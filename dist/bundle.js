(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var dispatchItModule = require('./php/src/MyApp/dispatchIt.php')();

// Hook stdout and stderr up to the DOM
dispatchItModule.getStdout().on('data', function (data) {
    document.body.insertAdjacentHTML('beforeEnd', data + '<br>');
});
dispatchItModule.getStderr().on('data', function (data) {
    document.body.insertAdjacentHTML('beforeEnd', data + '<br>');
});

dispatchItModule.execute();

},{"./php/src/MyApp/dispatchIt.php":173}],2:[function(require,module,exports){
(function (process,__filename){
/** vim: et:ts=4:sw=4:sts=4
 * @license amdefine 1.0.0 Copyright (c) 2011-2015, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/amdefine for details
 */

/*jslint node: true */
/*global module, process */
'use strict';

/**
 * Creates a define for node.
 * @param {Object} module the "module" object that is defined by Node for the
 * current module.
 * @param {Function} [requireFn]. Node's require function for the current module.
 * It only needs to be passed in Node versions before 0.5, when module.require
 * did not exist.
 * @returns {Function} a define function that is usable for the current node
 * module.
 */
function amdefine(module, requireFn) {
    'use strict';
    var defineCache = {},
        loaderCache = {},
        alreadyCalled = false,
        path = require('path'),
        makeRequire, stringRequire;

    /**
     * Trims the . and .. from an array of path segments.
     * It will keep a leading path segment if a .. will become
     * the first path segment, to help with module name lookups,
     * which act like paths, but can be remapped. But the end result,
     * all paths that use this function should look normalized.
     * NOTE: this method MODIFIES the input array.
     * @param {Array} ary the array of path segments.
     */
    function trimDots(ary) {
        var i, part;
        for (i = 0; ary[i]; i+= 1) {
            part = ary[i];
            if (part === '.') {
                ary.splice(i, 1);
                i -= 1;
            } else if (part === '..') {
                if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                    //End of the line. Keep at least one non-dot
                    //path segment at the front so it can be mapped
                    //correctly to disk. Otherwise, there is likely
                    //no path mapping for a path starting with '..'.
                    //This can still fail, but catches the most reasonable
                    //uses of ..
                    break;
                } else if (i > 0) {
                    ary.splice(i - 1, 2);
                    i -= 2;
                }
            }
        }
    }

    function normalize(name, baseName) {
        var baseParts;

        //Adjust any relative paths.
        if (name && name.charAt(0) === '.') {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                baseParts = baseName.split('/');
                baseParts = baseParts.slice(0, baseParts.length - 1);
                baseParts = baseParts.concat(name.split('/'));
                trimDots(baseParts);
                name = baseParts.join('/');
            }
        }

        return name;
    }

    /**
     * Create the normalize() function passed to a loader plugin's
     * normalize method.
     */
    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(id) {
        function load(value) {
            loaderCache[id] = value;
        }

        load.fromText = function (id, text) {
            //This one is difficult because the text can/probably uses
            //define, and any relative paths and requires should be relative
            //to that id was it would be found on disk. But this would require
            //bootstrapping a module/require fairly deeply from node core.
            //Not sure how best to go about that yet.
            throw new Error('amdefine does not implement load.fromText');
        };

        return load;
    }

    makeRequire = function (systemRequire, exports, module, relId) {
        function amdRequire(deps, callback) {
            if (typeof deps === 'string') {
                //Synchronous, single module require('')
                return stringRequire(systemRequire, exports, module, deps, relId);
            } else {
                //Array of dependencies with a callback.

                //Convert the dependencies to modules.
                deps = deps.map(function (depName) {
                    return stringRequire(systemRequire, exports, module, depName, relId);
                });

                //Wait for next tick to call back the require call.
                if (callback) {
                    process.nextTick(function () {
                        callback.apply(null, deps);
                    });
                }
            }
        }

        amdRequire.toUrl = function (filePath) {
            if (filePath.indexOf('.') === 0) {
                return normalize(filePath, path.dirname(module.filename));
            } else {
                return filePath;
            }
        };

        return amdRequire;
    };

    //Favor explicit value, passed in if the module wants to support Node 0.4.
    requireFn = requireFn || function req() {
        return module.require.apply(module, arguments);
    };

    function runFactory(id, deps, factory) {
        var r, e, m, result;

        if (id) {
            e = loaderCache[id] = {};
            m = {
                id: id,
                uri: __filename,
                exports: e
            };
            r = makeRequire(requireFn, e, m, id);
        } else {
            //Only support one define call per file
            if (alreadyCalled) {
                throw new Error('amdefine with no module ID cannot be called more than once per file.');
            }
            alreadyCalled = true;

            //Use the real variables from node
            //Use module.exports for exports, since
            //the exports in here is amdefine exports.
            e = module.exports;
            m = module;
            r = makeRequire(requireFn, e, m, module.id);
        }

        //If there are dependencies, they are strings, so need
        //to convert them to dependency values.
        if (deps) {
            deps = deps.map(function (depName) {
                return r(depName);
            });
        }

        //Call the factory with the right dependencies.
        if (typeof factory === 'function') {
            result = factory.apply(m.exports, deps);
        } else {
            result = factory;
        }

        if (result !== undefined) {
            m.exports = result;
            if (id) {
                loaderCache[id] = m.exports;
            }
        }
    }

    stringRequire = function (systemRequire, exports, module, id, relId) {
        //Split the ID by a ! so that
        var index = id.indexOf('!'),
            originalId = id,
            prefix, plugin;

        if (index === -1) {
            id = normalize(id, relId);

            //Straight module lookup. If it is one of the special dependencies,
            //deal with it, otherwise, delegate to node.
            if (id === 'require') {
                return makeRequire(systemRequire, exports, module, relId);
            } else if (id === 'exports') {
                return exports;
            } else if (id === 'module') {
                return module;
            } else if (loaderCache.hasOwnProperty(id)) {
                return loaderCache[id];
            } else if (defineCache[id]) {
                runFactory.apply(null, defineCache[id]);
                return loaderCache[id];
            } else {
                if(systemRequire) {
                    return systemRequire(originalId);
                } else {
                    throw new Error('No module with ID: ' + id);
                }
            }
        } else {
            //There is a plugin in play.
            prefix = id.substring(0, index);
            id = id.substring(index + 1, id.length);

            plugin = stringRequire(systemRequire, exports, module, prefix, relId);

            if (plugin.normalize) {
                id = plugin.normalize(id, makeNormalize(relId));
            } else {
                //Normalize the ID normally.
                id = normalize(id, relId);
            }

            if (loaderCache[id]) {
                return loaderCache[id];
            } else {
                plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});

                return loaderCache[id];
            }
        }
    };

    //Create a define function specific to the module asking for amdefine.
    function define(id, deps, factory) {
        if (Array.isArray(id)) {
            factory = deps;
            deps = id;
            id = undefined;
        } else if (typeof id !== 'string') {
            factory = id;
            id = deps = undefined;
        }

        if (deps && !Array.isArray(deps)) {
            factory = deps;
            deps = undefined;
        }

        if (!deps) {
            deps = ['require', 'exports', 'module'];
        }

        //Set up properties for this module. If an ID, then use
        //internal cache. If no ID, then use the external variables
        //for this node module.
        if (id) {
            //Put the module in deep freeze until there is a
            //require call for it.
            defineCache[id] = [id, deps, factory];
        } else {
            runFactory(id, deps, factory);
        }
    }

    //define.require, which has access to all the values in the
    //cache. Useful for AMD modules that all have IDs in the file,
    //but need to finally export a value to node based on one of those
    //IDs.
    define.require = function (id) {
        if (loaderCache[id]) {
            return loaderCache[id];
        }

        if (defineCache[id]) {
            runFactory.apply(null, defineCache[id]);
            return loaderCache[id];
        }
    };

    define.amd = {};

    return define;
}

module.exports = amdefine;

}).call(this,require('_process'),"/node_modules/amdefine/amdefine.js")
},{"_process":169,"path":42}],3:[function(require,module,exports){
(function (global){
/*
  Copyright (C) 2012-2014 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2015 Ingvar Stepanyan <me@rreverser.com>
  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>
  Copyright (C) 2012-2013 Michael Ficarra <escodegen.copyright@michael.ficarra.me>
  Copyright (C) 2012-2013 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2013 Irakli Gozalishvili <rfobic@gmail.com>
  Copyright (C) 2012 Robert Gust-Bardon <donate@robert.gust-bardon.org>
  Copyright (C) 2012 John Freeman <jfreeman08@gmail.com>
  Copyright (C) 2011-2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*global exports:true, require:true, global:true*/
(function () {
    'use strict';

    var Syntax,
        Precedence,
        BinaryPrecedence,
        SourceNode,
        estraverse,
        esutils,
        isArray,
        base,
        indent,
        json,
        renumber,
        hexadecimal,
        quotes,
        escapeless,
        newline,
        space,
        parentheses,
        semicolons,
        safeConcatenation,
        directive,
        extra,
        parse,
        sourceMap,
        sourceCode,
        preserveBlankLines,
        FORMAT_MINIFY,
        FORMAT_DEFAULTS;

    estraverse = require('estraverse');
    esutils = require('esutils');

    Syntax = estraverse.Syntax;

    // Generation is done by generateExpression.
    function isExpression(node) {
        return CodeGenerator.Expression.hasOwnProperty(node.type);
    }

    // Generation is done by generateStatement.
    function isStatement(node) {
        return CodeGenerator.Statement.hasOwnProperty(node.type);
    }

    Precedence = {
        Sequence: 0,
        Yield: 1,
        Await: 1,
        Assignment: 1,
        Conditional: 2,
        ArrowFunction: 2,
        LogicalOR: 3,
        LogicalAND: 4,
        BitwiseOR: 5,
        BitwiseXOR: 6,
        BitwiseAND: 7,
        Equality: 8,
        Relational: 9,
        BitwiseSHIFT: 10,
        Additive: 11,
        Multiplicative: 12,
        Unary: 13,
        Postfix: 14,
        Call: 15,
        New: 16,
        TaggedTemplate: 17,
        Member: 18,
        Primary: 19
    };

    BinaryPrecedence = {
        '||': Precedence.LogicalOR,
        '&&': Precedence.LogicalAND,
        '|': Precedence.BitwiseOR,
        '^': Precedence.BitwiseXOR,
        '&': Precedence.BitwiseAND,
        '==': Precedence.Equality,
        '!=': Precedence.Equality,
        '===': Precedence.Equality,
        '!==': Precedence.Equality,
        'is': Precedence.Equality,
        'isnt': Precedence.Equality,
        '<': Precedence.Relational,
        '>': Precedence.Relational,
        '<=': Precedence.Relational,
        '>=': Precedence.Relational,
        'in': Precedence.Relational,
        'instanceof': Precedence.Relational,
        '<<': Precedence.BitwiseSHIFT,
        '>>': Precedence.BitwiseSHIFT,
        '>>>': Precedence.BitwiseSHIFT,
        '+': Precedence.Additive,
        '-': Precedence.Additive,
        '*': Precedence.Multiplicative,
        '%': Precedence.Multiplicative,
        '/': Precedence.Multiplicative
    };

    //Flags
    var F_ALLOW_IN = 1,
        F_ALLOW_CALL = 1 << 1,
        F_ALLOW_UNPARATH_NEW = 1 << 2,
        F_FUNC_BODY = 1 << 3,
        F_DIRECTIVE_CTX = 1 << 4,
        F_SEMICOLON_OPT = 1 << 5;

    //Expression flag sets
    //NOTE: Flag order:
    // F_ALLOW_IN
    // F_ALLOW_CALL
    // F_ALLOW_UNPARATH_NEW
    var E_FTT = F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,
        E_TTF = F_ALLOW_IN | F_ALLOW_CALL,
        E_TTT = F_ALLOW_IN | F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,
        E_TFF = F_ALLOW_IN,
        E_FFT = F_ALLOW_UNPARATH_NEW,
        E_TFT = F_ALLOW_IN | F_ALLOW_UNPARATH_NEW;

    //Statement flag sets
    //NOTE: Flag order:
    // F_ALLOW_IN
    // F_FUNC_BODY
    // F_DIRECTIVE_CTX
    // F_SEMICOLON_OPT
    var S_TFFF = F_ALLOW_IN,
        S_TFFT = F_ALLOW_IN | F_SEMICOLON_OPT,
        S_FFFF = 0x00,
        S_TFTF = F_ALLOW_IN | F_DIRECTIVE_CTX,
        S_TTFF = F_ALLOW_IN | F_FUNC_BODY;

    function getDefaultOptions() {
        // default options
        return {
            indent: null,
            base: null,
            parse: null,
            comment: false,
            format: {
                indent: {
                    style: '    ',
                    base: 0,
                    adjustMultilineComment: false
                },
                newline: '\n',
                space: ' ',
                json: false,
                renumber: false,
                hexadecimal: false,
                quotes: 'single',
                escapeless: false,
                compact: false,
                parentheses: true,
                semicolons: true,
                safeConcatenation: false,
                preserveBlankLines: false
            },
            moz: {
                comprehensionExpressionStartsWithAssignment: false,
                starlessGenerator: false
            },
            sourceMap: null,
            sourceMapRoot: null,
            sourceMapWithCode: false,
            directive: false,
            raw: true,
            verbatim: null,
            sourceCode: null
        };
    }

    function stringRepeat(str, num) {
        var result = '';

        for (num |= 0; num > 0; num >>>= 1, str += str) {
            if (num & 1) {
                result += str;
            }
        }

        return result;
    }

    isArray = Array.isArray;
    if (!isArray) {
        isArray = function isArray(array) {
            return Object.prototype.toString.call(array) === '[object Array]';
        };
    }

    function hasLineTerminator(str) {
        return (/[\r\n]/g).test(str);
    }

    function endsWithLineTerminator(str) {
        var len = str.length;
        return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));
    }

    function merge(target, override) {
        var key;
        for (key in override) {
            if (override.hasOwnProperty(key)) {
                target[key] = override[key];
            }
        }
        return target;
    }

    function updateDeeply(target, override) {
        var key, val;

        function isHashObject(target) {
            return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);
        }

        for (key in override) {
            if (override.hasOwnProperty(key)) {
                val = override[key];
                if (isHashObject(val)) {
                    if (isHashObject(target[key])) {
                        updateDeeply(target[key], val);
                    } else {
                        target[key] = updateDeeply({}, val);
                    }
                } else {
                    target[key] = val;
                }
            }
        }
        return target;
    }

    function generateNumber(value) {
        var result, point, temp, exponent, pos;

        if (value !== value) {
            throw new Error('Numeric literal whose value is NaN');
        }
        if (value < 0 || (value === 0 && 1 / value < 0)) {
            throw new Error('Numeric literal whose value is negative');
        }

        if (value === 1 / 0) {
            return json ? 'null' : renumber ? '1e400' : '1e+400';
        }

        result = '' + value;
        if (!renumber || result.length < 3) {
            return result;
        }

        point = result.indexOf('.');
        if (!json && result.charCodeAt(0) === 0x30  /* 0 */ && point === 1) {
            point = 0;
            result = result.slice(1);
        }
        temp = result;
        result = result.replace('e+', 'e');
        exponent = 0;
        if ((pos = temp.indexOf('e')) > 0) {
            exponent = +temp.slice(pos + 1);
            temp = temp.slice(0, pos);
        }
        if (point >= 0) {
            exponent -= temp.length - point - 1;
            temp = +(temp.slice(0, point) + temp.slice(point + 1)) + '';
        }
        pos = 0;
        while (temp.charCodeAt(temp.length + pos - 1) === 0x30  /* 0 */) {
            --pos;
        }
        if (pos !== 0) {
            exponent -= pos;
            temp = temp.slice(0, pos);
        }
        if (exponent !== 0) {
            temp += 'e' + exponent;
        }
        if ((temp.length < result.length ||
                    (hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = '0x' + value.toString(16)).length < result.length)) &&
                +temp === value) {
            result = temp;
        }

        return result;
    }

    // Generate valid RegExp expression.
    // This function is based on https://github.com/Constellation/iv Engine

    function escapeRegExpCharacter(ch, previousIsBackslash) {
        // not handling '\' and handling \u2028 or \u2029 to unicode escape sequence
        if ((ch & ~1) === 0x2028) {
            return (previousIsBackslash ? 'u' : '\\u') + ((ch === 0x2028) ? '2028' : '2029');
        } else if (ch === 10 || ch === 13) {  // \n, \r
            return (previousIsBackslash ? '' : '\\') + ((ch === 10) ? 'n' : 'r');
        }
        return String.fromCharCode(ch);
    }

    function generateRegExp(reg) {
        var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;

        result = reg.toString();

        if (reg.source) {
            // extract flag from toString result
            match = result.match(/\/([^/]*)$/);
            if (!match) {
                return result;
            }

            flags = match[1];
            result = '';

            characterInBrack = false;
            previousIsBackslash = false;
            for (i = 0, iz = reg.source.length; i < iz; ++i) {
                ch = reg.source.charCodeAt(i);

                if (!previousIsBackslash) {
                    if (characterInBrack) {
                        if (ch === 93) {  // ]
                            characterInBrack = false;
                        }
                    } else {
                        if (ch === 47) {  // /
                            result += '\\';
                        } else if (ch === 91) {  // [
                            characterInBrack = true;
                        }
                    }
                    result += escapeRegExpCharacter(ch, previousIsBackslash);
                    previousIsBackslash = ch === 92;  // \
                } else {
                    // if new RegExp("\\\n') is provided, create /\n/
                    result += escapeRegExpCharacter(ch, previousIsBackslash);
                    // prevent like /\\[/]/
                    previousIsBackslash = false;
                }
            }

            return '/' + result + '/' + flags;
        }

        return result;
    }

    function escapeAllowedCharacter(code, next) {
        var hex;

        if (code === 0x08  /* \b */) {
            return '\\b';
        }

        if (code === 0x0C  /* \f */) {
            return '\\f';
        }

        if (code === 0x09  /* \t */) {
            return '\\t';
        }

        hex = code.toString(16).toUpperCase();
        if (json || code > 0xFF) {
            return '\\u' + '0000'.slice(hex.length) + hex;
        } else if (code === 0x0000 && !esutils.code.isDecimalDigit(next)) {
            return '\\0';
        } else if (code === 0x000B  /* \v */) { // '\v'
            return '\\x0B';
        } else {
            return '\\x' + '00'.slice(hex.length) + hex;
        }
    }

    function escapeDisallowedCharacter(code) {
        if (code === 0x5C  /* \ */) {
            return '\\\\';
        }

        if (code === 0x0A  /* \n */) {
            return '\\n';
        }

        if (code === 0x0D  /* \r */) {
            return '\\r';
        }

        if (code === 0x2028) {
            return '\\u2028';
        }

        if (code === 0x2029) {
            return '\\u2029';
        }

        throw new Error('Incorrectly classified character');
    }

    function escapeDirective(str) {
        var i, iz, code, quote;

        quote = quotes === 'double' ? '"' : '\'';
        for (i = 0, iz = str.length; i < iz; ++i) {
            code = str.charCodeAt(i);
            if (code === 0x27  /* ' */) {
                quote = '"';
                break;
            } else if (code === 0x22  /* " */) {
                quote = '\'';
                break;
            } else if (code === 0x5C  /* \ */) {
                ++i;
            }
        }

        return quote + str + quote;
    }

    function escapeString(str) {
        var result = '', i, len, code, singleQuotes = 0, doubleQuotes = 0, single, quote;

        for (i = 0, len = str.length; i < len; ++i) {
            code = str.charCodeAt(i);
            if (code === 0x27  /* ' */) {
                ++singleQuotes;
            } else if (code === 0x22  /* " */) {
                ++doubleQuotes;
            } else if (code === 0x2F  /* / */ && json) {
                result += '\\';
            } else if (esutils.code.isLineTerminator(code) || code === 0x5C  /* \ */) {
                result += escapeDisallowedCharacter(code);
                continue;
            } else if (!esutils.code.isIdentifierPartES5(code) && (json && code < 0x20  /* SP */ || !json && !escapeless && (code < 0x20  /* SP */ || code > 0x7E  /* ~ */))) {
                result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));
                continue;
            }
            result += String.fromCharCode(code);
        }

        single = !(quotes === 'double' || (quotes === 'auto' && doubleQuotes < singleQuotes));
        quote = single ? '\'' : '"';

        if (!(single ? singleQuotes : doubleQuotes)) {
            return quote + result + quote;
        }

        str = result;
        result = quote;

        for (i = 0, len = str.length; i < len; ++i) {
            code = str.charCodeAt(i);
            if ((code === 0x27  /* ' */ && single) || (code === 0x22  /* " */ && !single)) {
                result += '\\';
            }
            result += String.fromCharCode(code);
        }

        return result + quote;
    }

    /**
     * flatten an array to a string, where the array can contain
     * either strings or nested arrays
     */
    function flattenToString(arr) {
        var i, iz, elem, result = '';
        for (i = 0, iz = arr.length; i < iz; ++i) {
            elem = arr[i];
            result += isArray(elem) ? flattenToString(elem) : elem;
        }
        return result;
    }

    /**
     * convert generated to a SourceNode when source maps are enabled.
     */
    function toSourceNodeWhenNeeded(generated, node) {
        if (!sourceMap) {
            // with no source maps, generated is either an
            // array or a string.  if an array, flatten it.
            // if a string, just return it
            if (isArray(generated)) {
                return flattenToString(generated);
            } else {
                return generated;
            }
        }
        if (node == null) {
            if (generated instanceof SourceNode) {
                return generated;
            } else {
                node = {};
            }
        }
        if (node.loc == null) {
            return new SourceNode(null, null, sourceMap, generated, node.name || null);
        }
        return new SourceNode(node.loc.start.line, node.loc.start.column, (sourceMap === true ? node.loc.source || null : sourceMap), generated, node.name || null);
    }

    function noEmptySpace() {
        return (space) ? space : ' ';
    }

    function join(left, right) {
        var leftSource,
            rightSource,
            leftCharCode,
            rightCharCode;

        leftSource = toSourceNodeWhenNeeded(left).toString();
        if (leftSource.length === 0) {
            return [right];
        }

        rightSource = toSourceNodeWhenNeeded(right).toString();
        if (rightSource.length === 0) {
            return [left];
        }

        leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
        rightCharCode = rightSource.charCodeAt(0);

        if ((leftCharCode === 0x2B  /* + */ || leftCharCode === 0x2D  /* - */) && leftCharCode === rightCharCode ||
            esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode) ||
            leftCharCode === 0x2F  /* / */ && rightCharCode === 0x69  /* i */) { // infix word operators all start with `i`
            return [left, noEmptySpace(), right];
        } else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) ||
                esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {
            return [left, right];
        }
        return [left, space, right];
    }

    function addIndent(stmt) {
        return [base, stmt];
    }

    function withIndent(fn) {
        var previousBase;
        previousBase = base;
        base += indent;
        fn(base);
        base = previousBase;
    }

    function calculateSpaces(str) {
        var i;
        for (i = str.length - 1; i >= 0; --i) {
            if (esutils.code.isLineTerminator(str.charCodeAt(i))) {
                break;
            }
        }
        return (str.length - 1) - i;
    }

    function adjustMultilineComment(value, specialBase) {
        var array, i, len, line, j, spaces, previousBase, sn;

        array = value.split(/\r\n|[\r\n]/);
        spaces = Number.MAX_VALUE;

        // first line doesn't have indentation
        for (i = 1, len = array.length; i < len; ++i) {
            line = array[i];
            j = 0;
            while (j < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j))) {
                ++j;
            }
            if (spaces > j) {
                spaces = j;
            }
        }

        if (typeof specialBase !== 'undefined') {
            // pattern like
            // {
            //   var t = 20;  /*
            //                 * this is comment
            //                 */
            // }
            previousBase = base;
            if (array[1][spaces] === '*') {
                specialBase += ' ';
            }
            base = specialBase;
        } else {
            if (spaces & 1) {
                // /*
                //  *
                //  */
                // If spaces are odd number, above pattern is considered.
                // We waste 1 space.
                --spaces;
            }
            previousBase = base;
        }

        for (i = 1, len = array.length; i < len; ++i) {
            sn = toSourceNodeWhenNeeded(addIndent(array[i].slice(spaces)));
            array[i] = sourceMap ? sn.join('') : sn;
        }

        base = previousBase;

        return array.join('\n');
    }

    function generateComment(comment, specialBase) {
        if (comment.type === 'Line') {
            if (endsWithLineTerminator(comment.value)) {
                return '//' + comment.value;
            } else {
                // Always use LineTerminator
                var result = '//' + comment.value;
                if (!preserveBlankLines) {
                    result += '\n';
                }
                return result;
            }
        }
        if (extra.format.indent.adjustMultilineComment && /[\n\r]/.test(comment.value)) {
            return adjustMultilineComment('/*' + comment.value + '*/', specialBase);
        }
        return '/*' + comment.value + '*/';
    }

    function addComments(stmt, result) {
        var i, len, comment, save, tailingToStatement, specialBase, fragment,
            extRange, range, prevRange, prefix, infix, suffix, count;

        if (stmt.leadingComments && stmt.leadingComments.length > 0) {
            save = result;

            if (preserveBlankLines) {
                comment = stmt.leadingComments[0];
                result = [];

                extRange = comment.extendedRange;
                range = comment.range;

                prefix = sourceCode.substring(extRange[0], range[0]);
                count = (prefix.match(/\n/g) || []).length;
                if (count > 0) {
                    result.push(stringRepeat('\n', count));
                    result.push(addIndent(generateComment(comment)));
                } else {
                    result.push(prefix);
                    result.push(generateComment(comment));
                }

                prevRange = range;

                for (i = 1, len = stmt.leadingComments.length; i < len; i++) {
                    comment = stmt.leadingComments[i];
                    range = comment.range;

                    infix = sourceCode.substring(prevRange[1], range[0]);
                    count = (infix.match(/\n/g) || []).length;
                    result.push(stringRepeat('\n', count));
                    result.push(addIndent(generateComment(comment)));

                    prevRange = range;
                }

                suffix = sourceCode.substring(range[1], extRange[1]);
                count = (suffix.match(/\n/g) || []).length;
                result.push(stringRepeat('\n', count));
            } else {
                comment = stmt.leadingComments[0];
                result = [];
                if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {
                    result.push('\n');
                }
                result.push(generateComment(comment));
                if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                    result.push('\n');
                }

                for (i = 1, len = stmt.leadingComments.length; i < len; ++i) {
                    comment = stmt.leadingComments[i];
                    fragment = [generateComment(comment)];
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        fragment.push('\n');
                    }
                    result.push(addIndent(fragment));
                }
            }

            result.push(addIndent(save));
        }

        if (stmt.trailingComments) {

            if (preserveBlankLines) {
                comment = stmt.trailingComments[0];
                extRange = comment.extendedRange;
                range = comment.range;

                prefix = sourceCode.substring(extRange[0], range[0]);
                count = (prefix.match(/\n/g) || []).length;

                if (count > 0) {
                    result.push(stringRepeat('\n', count));
                    result.push(addIndent(generateComment(comment)));
                } else {
                    result.push(prefix);
                    result.push(generateComment(comment));
                }
            } else {
                tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
                specialBase = stringRepeat(' ', calculateSpaces(toSourceNodeWhenNeeded([base, result, indent]).toString()));
                for (i = 0, len = stmt.trailingComments.length; i < len; ++i) {
                    comment = stmt.trailingComments[i];
                    if (tailingToStatement) {
                        // We assume target like following script
                        //
                        // var t = 20;  /**
                        //               * This is comment of t
                        //               */
                        if (i === 0) {
                            // first case
                            result = [result, indent];
                        } else {
                            result = [result, specialBase];
                        }
                        result.push(generateComment(comment, specialBase));
                    } else {
                        result = [result, addIndent(generateComment(comment))];
                    }
                    if (i !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                        result = [result, '\n'];
                    }
                }
            }
        }

        return result;
    }

    function generateBlankLines(start, end, result) {
        var j, newlineCount = 0;

        for (j = start; j < end; j++) {
            if (sourceCode[j] === '\n') {
                newlineCount++;
            }
        }

        for (j = 1; j < newlineCount; j++) {
            result.push(newline);
        }
    }

    function parenthesize(text, current, should) {
        if (current < should) {
            return ['(', text, ')'];
        }
        return text;
    }

    function generateVerbatimString(string) {
        var i, iz, result;
        result = string.split(/\r\n|\n/);
        for (i = 1, iz = result.length; i < iz; i++) {
            result[i] = newline + base + result[i];
        }
        return result;
    }

    function generateVerbatim(expr, precedence) {
        var verbatim, result, prec;
        verbatim = expr[extra.verbatim];

        if (typeof verbatim === 'string') {
            result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, precedence);
        } else {
            // verbatim is object
            result = generateVerbatimString(verbatim.content);
            prec = (verbatim.precedence != null) ? verbatim.precedence : Precedence.Sequence;
            result = parenthesize(result, prec, precedence);
        }

        return toSourceNodeWhenNeeded(result, expr);
    }

    function CodeGenerator() {
    }

    // Helpers.

    CodeGenerator.prototype.maybeBlock = function(stmt, flags) {
        var result, noLeadingComment, that = this;

        noLeadingComment = !extra.comment || !stmt.leadingComments;

        if (stmt.type === Syntax.BlockStatement && noLeadingComment) {
            return [space, this.generateStatement(stmt, flags)];
        }

        if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {
            return ';';
        }

        withIndent(function () {
            result = [
                newline,
                addIndent(that.generateStatement(stmt, flags))
            ];
        });

        return result;
    };

    CodeGenerator.prototype.maybeBlockSuffix = function (stmt, result) {
        var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
        if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {
            return [result, space];
        }
        if (ends) {
            return [result, base];
        }
        return [result, newline, base];
    };

    function generateIdentifier(node) {
        return toSourceNodeWhenNeeded(node.name, node);
    }

    function generateAsyncPrefix(node, spaceRequired) {
        return node.async ? 'async' + (spaceRequired ? noEmptySpace() : space) : '';
    }

    function generateStarSuffix(node) {
        var isGenerator = node.generator && !extra.moz.starlessGenerator;
        return isGenerator ? '*' + space : '';
    }

    function generateMethodPrefix(prop) {
        var func = prop.value;
        if (func.async) {
            return generateAsyncPrefix(func, !prop.computed);
        } else {
            // avoid space before method name
            return generateStarSuffix(func) ? '*' : '';
        }
    }

    CodeGenerator.prototype.generatePattern = function (node, precedence, flags) {
        if (node.type === Syntax.Identifier) {
            return generateIdentifier(node);
        }
        return this.generateExpression(node, precedence, flags);
    };

    CodeGenerator.prototype.generateFunctionParams = function (node) {
        var i, iz, result, hasDefault;

        hasDefault = false;

        if (node.type === Syntax.ArrowFunctionExpression &&
                !node.rest && (!node.defaults || node.defaults.length === 0) &&
                node.params.length === 1 && node.params[0].type === Syntax.Identifier) {
            // arg => { } case
            result = [generateAsyncPrefix(node, true), generateIdentifier(node.params[0])];
        } else {
            result = node.type === Syntax.ArrowFunctionExpression ? [generateAsyncPrefix(node, false)] : [];
            result.push('(');
            if (node.defaults) {
                hasDefault = true;
            }
            for (i = 0, iz = node.params.length; i < iz; ++i) {
                if (hasDefault && node.defaults[i]) {
                    // Handle default values.
                    result.push(this.generateAssignment(node.params[i], node.defaults[i], '=', Precedence.Assignment, E_TTT));
                } else {
                    result.push(this.generatePattern(node.params[i], Precedence.Assignment, E_TTT));
                }
                if (i + 1 < iz) {
                    result.push(',' + space);
                }
            }

            if (node.rest) {
                if (node.params.length) {
                    result.push(',' + space);
                }
                result.push('...');
                result.push(generateIdentifier(node.rest));
            }

            result.push(')');
        }

        return result;
    };

    CodeGenerator.prototype.generateFunctionBody = function (node) {
        var result, expr;

        result = this.generateFunctionParams(node);

        if (node.type === Syntax.ArrowFunctionExpression) {
            result.push(space);
            result.push('=>');
        }

        if (node.expression) {
            result.push(space);
            expr = this.generateExpression(node.body, Precedence.Assignment, E_TTT);
            if (expr.toString().charAt(0) === '{') {
                expr = ['(', expr, ')'];
            }
            result.push(expr);
        } else {
            result.push(this.maybeBlock(node.body, S_TTFF));
        }

        return result;
    };

    CodeGenerator.prototype.generateIterationForStatement = function (operator, stmt, flags) {
        var result = ['for' + space + '('], that = this;
        withIndent(function () {
            if (stmt.left.type === Syntax.VariableDeclaration) {
                withIndent(function () {
                    result.push(stmt.left.kind + noEmptySpace());
                    result.push(that.generateStatement(stmt.left.declarations[0], S_FFFF));
                });
            } else {
                result.push(that.generateExpression(stmt.left, Precedence.Call, E_TTT));
            }

            result = join(result, operator);
            result = [join(
                result,
                that.generateExpression(stmt.right, Precedence.Sequence, E_TTT)
            ), ')'];
        });
        result.push(this.maybeBlock(stmt.body, flags));
        return result;
    };

    CodeGenerator.prototype.generatePropertyKey = function (expr, computed, value) {
        var result = [];

        if (computed) {
            result.push('[');
        }

        if (value.type === 'AssignmentPattern') {
            result.push(this.AssignmentPattern(value, Precedence.Sequence, E_TTT));
        } else {
            result.push(this.generateExpression(expr, Precedence.Sequence, E_TTT));
        }

        if (computed) {
            result.push(']');
        }

        return result;
    };

    CodeGenerator.prototype.generateAssignment = function (left, right, operator, precedence, flags) {
        if (Precedence.Assignment < precedence) {
            flags |= F_ALLOW_IN;
        }

        return parenthesize(
            [
                this.generateExpression(left, Precedence.Call, flags),
                space + operator + space,
                this.generateExpression(right, Precedence.Assignment, flags)
            ],
            Precedence.Assignment,
            precedence
        );
    };

    CodeGenerator.prototype.semicolon = function (flags) {
        if (!semicolons && flags & F_SEMICOLON_OPT) {
            return '';
        }
        return ';';
    };

    // Statements.

    CodeGenerator.Statement = {

        BlockStatement: function (stmt, flags) {
            var range, content, result = ['{', newline], that = this;

            withIndent(function () {
                // handle functions without any code
                if (stmt.body.length === 0 && preserveBlankLines) {
                    range = stmt.range;
                    if (range[1] - range[0] > 2) {
                        content = sourceCode.substring(range[0] + 1, range[1] - 1);
                        if (content[0] === '\n') {
                            result = ['{'];
                        }
                        result.push(content);
                    }
                }

                var i, iz, fragment, bodyFlags;
                bodyFlags = S_TFFF;
                if (flags & F_FUNC_BODY) {
                    bodyFlags |= F_DIRECTIVE_CTX;
                }

                for (i = 0, iz = stmt.body.length; i < iz; ++i) {
                    if (preserveBlankLines) {
                        // handle spaces before the first line
                        if (i === 0) {
                            if (stmt.body[0].leadingComments) {
                                range = stmt.body[0].leadingComments[0].extendedRange;
                                content = sourceCode.substring(range[0], range[1]);
                                if (content[0] === '\n') {
                                    result = ['{'];
                                }
                            }
                            if (!stmt.body[0].leadingComments) {
                                generateBlankLines(stmt.range[0], stmt.body[0].range[0], result);
                            }
                        }

                        // handle spaces between lines
                        if (i > 0) {
                            if (!stmt.body[i - 1].trailingComments  && !stmt.body[i].leadingComments) {
                                generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
                            }
                        }
                    }

                    if (i === iz - 1) {
                        bodyFlags |= F_SEMICOLON_OPT;
                    }

                    if (stmt.body[i].leadingComments && preserveBlankLines) {
                        fragment = that.generateStatement(stmt.body[i], bodyFlags);
                    } else {
                        fragment = addIndent(that.generateStatement(stmt.body[i], bodyFlags));
                    }

                    result.push(fragment);
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        if (preserveBlankLines && i < iz - 1) {
                            // don't add a new line if there are leading coments
                            // in the next statement
                            if (!stmt.body[i + 1].leadingComments) {
                                result.push(newline);
                            }
                        } else {
                            result.push(newline);
                        }
                    }

                    if (preserveBlankLines) {
                        // handle spaces after the last line
                        if (i === iz - 1) {
                            if (!stmt.body[i].trailingComments) {
                                generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
                            }
                        }
                    }
                }
            });

            result.push(addIndent('}'));
            return result;
        },

        BreakStatement: function (stmt, flags) {
            if (stmt.label) {
                return 'break ' + stmt.label.name + this.semicolon(flags);
            }
            return 'break' + this.semicolon(flags);
        },

        ContinueStatement: function (stmt, flags) {
            if (stmt.label) {
                return 'continue ' + stmt.label.name + this.semicolon(flags);
            }
            return 'continue' + this.semicolon(flags);
        },

        ClassBody: function (stmt, flags) {
            var result = [ '{', newline], that = this;

            withIndent(function (indent) {
                var i, iz;

                for (i = 0, iz = stmt.body.length; i < iz; ++i) {
                    result.push(indent);
                    result.push(that.generateExpression(stmt.body[i], Precedence.Sequence, E_TTT));
                    if (i + 1 < iz) {
                        result.push(newline);
                    }
                }
            });

            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(base);
            result.push('}');
            return result;
        },

        ClassDeclaration: function (stmt, flags) {
            var result, fragment;
            result  = ['class'];
            if (stmt.id) {
                result = join(result, this.generateExpression(stmt.id, Precedence.Sequence, E_TTT));
            }
            if (stmt.superClass) {
                fragment = join('extends', this.generateExpression(stmt.superClass, Precedence.Assignment, E_TTT));
                result = join(result, fragment);
            }
            result.push(space);
            result.push(this.generateStatement(stmt.body, S_TFFT));
            return result;
        },

        DirectiveStatement: function (stmt, flags) {
            if (extra.raw && stmt.raw) {
                return stmt.raw + this.semicolon(flags);
            }
            return escapeDirective(stmt.directive) + this.semicolon(flags);
        },

        DoWhileStatement: function (stmt, flags) {
            // Because `do 42 while (cond)` is Syntax Error. We need semicolon.
            var result = join('do', this.maybeBlock(stmt.body, S_TFFF));
            result = this.maybeBlockSuffix(stmt.body, result);
            return join(result, [
                'while' + space + '(',
                this.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
                ')' + this.semicolon(flags)
            ]);
        },

        CatchClause: function (stmt, flags) {
            var result, that = this;
            withIndent(function () {
                var guard;

                result = [
                    'catch' + space + '(',
                    that.generateExpression(stmt.param, Precedence.Sequence, E_TTT),
                    ')'
                ];

                if (stmt.guard) {
                    guard = that.generateExpression(stmt.guard, Precedence.Sequence, E_TTT);
                    result.splice(2, 0, ' if ', guard);
                }
            });
            result.push(this.maybeBlock(stmt.body, S_TFFF));
            return result;
        },

        DebuggerStatement: function (stmt, flags) {
            return 'debugger' + this.semicolon(flags);
        },

        EmptyStatement: function (stmt, flags) {
            return ';';
        },

        ExportDefaultDeclaration: function (stmt, flags) {
            var result = [ 'export' ], bodyFlags;

            bodyFlags = (flags & F_SEMICOLON_OPT) ? S_TFFT : S_TFFF;

            // export default HoistableDeclaration[Default]
            // export default AssignmentExpression[In] ;
            result = join(result, 'default');
            if (isStatement(stmt.declaration)) {
                result = join(result, this.generateStatement(stmt.declaration, bodyFlags));
            } else {
                result = join(result, this.generateExpression(stmt.declaration, Precedence.Assignment, E_TTT) + this.semicolon(flags));
            }
            return result;
        },

        ExportNamedDeclaration: function (stmt, flags) {
            var result = [ 'export' ], bodyFlags, that = this;

            bodyFlags = (flags & F_SEMICOLON_OPT) ? S_TFFT : S_TFFF;

            // export VariableStatement
            // export Declaration[Default]
            if (stmt.declaration) {
                return join(result, this.generateStatement(stmt.declaration, bodyFlags));
            }

            // export ExportClause[NoReference] FromClause ;
            // export ExportClause ;
            if (stmt.specifiers) {
                if (stmt.specifiers.length === 0) {
                    result = join(result, '{' + space + '}');
                } else if (stmt.specifiers[0].type === Syntax.ExportBatchSpecifier) {
                    result = join(result, this.generateExpression(stmt.specifiers[0], Precedence.Sequence, E_TTT));
                } else {
                    result = join(result, '{');
                    withIndent(function (indent) {
                        var i, iz;
                        result.push(newline);
                        for (i = 0, iz = stmt.specifiers.length; i < iz; ++i) {
                            result.push(indent);
                            result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));
                            if (i + 1 < iz) {
                                result.push(',' + newline);
                            }
                        }
                    });
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                        result.push(newline);
                    }
                    result.push(base + '}');
                }

                if (stmt.source) {
                    result = join(result, [
                        'from' + space,
                        // ModuleSpecifier
                        this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                        this.semicolon(flags)
                    ]);
                } else {
                    result.push(this.semicolon(flags));
                }
            }
            return result;
        },

        ExportAllDeclaration: function (stmt, flags) {
            // export * FromClause ;
            return [
                'export' + space,
                '*' + space,
                'from' + space,
                // ModuleSpecifier
                this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                this.semicolon(flags)
            ];
        },

        ExpressionStatement: function (stmt, flags) {
            var result, fragment;

            function isClassPrefixed(fragment) {
                var code;
                if (fragment.slice(0, 5) !== 'class') {
                    return false;
                }
                code = fragment.charCodeAt(5);
                return code === 0x7B  /* '{' */ || esutils.code.isWhiteSpace(code) || esutils.code.isLineTerminator(code);
            }

            function isFunctionPrefixed(fragment) {
                var code;
                if (fragment.slice(0, 8) !== 'function') {
                    return false;
                }
                code = fragment.charCodeAt(8);
                return code === 0x28 /* '(' */ || esutils.code.isWhiteSpace(code) || code === 0x2A  /* '*' */ || esutils.code.isLineTerminator(code);
            }

            function isAsyncPrefixed(fragment) {
                var code, i, iz;
                if (fragment.slice(0, 5) !== 'async') {
                    return false;
                }
                if (!esutils.code.isWhiteSpace(fragment.charCodeAt(5))) {
                    return false;
                }
                for (i = 6, iz = fragment.length; i < iz; ++i) {
                    if (!esutils.code.isWhiteSpace(fragment.charCodeAt(i))) {
                        break;
                    }
                }
                if (i === iz) {
                    return false;
                }
                if (fragment.slice(i, i + 8) !== 'function') {
                    return false;
                }
                code = fragment.charCodeAt(i + 8);
                return code === 0x28 /* '(' */ || esutils.code.isWhiteSpace(code) || code === 0x2A  /* '*' */ || esutils.code.isLineTerminator(code);
            }

            result = [this.generateExpression(stmt.expression, Precedence.Sequence, E_TTT)];
            // 12.4 '{', 'function', 'class' is not allowed in this position.
            // wrap expression with parentheses
            fragment = toSourceNodeWhenNeeded(result).toString();
            if (fragment.charCodeAt(0) === 0x7B  /* '{' */ ||  // ObjectExpression
                    isClassPrefixed(fragment) ||
                    isFunctionPrefixed(fragment) ||
                    isAsyncPrefixed(fragment) ||
                    (directive && (flags & F_DIRECTIVE_CTX) && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === 'string')) {
                result = ['(', result, ')' + this.semicolon(flags)];
            } else {
                result.push(this.semicolon(flags));
            }
            return result;
        },

        ImportDeclaration: function (stmt, flags) {
            // ES6: 15.2.1 valid import declarations:
            //     - import ImportClause FromClause ;
            //     - import ModuleSpecifier ;
            var result, cursor, that = this;

            // If no ImportClause is present,
            // this should be `import ModuleSpecifier` so skip `from`
            // ModuleSpecifier is StringLiteral.
            if (stmt.specifiers.length === 0) {
                // import ModuleSpecifier ;
                return [
                    'import',
                    space,
                    // ModuleSpecifier
                    this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                    this.semicolon(flags)
                ];
            }

            // import ImportClause FromClause ;
            result = [
                'import'
            ];
            cursor = 0;

            // ImportedBinding
            if (stmt.specifiers[cursor].type === Syntax.ImportDefaultSpecifier) {
                result = join(result, [
                        this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
                ]);
                ++cursor;
            }

            if (stmt.specifiers[cursor]) {
                if (cursor !== 0) {
                    result.push(',');
                }

                if (stmt.specifiers[cursor].type === Syntax.ImportNamespaceSpecifier) {
                    // NameSpaceImport
                    result = join(result, [
                            space,
                            this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
                    ]);
                } else {
                    // NamedImports
                    result.push(space + '{');

                    if ((stmt.specifiers.length - cursor) === 1) {
                        // import { ... } from "...";
                        result.push(space);
                        result.push(this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT));
                        result.push(space + '}' + space);
                    } else {
                        // import {
                        //    ...,
                        //    ...,
                        // } from "...";
                        withIndent(function (indent) {
                            var i, iz;
                            result.push(newline);
                            for (i = cursor, iz = stmt.specifiers.length; i < iz; ++i) {
                                result.push(indent);
                                result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));
                                if (i + 1 < iz) {
                                    result.push(',' + newline);
                                }
                            }
                        });
                        if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                            result.push(newline);
                        }
                        result.push(base + '}' + space);
                    }
                }
            }

            result = join(result, [
                'from' + space,
                // ModuleSpecifier
                this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                this.semicolon(flags)
            ]);
            return result;
        },

        VariableDeclarator: function (stmt, flags) {
            var itemFlags = (flags & F_ALLOW_IN) ? E_TTT : E_FTT;
            if (stmt.init) {
                return [
                    this.generateExpression(stmt.id, Precedence.Assignment, itemFlags),
                    space,
                    '=',
                    space,
                    this.generateExpression(stmt.init, Precedence.Assignment, itemFlags)
                ];
            }
            return this.generatePattern(stmt.id, Precedence.Assignment, itemFlags);
        },

        VariableDeclaration: function (stmt, flags) {
            // VariableDeclarator is typed as Statement,
            // but joined with comma (not LineTerminator).
            // So if comment is attached to target node, we should specialize.
            var result, i, iz, node, bodyFlags, that = this;

            result = [ stmt.kind ];

            bodyFlags = (flags & F_ALLOW_IN) ? S_TFFF : S_FFFF;

            function block() {
                node = stmt.declarations[0];
                if (extra.comment && node.leadingComments) {
                    result.push('\n');
                    result.push(addIndent(that.generateStatement(node, bodyFlags)));
                } else {
                    result.push(noEmptySpace());
                    result.push(that.generateStatement(node, bodyFlags));
                }

                for (i = 1, iz = stmt.declarations.length; i < iz; ++i) {
                    node = stmt.declarations[i];
                    if (extra.comment && node.leadingComments) {
                        result.push(',' + newline);
                        result.push(addIndent(that.generateStatement(node, bodyFlags)));
                    } else {
                        result.push(',' + space);
                        result.push(that.generateStatement(node, bodyFlags));
                    }
                }
            }

            if (stmt.declarations.length > 1) {
                withIndent(block);
            } else {
                block();
            }

            result.push(this.semicolon(flags));

            return result;
        },

        ThrowStatement: function (stmt, flags) {
            return [join(
                'throw',
                this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)
            ), this.semicolon(flags)];
        },

        TryStatement: function (stmt, flags) {
            var result, i, iz, guardedHandlers;

            result = ['try', this.maybeBlock(stmt.block, S_TFFF)];
            result = this.maybeBlockSuffix(stmt.block, result);

            if (stmt.handlers) {
                // old interface
                for (i = 0, iz = stmt.handlers.length; i < iz; ++i) {
                    result = join(result, this.generateStatement(stmt.handlers[i], S_TFFF));
                    if (stmt.finalizer || i + 1 !== iz) {
                        result = this.maybeBlockSuffix(stmt.handlers[i].body, result);
                    }
                }
            } else {
                guardedHandlers = stmt.guardedHandlers || [];

                for (i = 0, iz = guardedHandlers.length; i < iz; ++i) {
                    result = join(result, this.generateStatement(guardedHandlers[i], S_TFFF));
                    if (stmt.finalizer || i + 1 !== iz) {
                        result = this.maybeBlockSuffix(guardedHandlers[i].body, result);
                    }
                }

                // new interface
                if (stmt.handler) {
                    if (isArray(stmt.handler)) {
                        for (i = 0, iz = stmt.handler.length; i < iz; ++i) {
                            result = join(result, this.generateStatement(stmt.handler[i], S_TFFF));
                            if (stmt.finalizer || i + 1 !== iz) {
                                result = this.maybeBlockSuffix(stmt.handler[i].body, result);
                            }
                        }
                    } else {
                        result = join(result, this.generateStatement(stmt.handler, S_TFFF));
                        if (stmt.finalizer) {
                            result = this.maybeBlockSuffix(stmt.handler.body, result);
                        }
                    }
                }
            }
            if (stmt.finalizer) {
                result = join(result, ['finally', this.maybeBlock(stmt.finalizer, S_TFFF)]);
            }
            return result;
        },

        SwitchStatement: function (stmt, flags) {
            var result, fragment, i, iz, bodyFlags, that = this;
            withIndent(function () {
                result = [
                    'switch' + space + '(',
                    that.generateExpression(stmt.discriminant, Precedence.Sequence, E_TTT),
                    ')' + space + '{' + newline
                ];
            });
            if (stmt.cases) {
                bodyFlags = S_TFFF;
                for (i = 0, iz = stmt.cases.length; i < iz; ++i) {
                    if (i === iz - 1) {
                        bodyFlags |= F_SEMICOLON_OPT;
                    }
                    fragment = addIndent(this.generateStatement(stmt.cases[i], bodyFlags));
                    result.push(fragment);
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        result.push(newline);
                    }
                }
            }
            result.push(addIndent('}'));
            return result;
        },

        SwitchCase: function (stmt, flags) {
            var result, fragment, i, iz, bodyFlags, that = this;
            withIndent(function () {
                if (stmt.test) {
                    result = [
                        join('case', that.generateExpression(stmt.test, Precedence.Sequence, E_TTT)),
                        ':'
                    ];
                } else {
                    result = ['default:'];
                }

                i = 0;
                iz = stmt.consequent.length;
                if (iz && stmt.consequent[0].type === Syntax.BlockStatement) {
                    fragment = that.maybeBlock(stmt.consequent[0], S_TFFF);
                    result.push(fragment);
                    i = 1;
                }

                if (i !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                    result.push(newline);
                }

                bodyFlags = S_TFFF;
                for (; i < iz; ++i) {
                    if (i === iz - 1 && flags & F_SEMICOLON_OPT) {
                        bodyFlags |= F_SEMICOLON_OPT;
                    }
                    fragment = addIndent(that.generateStatement(stmt.consequent[i], bodyFlags));
                    result.push(fragment);
                    if (i + 1 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        result.push(newline);
                    }
                }
            });
            return result;
        },

        IfStatement: function (stmt, flags) {
            var result, bodyFlags, semicolonOptional, that = this;
            withIndent(function () {
                result = [
                    'if' + space + '(',
                    that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
                    ')'
                ];
            });
            semicolonOptional = flags & F_SEMICOLON_OPT;
            bodyFlags = S_TFFF;
            if (semicolonOptional) {
                bodyFlags |= F_SEMICOLON_OPT;
            }
            if (stmt.alternate) {
                result.push(this.maybeBlock(stmt.consequent, S_TFFF));
                result = this.maybeBlockSuffix(stmt.consequent, result);
                if (stmt.alternate.type === Syntax.IfStatement) {
                    result = join(result, ['else ', this.generateStatement(stmt.alternate, bodyFlags)]);
                } else {
                    result = join(result, join('else', this.maybeBlock(stmt.alternate, bodyFlags)));
                }
            } else {
                result.push(this.maybeBlock(stmt.consequent, bodyFlags));
            }
            return result;
        },

        ForStatement: function (stmt, flags) {
            var result, that = this;
            withIndent(function () {
                result = ['for' + space + '('];
                if (stmt.init) {
                    if (stmt.init.type === Syntax.VariableDeclaration) {
                        result.push(that.generateStatement(stmt.init, S_FFFF));
                    } else {
                        // F_ALLOW_IN becomes false.
                        result.push(that.generateExpression(stmt.init, Precedence.Sequence, E_FTT));
                        result.push(';');
                    }
                } else {
                    result.push(';');
                }

                if (stmt.test) {
                    result.push(space);
                    result.push(that.generateExpression(stmt.test, Precedence.Sequence, E_TTT));
                    result.push(';');
                } else {
                    result.push(';');
                }

                if (stmt.update) {
                    result.push(space);
                    result.push(that.generateExpression(stmt.update, Precedence.Sequence, E_TTT));
                    result.push(')');
                } else {
                    result.push(')');
                }
            });

            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
            return result;
        },

        ForInStatement: function (stmt, flags) {
            return this.generateIterationForStatement('in', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
        },

        ForOfStatement: function (stmt, flags) {
            return this.generateIterationForStatement('of', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
        },

        LabeledStatement: function (stmt, flags) {
            return [stmt.label.name + ':', this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)];
        },

        Program: function (stmt, flags) {
            var result, fragment, i, iz, bodyFlags;
            iz = stmt.body.length;
            result = [safeConcatenation && iz > 0 ? '\n' : ''];
            bodyFlags = S_TFTF;
            for (i = 0; i < iz; ++i) {
                if (!safeConcatenation && i === iz - 1) {
                    bodyFlags |= F_SEMICOLON_OPT;
                }

                if (preserveBlankLines) {
                    // handle spaces before the first line
                    if (i === 0) {
                        if (!stmt.body[0].leadingComments) {
                            generateBlankLines(stmt.range[0], stmt.body[i].range[0], result);
                        }
                    }

                    // handle spaces between lines
                    if (i > 0) {
                        if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {
                            generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
                        }
                    }
                }

                fragment = addIndent(this.generateStatement(stmt.body[i], bodyFlags));
                result.push(fragment);
                if (i + 1 < iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                    if (preserveBlankLines) {
                        if (!stmt.body[i + 1].leadingComments) {
                            result.push(newline);
                        }
                    } else {
                        result.push(newline);
                    }
                }

                if (preserveBlankLines) {
                    // handle spaces after the last line
                    if (i === iz - 1) {
                        if (!stmt.body[i].trailingComments) {
                            generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
                        }
                    }
                }
            }
            return result;
        },

        FunctionDeclaration: function (stmt, flags) {
            return [
                generateAsyncPrefix(stmt, true),
                'function',
                generateStarSuffix(stmt) || noEmptySpace(),
                stmt.id ? generateIdentifier(stmt.id) : '',
                this.generateFunctionBody(stmt)
            ];
        },

        ReturnStatement: function (stmt, flags) {
            if (stmt.argument) {
                return [join(
                    'return',
                    this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)
                ), this.semicolon(flags)];
            }
            return ['return' + this.semicolon(flags)];
        },

        WhileStatement: function (stmt, flags) {
            var result, that = this;
            withIndent(function () {
                result = [
                    'while' + space + '(',
                    that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
                    ')'
                ];
            });
            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
            return result;
        },

        WithStatement: function (stmt, flags) {
            var result, that = this;
            withIndent(function () {
                result = [
                    'with' + space + '(',
                    that.generateExpression(stmt.object, Precedence.Sequence, E_TTT),
                    ')'
                ];
            });
            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
            return result;
        }

    };

    merge(CodeGenerator.prototype, CodeGenerator.Statement);

    // Expressions.

    CodeGenerator.Expression = {

        SequenceExpression: function (expr, precedence, flags) {
            var result, i, iz;
            if (Precedence.Sequence < precedence) {
                flags |= F_ALLOW_IN;
            }
            result = [];
            for (i = 0, iz = expr.expressions.length; i < iz; ++i) {
                result.push(this.generateExpression(expr.expressions[i], Precedence.Assignment, flags));
                if (i + 1 < iz) {
                    result.push(',' + space);
                }
            }
            return parenthesize(result, Precedence.Sequence, precedence);
        },

        AssignmentExpression: function (expr, precedence, flags) {
            return this.generateAssignment(expr.left, expr.right, expr.operator, precedence, flags);
        },

        ArrowFunctionExpression: function (expr, precedence, flags) {
            return parenthesize(this.generateFunctionBody(expr), Precedence.ArrowFunction, precedence);
        },

        ConditionalExpression: function (expr, precedence, flags) {
            if (Precedence.Conditional < precedence) {
                flags |= F_ALLOW_IN;
            }
            return parenthesize(
                [
                    this.generateExpression(expr.test, Precedence.LogicalOR, flags),
                    space + '?' + space,
                    this.generateExpression(expr.consequent, Precedence.Assignment, flags),
                    space + ':' + space,
                    this.generateExpression(expr.alternate, Precedence.Assignment, flags)
                ],
                Precedence.Conditional,
                precedence
            );
        },

        LogicalExpression: function (expr, precedence, flags) {
            return this.BinaryExpression(expr, precedence, flags);
        },

        BinaryExpression: function (expr, precedence, flags) {
            var result, currentPrecedence, fragment, leftSource;
            currentPrecedence = BinaryPrecedence[expr.operator];

            if (currentPrecedence < precedence) {
                flags |= F_ALLOW_IN;
            }

            fragment = this.generateExpression(expr.left, currentPrecedence, flags);

            leftSource = fragment.toString();

            if (leftSource.charCodeAt(leftSource.length - 1) === 0x2F /* / */ && esutils.code.isIdentifierPartES5(expr.operator.charCodeAt(0))) {
                result = [fragment, noEmptySpace(), expr.operator];
            } else {
                result = join(fragment, expr.operator);
            }

            fragment = this.generateExpression(expr.right, currentPrecedence + 1, flags);

            if (expr.operator === '/' && fragment.toString().charAt(0) === '/' ||
            expr.operator.slice(-1) === '<' && fragment.toString().slice(0, 3) === '!--') {
                // If '/' concats with '/' or `<` concats with `!--`, it is interpreted as comment start
                result.push(noEmptySpace());
                result.push(fragment);
            } else {
                result = join(result, fragment);
            }

            if (expr.operator === 'in' && !(flags & F_ALLOW_IN)) {
                return ['(', result, ')'];
            }
            return parenthesize(result, currentPrecedence, precedence);
        },

        CallExpression: function (expr, precedence, flags) {
            var result, i, iz;
            // F_ALLOW_UNPARATH_NEW becomes false.
            result = [this.generateExpression(expr.callee, Precedence.Call, E_TTF)];
            result.push('(');
            for (i = 0, iz = expr['arguments'].length; i < iz; ++i) {
                result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));
                if (i + 1 < iz) {
                    result.push(',' + space);
                }
            }
            result.push(')');

            if (!(flags & F_ALLOW_CALL)) {
                return ['(', result, ')'];
            }
            return parenthesize(result, Precedence.Call, precedence);
        },

        NewExpression: function (expr, precedence, flags) {
            var result, length, i, iz, itemFlags;
            length = expr['arguments'].length;

            // F_ALLOW_CALL becomes false.
            // F_ALLOW_UNPARATH_NEW may become false.
            itemFlags = (flags & F_ALLOW_UNPARATH_NEW && !parentheses && length === 0) ? E_TFT : E_TFF;

            result = join(
                'new',
                this.generateExpression(expr.callee, Precedence.New, itemFlags)
            );

            if (!(flags & F_ALLOW_UNPARATH_NEW) || parentheses || length > 0) {
                result.push('(');
                for (i = 0, iz = length; i < iz; ++i) {
                    result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));
                    if (i + 1 < iz) {
                        result.push(',' + space);
                    }
                }
                result.push(')');
            }

            return parenthesize(result, Precedence.New, precedence);
        },

        MemberExpression: function (expr, precedence, flags) {
            var result, fragment;

            // F_ALLOW_UNPARATH_NEW becomes false.
            result = [this.generateExpression(expr.object, Precedence.Call, (flags & F_ALLOW_CALL) ? E_TTF : E_TFF)];

            if (expr.computed) {
                result.push('[');
                result.push(this.generateExpression(expr.property, Precedence.Sequence, flags & F_ALLOW_CALL ? E_TTT : E_TFT));
                result.push(']');
            } else {
                if (expr.object.type === Syntax.Literal && typeof expr.object.value === 'number') {
                    fragment = toSourceNodeWhenNeeded(result).toString();
                    // When the following conditions are all true,
                    //   1. No floating point
                    //   2. Don't have exponents
                    //   3. The last character is a decimal digit
                    //   4. Not hexadecimal OR octal number literal
                    // we should add a floating point.
                    if (
                            fragment.indexOf('.') < 0 &&
                            !/[eExX]/.test(fragment) &&
                            esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) &&
                            !(fragment.length >= 2 && fragment.charCodeAt(0) === 48)  // '0'
                            ) {
                        result.push('.');
                    }
                }
                result.push('.');
                result.push(generateIdentifier(expr.property));
            }

            return parenthesize(result, Precedence.Member, precedence);
        },

        MetaProperty: function (expr, precedence, flags) {
            var result;
            result = [];
            result.push(expr.meta);
            result.push('.');
            result.push(expr.property);
            return parenthesize(result, Precedence.Member, precedence);
        },

        UnaryExpression: function (expr, precedence, flags) {
            var result, fragment, rightCharCode, leftSource, leftCharCode;
            fragment = this.generateExpression(expr.argument, Precedence.Unary, E_TTT);

            if (space === '') {
                result = join(expr.operator, fragment);
            } else {
                result = [expr.operator];
                if (expr.operator.length > 2) {
                    // delete, void, typeof
                    // get `typeof []`, not `typeof[]`
                    result = join(result, fragment);
                } else {
                    // Prevent inserting spaces between operator and argument if it is unnecessary
                    // like, `!cond`
                    leftSource = toSourceNodeWhenNeeded(result).toString();
                    leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
                    rightCharCode = fragment.toString().charCodeAt(0);

                    if (((leftCharCode === 0x2B  /* + */ || leftCharCode === 0x2D  /* - */) && leftCharCode === rightCharCode) ||
                            (esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode))) {
                        result.push(noEmptySpace());
                        result.push(fragment);
                    } else {
                        result.push(fragment);
                    }
                }
            }
            return parenthesize(result, Precedence.Unary, precedence);
        },

        YieldExpression: function (expr, precedence, flags) {
            var result;
            if (expr.delegate) {
                result = 'yield*';
            } else {
                result = 'yield';
            }
            if (expr.argument) {
                result = join(
                    result,
                    this.generateExpression(expr.argument, Precedence.Yield, E_TTT)
                );
            }
            return parenthesize(result, Precedence.Yield, precedence);
        },

        AwaitExpression: function (expr, precedence, flags) {
            var result = join(
                expr.all ? 'await*' : 'await',
                this.generateExpression(expr.argument, Precedence.Await, E_TTT)
            );
            return parenthesize(result, Precedence.Await, precedence);
        },

        UpdateExpression: function (expr, precedence, flags) {
            if (expr.prefix) {
                return parenthesize(
                    [
                        expr.operator,
                        this.generateExpression(expr.argument, Precedence.Unary, E_TTT)
                    ],
                    Precedence.Unary,
                    precedence
                );
            }
            return parenthesize(
                [
                    this.generateExpression(expr.argument, Precedence.Postfix, E_TTT),
                    expr.operator
                ],
                Precedence.Postfix,
                precedence
            );
        },

        FunctionExpression: function (expr, precedence, flags) {
            var result = [
                generateAsyncPrefix(expr, true),
                'function'
            ];
            if (expr.id) {
                result.push(generateStarSuffix(expr) || noEmptySpace());
                result.push(generateIdentifier(expr.id));
            } else {
                result.push(generateStarSuffix(expr) || space);
            }
            result.push(this.generateFunctionBody(expr));
            return result;
        },

        ArrayPattern: function (expr, precedence, flags) {
            return this.ArrayExpression(expr, precedence, flags, true);
        },

        ArrayExpression: function (expr, precedence, flags, isPattern) {
            var result, multiline, that = this;
            if (!expr.elements.length) {
                return '[]';
            }
            multiline = isPattern ? false : expr.elements.length > 1;
            result = ['[', multiline ? newline : ''];
            withIndent(function (indent) {
                var i, iz;
                for (i = 0, iz = expr.elements.length; i < iz; ++i) {
                    if (!expr.elements[i]) {
                        if (multiline) {
                            result.push(indent);
                        }
                        if (i + 1 === iz) {
                            result.push(',');
                        }
                    } else {
                        result.push(multiline ? indent : '');
                        result.push(that.generateExpression(expr.elements[i], Precedence.Assignment, E_TTT));
                    }
                    if (i + 1 < iz) {
                        result.push(',' + (multiline ? newline : space));
                    }
                }
            });
            if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(multiline ? base : '');
            result.push(']');
            return result;
        },

        RestElement: function(expr, precedence, flags) {
            return '...' + this.generatePattern(expr.argument);
        },

        ClassExpression: function (expr, precedence, flags) {
            var result, fragment;
            result = ['class'];
            if (expr.id) {
                result = join(result, this.generateExpression(expr.id, Precedence.Sequence, E_TTT));
            }
            if (expr.superClass) {
                fragment = join('extends', this.generateExpression(expr.superClass, Precedence.Assignment, E_TTT));
                result = join(result, fragment);
            }
            result.push(space);
            result.push(this.generateStatement(expr.body, S_TFFT));
            return result;
        },

        MethodDefinition: function (expr, precedence, flags) {
            var result, fragment;
            if (expr['static']) {
                result = ['static' + space];
            } else {
                result = [];
            }
            if (expr.kind === 'get' || expr.kind === 'set') {
                fragment = [
                    join(expr.kind, this.generatePropertyKey(expr.key, expr.computed, expr.value)),
                    this.generateFunctionBody(expr.value)
                ];
            } else {
                fragment = [
                    generateMethodPrefix(expr),
                    this.generatePropertyKey(expr.key, expr.computed, expr.value),
                    this.generateFunctionBody(expr.value)
                ];
            }
            return join(result, fragment);
        },

        Property: function (expr, precedence, flags) {
            if (expr.kind === 'get' || expr.kind === 'set') {
                return [
                    expr.kind, noEmptySpace(),
                    this.generatePropertyKey(expr.key, expr.computed, expr.value),
                    this.generateFunctionBody(expr.value)
                ];
            }

            if (expr.shorthand) {
                return this.generatePropertyKey(expr.key, expr.computed, expr.value);
            }

            if (expr.method) {
                return [
                    generateMethodPrefix(expr),
                    this.generatePropertyKey(expr.key, expr.computed, expr.value),
                    this.generateFunctionBody(expr.value)
                ];
            }

            return [
                this.generatePropertyKey(expr.key, expr.computed, expr.value),
                ':' + space,
                this.generateExpression(expr.value, Precedence.Assignment, E_TTT)
            ];
        },

        ObjectExpression: function (expr, precedence, flags) {
            var multiline, result, fragment, that = this;

            if (!expr.properties.length) {
                return '{}';
            }
            multiline = expr.properties.length > 1;

            withIndent(function () {
                fragment = that.generateExpression(expr.properties[0], Precedence.Sequence, E_TTT);
            });

            if (!multiline) {
                // issues 4
                // Do not transform from
                //   dejavu.Class.declare({
                //       method2: function () {}
                //   });
                // to
                //   dejavu.Class.declare({method2: function () {
                //       }});
                if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                    return [ '{', space, fragment, space, '}' ];
                }
            }

            withIndent(function (indent) {
                var i, iz;
                result = [ '{', newline, indent, fragment ];

                if (multiline) {
                    result.push(',' + newline);
                    for (i = 1, iz = expr.properties.length; i < iz; ++i) {
                        result.push(indent);
                        result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));
                        if (i + 1 < iz) {
                            result.push(',' + newline);
                        }
                    }
                }
            });

            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(base);
            result.push('}');
            return result;
        },

        AssignmentPattern: function(expr, precedence, flags) {
            return this.generateAssignment(expr.left, expr.right, '=', precedence, flags);
        },

        ObjectPattern: function (expr, precedence, flags) {
            var result, i, iz, multiline, property, that = this;
            if (!expr.properties.length) {
                return '{}';
            }

            multiline = false;
            if (expr.properties.length === 1) {
                property = expr.properties[0];
                if (property.value.type !== Syntax.Identifier) {
                    multiline = true;
                }
            } else {
                for (i = 0, iz = expr.properties.length; i < iz; ++i) {
                    property = expr.properties[i];
                    if (!property.shorthand) {
                        multiline = true;
                        break;
                    }
                }
            }
            result = ['{', multiline ? newline : '' ];

            withIndent(function (indent) {
                var i, iz;
                for (i = 0, iz = expr.properties.length; i < iz; ++i) {
                    result.push(multiline ? indent : '');
                    result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));
                    if (i + 1 < iz) {
                        result.push(',' + (multiline ? newline : space));
                    }
                }
            });

            if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(multiline ? base : '');
            result.push('}');
            return result;
        },

        ThisExpression: function (expr, precedence, flags) {
            return 'this';
        },

        Super: function (expr, precedence, flags) {
            return 'super';
        },

        Identifier: function (expr, precedence, flags) {
            return generateIdentifier(expr);
        },

        ImportDefaultSpecifier: function (expr, precedence, flags) {
            return generateIdentifier(expr.id || expr.local);
        },

        ImportNamespaceSpecifier: function (expr, precedence, flags) {
            var result = ['*'];
            var id = expr.id || expr.local;
            if (id) {
                result.push(space + 'as' + noEmptySpace() + generateIdentifier(id));
            }
            return result;
        },

        ImportSpecifier: function (expr, precedence, flags) {
            var imported = expr.imported;
            var result = [ imported.name ];
            var local = expr.local;
            if (local && local.name !== imported.name) {
                result.push(noEmptySpace() + 'as' + noEmptySpace() + generateIdentifier(local));
            }
            return result;
        },

        ExportSpecifier: function (expr, precedence, flags) {
            var local = expr.local;
            var result = [ local.name ];
            var exported = expr.exported;
            if (exported && exported.name !== local.name) {
                result.push(noEmptySpace() + 'as' + noEmptySpace() + generateIdentifier(exported));
            }
            return result;
        },

        Literal: function (expr, precedence, flags) {
            var raw;
            if (expr.hasOwnProperty('raw') && parse && extra.raw) {
                try {
                    raw = parse(expr.raw).body[0].expression;
                    if (raw.type === Syntax.Literal) {
                        if (raw.value === expr.value) {
                            return expr.raw;
                        }
                    }
                } catch (e) {
                    // not use raw property
                }
            }

            if (expr.value === null) {
                return 'null';
            }

            if (typeof expr.value === 'string') {
                return escapeString(expr.value);
            }

            if (typeof expr.value === 'number') {
                return generateNumber(expr.value);
            }

            if (typeof expr.value === 'boolean') {
                return expr.value ? 'true' : 'false';
            }

            return generateRegExp(expr.value);
        },

        GeneratorExpression: function (expr, precedence, flags) {
            return this.ComprehensionExpression(expr, precedence, flags);
        },

        ComprehensionExpression: function (expr, precedence, flags) {
            // GeneratorExpression should be parenthesized with (...), ComprehensionExpression with [...]
            // Due to https://bugzilla.mozilla.org/show_bug.cgi?id=883468 position of expr.body can differ in Spidermonkey and ES6

            var result, i, iz, fragment, that = this;
            result = (expr.type === Syntax.GeneratorExpression) ? ['('] : ['['];

            if (extra.moz.comprehensionExpressionStartsWithAssignment) {
                fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);
                result.push(fragment);
            }

            if (expr.blocks) {
                withIndent(function () {
                    for (i = 0, iz = expr.blocks.length; i < iz; ++i) {
                        fragment = that.generateExpression(expr.blocks[i], Precedence.Sequence, E_TTT);
                        if (i > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {
                            result = join(result, fragment);
                        } else {
                            result.push(fragment);
                        }
                    }
                });
            }

            if (expr.filter) {
                result = join(result, 'if' + space);
                fragment = this.generateExpression(expr.filter, Precedence.Sequence, E_TTT);
                result = join(result, [ '(', fragment, ')' ]);
            }

            if (!extra.moz.comprehensionExpressionStartsWithAssignment) {
                fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);

                result = join(result, fragment);
            }

            result.push((expr.type === Syntax.GeneratorExpression) ? ')' : ']');
            return result;
        },

        ComprehensionBlock: function (expr, precedence, flags) {
            var fragment;
            if (expr.left.type === Syntax.VariableDeclaration) {
                fragment = [
                    expr.left.kind, noEmptySpace(),
                    this.generateStatement(expr.left.declarations[0], S_FFFF)
                ];
            } else {
                fragment = this.generateExpression(expr.left, Precedence.Call, E_TTT);
            }

            fragment = join(fragment, expr.of ? 'of' : 'in');
            fragment = join(fragment, this.generateExpression(expr.right, Precedence.Sequence, E_TTT));

            return [ 'for' + space + '(', fragment, ')' ];
        },

        SpreadElement: function (expr, precedence, flags) {
            return [
                '...',
                this.generateExpression(expr.argument, Precedence.Assignment, E_TTT)
            ];
        },

        TaggedTemplateExpression: function (expr, precedence, flags) {
            var itemFlags = E_TTF;
            if (!(flags & F_ALLOW_CALL)) {
                itemFlags = E_TFF;
            }
            var result = [
                this.generateExpression(expr.tag, Precedence.Call, itemFlags),
                this.generateExpression(expr.quasi, Precedence.Primary, E_FFT)
            ];
            return parenthesize(result, Precedence.TaggedTemplate, precedence);
        },

        TemplateElement: function (expr, precedence, flags) {
            // Don't use "cooked". Since tagged template can use raw template
            // representation. So if we do so, it breaks the script semantics.
            return expr.value.raw;
        },

        TemplateLiteral: function (expr, precedence, flags) {
            var result, i, iz;
            result = [ '`' ];
            for (i = 0, iz = expr.quasis.length; i < iz; ++i) {
                result.push(this.generateExpression(expr.quasis[i], Precedence.Primary, E_TTT));
                if (i + 1 < iz) {
                    result.push('${' + space);
                    result.push(this.generateExpression(expr.expressions[i], Precedence.Sequence, E_TTT));
                    result.push(space + '}');
                }
            }
            result.push('`');
            return result;
        },

        ModuleSpecifier: function (expr, precedence, flags) {
            return this.Literal(expr, precedence, flags);
        }

    };

    merge(CodeGenerator.prototype, CodeGenerator.Expression);

    CodeGenerator.prototype.generateExpression = function (expr, precedence, flags) {
        var result, type;

        type = expr.type || Syntax.Property;

        if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {
            return generateVerbatim(expr, precedence);
        }

        result = this[type](expr, precedence, flags);


        if (extra.comment) {
            result = addComments(expr, result);
        }
        return toSourceNodeWhenNeeded(result, expr);
    };

    CodeGenerator.prototype.generateStatement = function (stmt, flags) {
        var result,
            fragment;

        result = this[stmt.type](stmt, flags);

        // Attach comments

        if (extra.comment) {
            result = addComments(stmt, result);
        }

        fragment = toSourceNodeWhenNeeded(result).toString();
        if (stmt.type === Syntax.Program && !safeConcatenation && newline === '' &&  fragment.charAt(fragment.length - 1) === '\n') {
            result = sourceMap ? toSourceNodeWhenNeeded(result).replaceRight(/\s+$/, '') : fragment.replace(/\s+$/, '');
        }

        return toSourceNodeWhenNeeded(result, stmt);
    };

    function generateInternal(node) {
        var codegen;

        codegen = new CodeGenerator();
        if (isStatement(node)) {
            return codegen.generateStatement(node, S_TFFF);
        }

        if (isExpression(node)) {
            return codegen.generateExpression(node, Precedence.Sequence, E_TTT);
        }

        throw new Error('Unknown node type: ' + node.type);
    }

    function generate(node, options) {
        var defaultOptions = getDefaultOptions(), result, pair;

        if (options != null) {
            // Obsolete options
            //
            //   `options.indent`
            //   `options.base`
            //
            // Instead of them, we can use `option.format.indent`.
            if (typeof options.indent === 'string') {
                defaultOptions.format.indent.style = options.indent;
            }
            if (typeof options.base === 'number') {
                defaultOptions.format.indent.base = options.base;
            }
            options = updateDeeply(defaultOptions, options);
            indent = options.format.indent.style;
            if (typeof options.base === 'string') {
                base = options.base;
            } else {
                base = stringRepeat(indent, options.format.indent.base);
            }
        } else {
            options = defaultOptions;
            indent = options.format.indent.style;
            base = stringRepeat(indent, options.format.indent.base);
        }
        json = options.format.json;
        renumber = options.format.renumber;
        hexadecimal = json ? false : options.format.hexadecimal;
        quotes = json ? 'double' : options.format.quotes;
        escapeless = options.format.escapeless;
        newline = options.format.newline;
        space = options.format.space;
        if (options.format.compact) {
            newline = space = indent = base = '';
        }
        parentheses = options.format.parentheses;
        semicolons = options.format.semicolons;
        safeConcatenation = options.format.safeConcatenation;
        directive = options.directive;
        parse = json ? null : options.parse;
        sourceMap = options.sourceMap;
        sourceCode = options.sourceCode;
        preserveBlankLines = options.format.preserveBlankLines && sourceCode !== null;
        extra = options;

        if (sourceMap) {
            if (!exports.browser) {
                // We assume environment is node.js
                // And prevent from including source-map by browserify
                SourceNode = require('source-map').SourceNode;
            } else {
                SourceNode = global.sourceMap.SourceNode;
            }
        }

        result = generateInternal(node);

        if (!sourceMap) {
            pair = {code: result.toString(), map: null};
            return options.sourceMapWithCode ? pair : pair.code;
        }


        pair = result.toStringWithSourceMap({
            file: options.file,
            sourceRoot: options.sourceMapRoot
        });

        if (options.sourceContent) {
            pair.map.setSourceContent(options.sourceMap,
                                      options.sourceContent);
        }

        if (options.sourceMapWithCode) {
            return pair;
        }

        return pair.map.toString();
    }

    FORMAT_MINIFY = {
        indent: {
            style: '',
            base: 0
        },
        renumber: true,
        hexadecimal: true,
        quotes: 'auto',
        escapeless: true,
        compact: true,
        parentheses: false,
        semicolons: false
    };

    FORMAT_DEFAULTS = getDefaultOptions().format;

    exports.version = require('./package.json').version;
    exports.generate = generate;
    exports.attachComments = estraverse.attachComments;
    exports.Precedence = updateDeeply({}, Precedence);
    exports.browser = false;
    exports.FORMAT_MINIFY = FORMAT_MINIFY;
    exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;
}());
/* vim: set sw=4 ts=4 et tw=80 : */

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./package.json":17,"estraverse":4,"esutils":23,"source-map":5}],4:[function(require,module,exports){
/*
  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*jslint vars:false, bitwise:true*/
/*jshint indent:4*/
/*global exports:true, define:true*/
(function (root, factory) {
    'use strict';

    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // and plain browser loading,
    if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
    } else if (typeof exports !== 'undefined') {
        factory(exports);
    } else {
        factory((root.estraverse = {}));
    }
}(this, function clone(exports) {
    'use strict';

    var Syntax,
        isArray,
        VisitorOption,
        VisitorKeys,
        objectCreate,
        objectKeys,
        BREAK,
        SKIP,
        REMOVE;

    function ignoreJSHintError() { }

    isArray = Array.isArray;
    if (!isArray) {
        isArray = function isArray(array) {
            return Object.prototype.toString.call(array) === '[object Array]';
        };
    }

    function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                val = obj[key];
                if (typeof val === 'object' && val !== null) {
                    ret[key] = deepCopy(val);
                } else {
                    ret[key] = val;
                }
            }
        }
        return ret;
    }

    function shallowCopy(obj) {
        var ret = {}, key;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                ret[key] = obj[key];
            }
        }
        return ret;
    }
    ignoreJSHintError(shallowCopy);

    // based on LLVM libc++ upper_bound / lower_bound
    // MIT License

    function upperBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                len = diff;
            } else {
                i = current + 1;
                len -= diff + 1;
            }
        }
        return i;
    }

    function lowerBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                i = current + 1;
                len -= diff + 1;
            } else {
                len = diff;
            }
        }
        return i;
    }
    ignoreJSHintError(lowerBound);

    objectCreate = Object.create || (function () {
        function F() { }

        return function (o) {
            F.prototype = o;
            return new F();
        };
    })();

    objectKeys = Object.keys || function (o) {
        var keys = [], key;
        for (key in o) {
            keys.push(key);
        }
        return keys;
    };

    function extend(to, from) {
        var keys = objectKeys(from), key, i, len;
        for (i = 0, len = keys.length; i < len; i += 1) {
            key = keys[i];
            to[key] = from[key];
        }
        return to;
    }

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        AwaitExpression: 'AwaitExpression', // CAUTION: It's deferred to ES7.
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ComprehensionBlock: 'ComprehensionBlock',  // CAUTION: It's deferred to ES7.
        ComprehensionExpression: 'ComprehensionExpression',  // CAUTION: It's deferred to ES7.
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DebuggerStatement: 'DebuggerStatement',
        DirectiveStatement: 'DirectiveStatement',
        DoWhileStatement: 'DoWhileStatement',
        EmptyStatement: 'EmptyStatement',
        ExportBatchSpecifier: 'ExportBatchSpecifier',
        ExportDeclaration: 'ExportDeclaration',
        ExportSpecifier: 'ExportSpecifier',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        ForOfStatement: 'ForOfStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        GeneratorExpression: 'GeneratorExpression',  // CAUTION: It's deferred to ES7.
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        ImportDeclaration: 'ImportDeclaration',
        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
        ImportSpecifier: 'ImportSpecifier',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MethodDefinition: 'MethodDefinition',
        ModuleSpecifier: 'ModuleSpecifier',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SpreadElement: 'SpreadElement',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        TaggedTemplateExpression: 'TaggedTemplateExpression',
        TemplateElement: 'TemplateElement',
        TemplateLiteral: 'TemplateLiteral',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
    };

    VisitorKeys = {
        AssignmentExpression: ['left', 'right'],
        ArrayExpression: ['elements'],
        ArrayPattern: ['elements'],
        ArrowFunctionExpression: ['params', 'defaults', 'rest', 'body'],
        AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.
        BlockStatement: ['body'],
        BinaryExpression: ['left', 'right'],
        BreakStatement: ['label'],
        CallExpression: ['callee', 'arguments'],
        CatchClause: ['param', 'body'],
        ClassBody: ['body'],
        ClassDeclaration: ['id', 'body', 'superClass'],
        ClassExpression: ['id', 'body', 'superClass'],
        ComprehensionBlock: ['left', 'right'],  // CAUTION: It's deferred to ES7.
        ComprehensionExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
        ConditionalExpression: ['test', 'consequent', 'alternate'],
        ContinueStatement: ['label'],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ['body', 'test'],
        EmptyStatement: [],
        ExportBatchSpecifier: [],
        ExportDeclaration: ['declaration', 'specifiers', 'source'],
        ExportSpecifier: ['id', 'name'],
        ExpressionStatement: ['expression'],
        ForStatement: ['init', 'test', 'update', 'body'],
        ForInStatement: ['left', 'right', 'body'],
        ForOfStatement: ['left', 'right', 'body'],
        FunctionDeclaration: ['id', 'params', 'defaults', 'rest', 'body'],
        FunctionExpression: ['id', 'params', 'defaults', 'rest', 'body'],
        GeneratorExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
        Identifier: [],
        IfStatement: ['test', 'consequent', 'alternate'],
        ImportDeclaration: ['specifiers', 'source'],
        ImportDefaultSpecifier: ['id'],
        ImportNamespaceSpecifier: ['id'],
        ImportSpecifier: ['id', 'name'],
        Literal: [],
        LabeledStatement: ['label', 'body'],
        LogicalExpression: ['left', 'right'],
        MemberExpression: ['object', 'property'],
        MethodDefinition: ['key', 'value'],
        ModuleSpecifier: [],
        NewExpression: ['callee', 'arguments'],
        ObjectExpression: ['properties'],
        ObjectPattern: ['properties'],
        Program: ['body'],
        Property: ['key', 'value'],
        ReturnStatement: ['argument'],
        SequenceExpression: ['expressions'],
        SpreadElement: ['argument'],
        SwitchStatement: ['discriminant', 'cases'],
        SwitchCase: ['test', 'consequent'],
        TaggedTemplateExpression: ['tag', 'quasi'],
        TemplateElement: [],
        TemplateLiteral: ['quasis', 'expressions'],
        ThisExpression: [],
        ThrowStatement: ['argument'],
        TryStatement: ['block', 'handlers', 'handler', 'guardedHandlers', 'finalizer'],
        UnaryExpression: ['argument'],
        UpdateExpression: ['argument'],
        VariableDeclaration: ['declarations'],
        VariableDeclarator: ['id', 'init'],
        WhileStatement: ['test', 'body'],
        WithStatement: ['object', 'body'],
        YieldExpression: ['argument']
    };

    // unique id
    BREAK = {};
    SKIP = {};
    REMOVE = {};

    VisitorOption = {
        Break: BREAK,
        Skip: SKIP,
        Remove: REMOVE
    };

    function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
    }

    Reference.prototype.replace = function replace(node) {
        this.parent[this.key] = node;
    };

    Reference.prototype.remove = function remove() {
        if (isArray(this.parent)) {
            this.parent.splice(this.key, 1);
            return true;
        } else {
            this.replace(null);
            return false;
        }
    };

    function Element(node, path, wrap, ref) {
        this.node = node;
        this.path = path;
        this.wrap = wrap;
        this.ref = ref;
    }

    function Controller() { }

    // API:
    // return property path array from root to current node
    Controller.prototype.path = function path() {
        var i, iz, j, jz, result, element;

        function addToPath(result, path) {
            if (isArray(path)) {
                for (j = 0, jz = path.length; j < jz; ++j) {
                    result.push(path[j]);
                }
            } else {
                result.push(path);
            }
        }

        // root node
        if (!this.__current.path) {
            return null;
        }

        // first node is sentinel, second node is root element
        result = [];
        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
            element = this.__leavelist[i];
            addToPath(result, element.path);
        }
        addToPath(result, this.__current.path);
        return result;
    };

    // API:
    // return type of current node
    Controller.prototype.type = function () {
        var node = this.current();
        return node.type || this.__current.wrap;
    };

    // API:
    // return array of parent elements
    Controller.prototype.parents = function parents() {
        var i, iz, result;

        // first node is sentinel
        result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
            result.push(this.__leavelist[i].node);
        }

        return result;
    };

    // API:
    // return current node
    Controller.prototype.current = function current() {
        return this.__current.node;
    };

    Controller.prototype.__execute = function __execute(callback, element) {
        var previous, result;

        result = undefined;

        previous  = this.__current;
        this.__current = element;
        this.__state = null;
        if (callback) {
            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;

        return result;
    };

    // API:
    // notify control skip / break
    Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
    };

    // API:
    // skip child nodes of current node
    Controller.prototype.skip = function () {
        this.notify(SKIP);
    };

    // API:
    // break traversals
    Controller.prototype['break'] = function () {
        this.notify(BREAK);
    };

    // API:
    // remove node
    Controller.prototype.remove = function () {
        this.notify(REMOVE);
    };

    Controller.prototype.__initialize = function(root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
        this.__fallback = visitor.fallback === 'iteration';
        this.__keys = VisitorKeys;
        if (visitor.keys) {
            this.__keys = extend(objectCreate(this.__keys), visitor.keys);
        }
    };

    function isNode(node) {
        if (node == null) {
            return false;
        }
        return typeof node === 'object' && typeof node.type === 'string';
    }

    function isProperty(nodeType, key) {
        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
    }

    Controller.prototype.traverse = function traverse(root, visitor) {
        var worklist,
            leavelist,
            element,
            node,
            nodeType,
            ret,
            key,
            current,
            current2,
            candidates,
            candidate,
            sentinel;

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        worklist.push(new Element(root, null, null, null));
        leavelist.push(new Element(null, null, null, null));

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                ret = this.__execute(visitor.leave, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }
                continue;
            }

            if (element.node) {

                ret = this.__execute(visitor.enter, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }

                worklist.push(sentinel);
                leavelist.push(element);

                if (this.__state === SKIP || ret === SKIP) {
                    continue;
                }

                node = element.node;
                nodeType = element.wrap || node.type;
                candidates = this.__keys[nodeType];
                if (!candidates) {
                    if (this.__fallback) {
                        candidates = objectKeys(node);
                    } else {
                        throw new Error('Unknown node type ' + nodeType + '.');
                    }
                }

                current = candidates.length;
                while ((current -= 1) >= 0) {
                    key = candidates[current];
                    candidate = node[key];
                    if (!candidate) {
                        continue;
                    }

                    if (isArray(candidate)) {
                        current2 = candidate.length;
                        while ((current2 -= 1) >= 0) {
                            if (!candidate[current2]) {
                                continue;
                            }
                            if (isProperty(nodeType, candidates[current])) {
                                element = new Element(candidate[current2], [key, current2], 'Property', null);
                            } else if (isNode(candidate[current2])) {
                                element = new Element(candidate[current2], [key, current2], null, null);
                            } else {
                                continue;
                            }
                            worklist.push(element);
                        }
                    } else if (isNode(candidate)) {
                        worklist.push(new Element(candidate, key, null, null));
                    }
                }
            }
        }
    };

    Controller.prototype.replace = function replace(root, visitor) {
        function removeElem(element) {
            var i,
                key,
                nextElem,
                parent;

            if (element.ref.remove()) {
                // When the reference is an element of an array.
                key = element.ref.key;
                parent = element.ref.parent;

                // If removed from array, then decrease following items' keys.
                i = worklist.length;
                while (i--) {
                    nextElem = worklist[i];
                    if (nextElem.ref && nextElem.ref.parent === parent) {
                        if  (nextElem.ref.key < key) {
                            break;
                        }
                        --nextElem.ref.key;
                    }
                }
            }
        }

        var worklist,
            leavelist,
            node,
            nodeType,
            target,
            element,
            current,
            current2,
            candidates,
            candidate,
            sentinel,
            outer,
            key;

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        outer = {
            root: root
        };
        element = new Element(root, null, null, new Reference(outer, 'root'));
        worklist.push(element);
        leavelist.push(element);

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                target = this.__execute(visitor.leave, element);

                // node may be replaced with null,
                // so distinguish between undefined and null in this place
                if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                    // replace
                    element.ref.replace(target);
                }

                if (this.__state === REMOVE || target === REMOVE) {
                    removeElem(element);
                }

                if (this.__state === BREAK || target === BREAK) {
                    return outer.root;
                }
                continue;
            }

            target = this.__execute(visitor.enter, element);

            // node may be replaced with null,
            // so distinguish between undefined and null in this place
            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                // replace
                element.ref.replace(target);
                element.node = target;
            }

            if (this.__state === REMOVE || target === REMOVE) {
                removeElem(element);
                element.node = null;
            }

            if (this.__state === BREAK || target === BREAK) {
                return outer.root;
            }

            // node may be null
            node = element.node;
            if (!node) {
                continue;
            }

            worklist.push(sentinel);
            leavelist.push(element);

            if (this.__state === SKIP || target === SKIP) {
                continue;
            }

            nodeType = element.wrap || node.type;
            candidates = this.__keys[nodeType];
            if (!candidates) {
                if (this.__fallback) {
                    candidates = objectKeys(node);
                } else {
                    throw new Error('Unknown node type ' + nodeType + '.');
                }
            }

            current = candidates.length;
            while ((current -= 1) >= 0) {
                key = candidates[current];
                candidate = node[key];
                if (!candidate) {
                    continue;
                }

                if (isArray(candidate)) {
                    current2 = candidate.length;
                    while ((current2 -= 1) >= 0) {
                        if (!candidate[current2]) {
                            continue;
                        }
                        if (isProperty(nodeType, candidates[current])) {
                            element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
                        } else if (isNode(candidate[current2])) {
                            element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
                        } else {
                            continue;
                        }
                        worklist.push(element);
                    }
                } else if (isNode(candidate)) {
                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));
                }
            }
        }

        return outer.root;
    };

    function traverse(root, visitor) {
        var controller = new Controller();
        return controller.traverse(root, visitor);
    }

    function replace(root, visitor) {
        var controller = new Controller();
        return controller.replace(root, visitor);
    }

    function extendCommentRange(comment, tokens) {
        var target;

        target = upperBound(tokens, function search(token) {
            return token.range[0] > comment.range[0];
        });

        comment.extendedRange = [comment.range[0], comment.range[1]];

        if (target !== tokens.length) {
            comment.extendedRange[1] = tokens[target].range[0];
        }

        target -= 1;
        if (target >= 0) {
            comment.extendedRange[0] = tokens[target].range[1];
        }

        return comment;
    }

    function attachComments(tree, providedComments, tokens) {
        // At first, we should calculate extended comment ranges.
        var comments = [], comment, len, i, cursor;

        if (!tree.range) {
            throw new Error('attachComments needs range information');
        }

        // tokens array is empty, we attach comments to tree as 'leadingComments'
        if (!tokens.length) {
            if (providedComments.length) {
                for (i = 0, len = providedComments.length; i < len; i += 1) {
                    comment = deepCopy(providedComments[i]);
                    comment.extendedRange = [0, tree.range[0]];
                    comments.push(comment);
                }
                tree.leadingComments = comments;
            }
            return tree;
        }

        for (i = 0, len = providedComments.length; i < len; i += 1) {
            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        }

        // This is based on John Freeman's implementation.
        cursor = 0;
        traverse(tree, {
            enter: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (comment.extendedRange[1] > node.range[0]) {
                        break;
                    }

                    if (comment.extendedRange[1] === node.range[0]) {
                        if (!node.leadingComments) {
                            node.leadingComments = [];
                        }
                        node.leadingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        cursor = 0;
        traverse(tree, {
            leave: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (node.range[1] < comment.extendedRange[0]) {
                        break;
                    }

                    if (node.range[1] === comment.extendedRange[0]) {
                        if (!node.trailingComments) {
                            node.trailingComments = [];
                        }
                        node.trailingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        return tree;
    }

    exports.version = '1.8.1-dev';
    exports.Syntax = Syntax;
    exports.traverse = traverse;
    exports.replace = replace;
    exports.attachComments = attachComments;
    exports.VisitorKeys = VisitorKeys;
    exports.VisitorOption = VisitorOption;
    exports.Controller = Controller;
    exports.cloneEnvironment = function () { return clone({}); };

    return exports;
}));
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],5:[function(require,module,exports){
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = require('./source-map/source-map-generator').SourceMapGenerator;
exports.SourceMapConsumer = require('./source-map/source-map-consumer').SourceMapConsumer;
exports.SourceNode = require('./source-map/source-node').SourceNode;

},{"./source-map/source-map-consumer":13,"./source-map/source-map-generator":14,"./source-map/source-node":15}],6:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');

  /**
   * A data structure which is a combination of an array and a set. Adding a new
   * member is O(1), testing for membership is O(1), and finding the index of an
   * element is O(1). Removing elements from the set is not supported. Only
   * strings are supported for membership.
   */
  function ArraySet() {
    this._array = [];
    this._set = {};
  }

  /**
   * Static method for creating ArraySet instances from an existing array.
   */
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();
    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };

  /**
   * Add the given string to this set.
   *
   * @param String aStr
   */
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var isDuplicate = this.has(aStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      this._set[util.toSetString(aStr)] = idx;
    }
  };

  /**
   * Is the given string a member of this set?
   *
   * @param String aStr
   */
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    return Object.prototype.hasOwnProperty.call(this._set,
                                                util.toSetString(aStr));
  };

  /**
   * What is the index of the given string in the array?
   *
   * @param String aStr
   */
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (this.has(aStr)) {
      return this._set[util.toSetString(aStr)];
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };

  /**
   * What is the element at the given index?
   *
   * @param Number aIdx
   */
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error('No element indexed by ' + aIdx);
  };

  /**
   * Returns the array representation of this set (which has the proper indices
   * indicated by indexOf). Note that this is a copy of the internal array used
   * for storing the members so that no one can mess with internal state.
   */
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };

  exports.ArraySet = ArraySet;

});

},{"./util":16,"amdefine":2}],7:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var base64 = require('./base64');

  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
  // length quantities we use in the source map spec, the first bit is the sign,
  // the next four bits are the actual value, and the 6th bit is the
  // continuation bit. The continuation bit tells us whether there are more
  // digits in this value following this digit.
  //
  //   Continuation
  //   |    Sign
  //   |    |
  //   V    V
  //   101011

  var VLQ_BASE_SHIFT = 5;

  // binary: 100000
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

  // binary: 011111
  var VLQ_BASE_MASK = VLQ_BASE - 1;

  // binary: 100000
  var VLQ_CONTINUATION_BIT = VLQ_BASE;

  /**
   * Converts from a two-complement value to a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
   */
  function toVLQSigned(aValue) {
    return aValue < 0
      ? ((-aValue) << 1) + 1
      : (aValue << 1) + 0;
  }

  /**
   * Converts to a two-complement value from a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
   */
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative
      ? -shifted
      : shifted;
  }

  /**
   * Returns the base 64 VLQ encoded value.
   */
  exports.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;

    var vlq = toVLQSigned(aValue);

    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        // There are still more digits in this value, so we must make sure the
        // continuation bit is marked.
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);

    return encoded;
  };

  /**
   * Decodes the next base 64 VLQ value from the given string and returns the
   * value and the rest of the string via the out parameter.
   */
  exports.decode = function base64VLQ_decode(aStr, aOutParam) {
    var i = 0;
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;

    do {
      if (i >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base64.decode(aStr.charAt(i++));
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);

    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aStr.slice(i);
  };

});

},{"./base64":8,"amdefine":2}],8:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var charToIntMap = {};
  var intToCharMap = {};

  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    .split('')
    .forEach(function (ch, index) {
      charToIntMap[ch] = index;
      intToCharMap[index] = ch;
    });

  /**
   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
   */
  exports.encode = function base64_encode(aNumber) {
    if (aNumber in intToCharMap) {
      return intToCharMap[aNumber];
    }
    throw new TypeError("Must be between 0 and 63: " + aNumber);
  };

  /**
   * Decode a single base 64 digit to an integer.
   */
  exports.decode = function base64_decode(aChar) {
    if (aChar in charToIntMap) {
      return charToIntMap[aChar];
    }
    throw new TypeError("Not a valid base 64 digit: " + aChar);
  };

});

},{"amdefine":2}],9:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');
  var binarySearch = require('./binary-search');
  var ArraySet = require('./array-set').ArraySet;
  var base64VLQ = require('./base64-vlq');
  var SourceMapConsumer = require('./source-map-consumer').SourceMapConsumer;

  /**
   * A BasicSourceMapConsumer instance represents a parsed source map which we can
   * query for information about the original file positions by giving it a file
   * position in the generated source.
   *
   * The only parameter is the raw source map (either as a JSON string, or
   * already parsed to an object). According to the spec, source maps have the
   * following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - sources: An array of URLs to the original source files.
   *   - names: An array of identifiers which can be referrenced by individual mappings.
   *   - sourceRoot: Optional. The URL root from which all sources are relative.
   *   - sourcesContent: Optional. An array of contents of the original source files.
   *   - mappings: A string of base64 VLQs which contain the actual mappings.
   *   - file: Optional. The generated file this source map is associated with.
   *
   * Here is an example source map, taken from the source map spec[0]:
   *
   *     {
   *       version : 3,
   *       file: "out.js",
   *       sourceRoot : "",
   *       sources: ["foo.js", "bar.js"],
   *       names: ["src", "maps", "are", "fun"],
   *       mappings: "AA,AB;;ABCDE;"
   *     }
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
   */
  function BasicSourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources');
    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    // requires the array) to play nice here.
    var names = util.getArg(sourceMap, 'names', []);
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file', null);

    // Once again, Sass deviates from the spec and supplies the version as a
    // string rather than a number, so we use loose equality checking here.
    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    sources = sources.map(util.normalize);

    // Pass `true` below to allow duplicate names and sources. While source maps
    // are intended to be compressed and deduplicated, the TypeScript compiler
    // sometimes generates source maps with duplicates in them. See Github issue
    // #72 and bugzil.la/889492.
    this._names = ArraySet.fromArray(names, true);
    this._sources = ArraySet.fromArray(sources, true);

    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this.file = file;
  }

  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

  /**
   * Create a BasicSourceMapConsumer from a SourceMapGenerator.
   *
   * @param SourceMapGenerator aSourceMap
   *        The source map that will be consumed.
   * @returns BasicSourceMapConsumer
   */
  BasicSourceMapConsumer.fromSourceMap =
    function SourceMapConsumer_fromSourceMap(aSourceMap) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);

      smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                              smc.sourceRoot);
      smc.file = aSourceMap._file;

      smc.__generatedMappings = aSourceMap._mappings.toArray().slice();
      smc.__originalMappings = aSourceMap._mappings.toArray().slice()
        .sort(util.compareByOriginalPositions);

      return smc;
    };

  /**
   * The version of the source mapping spec that we are consuming.
   */
  BasicSourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
    get: function () {
      return this._sources.toArray().map(function (s) {
        return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
      }, this);
    }
  });

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  BasicSourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var str = aStr;
      var temp = {};
      var mapping;

      while (str.length > 0) {
        if (str.charAt(0) === ';') {
          generatedLine++;
          str = str.slice(1);
          previousGeneratedColumn = 0;
        }
        else if (str.charAt(0) === ',') {
          str = str.slice(1);
        }
        else {
          mapping = {};
          mapping.generatedLine = generatedLine;

          // Generated column.
          base64VLQ.decode(str, temp);
          mapping.generatedColumn = previousGeneratedColumn + temp.value;
          previousGeneratedColumn = mapping.generatedColumn;
          str = temp.rest;

          if (str.length > 0 && !this._nextCharIsMappingSeparator(str)) {
            // Original source.
            base64VLQ.decode(str, temp);
            mapping.source = this._sources.at(previousSource + temp.value);
            previousSource += temp.value;
            str = temp.rest;
            if (str.length === 0 || this._nextCharIsMappingSeparator(str)) {
              throw new Error('Found a source, but no line and column');
            }

            // Original line.
            base64VLQ.decode(str, temp);
            mapping.originalLine = previousOriginalLine + temp.value;
            previousOriginalLine = mapping.originalLine;
            // Lines are stored 0-based
            mapping.originalLine += 1;
            str = temp.rest;
            if (str.length === 0 || this._nextCharIsMappingSeparator(str)) {
              throw new Error('Found a source and line, but no column');
            }

            // Original column.
            base64VLQ.decode(str, temp);
            mapping.originalColumn = previousOriginalColumn + temp.value;
            previousOriginalColumn = mapping.originalColumn;
            str = temp.rest;

            if (str.length > 0 && !this._nextCharIsMappingSeparator(str)) {
              // Original name.
              base64VLQ.decode(str, temp);
              mapping.name = this._names.at(previousName + temp.value);
              previousName += temp.value;
              str = temp.rest;
            }
          }

          this.__generatedMappings.push(mapping);
          if (typeof mapping.originalLine === 'number') {
            this.__originalMappings.push(mapping);
          }
        }
      }

      this.__generatedMappings.sort(util.compareByGeneratedPositions);
      this.__originalMappings.sort(util.compareByOriginalPositions);
    };

  /**
   * Find the mapping that best matches the hypothetical "needle" mapping that
   * we are searching for in the given "haystack" of mappings.
   */
  BasicSourceMapConsumer.prototype._findMapping =
    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                           aColumnName, aComparator) {
      // To return the position we are searching for, we must first find the
      // mapping for the given position and then return the opposite position it
      // points to. Because the mappings are sorted, we can use binary search to
      // find the best mapping.

      if (aNeedle[aLineName] <= 0) {
        throw new TypeError('Line must be greater than or equal to 1, got '
                            + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError('Column must be greater than or equal to 0, got '
                            + aNeedle[aColumnName]);
      }

      return binarySearch.search(aNeedle, aMappings, aComparator);
    };

  /**
   * Compute the last column for each generated mapping. The last column is
   * inclusive.
   */
  BasicSourceMapConsumer.prototype.computeColumnSpans =
    function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];

        // Mappings do not contain a field for the last generated columnt. We
        // can come up with an optimistic estimate, however, by assuming that
        // mappings are contiguous (i.e. given two consecutive mappings, the
        // first mapping ends where the second one starts).
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];

          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }

        // The last mapping for each line spans the entire line.
        mapping.lastGeneratedColumn = Infinity;
      }
    };

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.
   *   - column: The column number in the generated source.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.
   *   - column: The column number in the original source, or null.
   *   - name: The original identifier, or null.
   */
  BasicSourceMapConsumer.prototype.originalPositionFor =
    function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
      };

      var index = this._findMapping(needle,
                                    this._generatedMappings,
                                    "generatedLine",
                                    "generatedColumn",
                                    util.compareByGeneratedPositions);

      if (index >= 0) {
        var mapping = this._generatedMappings[index];

        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, 'source', null);
          if (source != null && this.sourceRoot != null) {
            source = util.join(this.sourceRoot, source);
          }
          return {
            source: source,
            line: util.getArg(mapping, 'originalLine', null),
            column: util.getArg(mapping, 'originalColumn', null),
            name: util.getArg(mapping, 'name', null)
          };
        }
      }

      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * availible.
   */
  BasicSourceMapConsumer.prototype.sourceContentFor =
    function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }

      if (this.sourceRoot != null) {
        aSource = util.relative(this.sourceRoot, aSource);
      }

      if (this._sources.has(aSource)) {
        return this.sourcesContent[this._sources.indexOf(aSource)];
      }

      var url;
      if (this.sourceRoot != null
          && (url = util.urlParse(this.sourceRoot))) {
        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
        // many users. We can help them out when they expect file:// URIs to
        // behave like it would if they were running a local HTTP server. See
        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
        if (url.scheme == "file"
            && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
        }

        if ((!url.path || url.path == "/")
            && this._sources.has("/" + aSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
        }
      }

      // This function is used recursively from
      // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
      // don't want to throw if we can't find the source - we just want to
      // return null, so we provide a flag to exit gracefully.
      if (nullOnMissing) {
        return null;
      }
      else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: The column number in the original source.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  BasicSourceMapConsumer.prototype.generatedPositionFor =
    function SourceMapConsumer_generatedPositionFor(aArgs) {
      var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: util.getArg(aArgs, 'column')
      };

      if (this.sourceRoot != null) {
        needle.source = util.relative(this.sourceRoot, needle.source);
      }

      var index = this._findMapping(needle,
                                    this._originalMappings,
                                    "originalLine",
                                    "originalColumn",
                                    util.compareByOriginalPositions);

      if (index >= 0) {
        var mapping = this._originalMappings[index];

        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }

      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };

  exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

});

},{"./array-set":6,"./base64-vlq":7,"./binary-search":10,"./source-map-consumer":13,"./util":16,"amdefine":2}],10:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  /**
   * Recursive implementation of binary search.
   *
   * @param aLow Indices here and lower do not contain the needle.
   * @param aHigh Indices here and higher do not contain the needle.
   * @param aNeedle The element being searched for.
   * @param aHaystack The non-empty array being searched.
   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
   */
  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare) {
    // This function terminates when one of the following is true:
    //
    //   1. We find the exact element we are looking for.
    //
    //   2. We did not find the exact element, but we can return the index of
    //      the next closest element that is less than that element.
    //
    //   3. We did not find the exact element, and there is no next-closest
    //      element which is less than the one we are searching for, so we
    //      return -1.
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      // Found the element we are looking for.
      return mid;
    }
    else if (cmp > 0) {
      // aHaystack[mid] is greater than our needle.
      if (aHigh - mid > 1) {
        // The element is in the upper half.
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare);
      }
      // We did not find an exact match, return the next closest one
      // (termination case 2).
      return mid;
    }
    else {
      // aHaystack[mid] is less than our needle.
      if (mid - aLow > 1) {
        // The element is in the lower half.
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare);
      }
      // The exact needle element was not found in this haystack. Determine if
      // we are in termination case (2) or (3) and return the appropriate thing.
      return aLow < 0 ? -1 : aLow;
    }
  }

  /**
   * This is an implementation of binary search which will always try and return
   * the index of next lowest value checked if there is no exact hit. This is
   * because mappings between original and generated line/col pairs are single
   * points, and there is an implicit region between each of them, so a miss
   * just means that you aren't on the very start of a region.
   *
   * @param aNeedle The element you are looking for.
   * @param aHaystack The array that is being searched.
   * @param aCompare A function which takes the needle and an element in the
   *     array and returns -1, 0, or 1 depending on whether the needle is less
   *     than, equal to, or greater than the element, respectively.
   */
  exports.search = function search(aNeedle, aHaystack, aCompare) {
    if (aHaystack.length === 0) {
      return -1;
    }
    return recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare)
  };

});

},{"amdefine":2}],11:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');
  var binarySearch = require('./binary-search');
  var SourceMapConsumer = require('./source-map-consumer').SourceMapConsumer;
  var BasicSourceMapConsumer = require('./basic-source-map-consumer').BasicSourceMapConsumer;

  /**
   * An IndexedSourceMapConsumer instance represents a parsed source map which
   * we can query for information. It differs from BasicSourceMapConsumer in
   * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
   * input.
   *
   * The only parameter is a raw source map (either as a JSON string, or already
   * parsed to an object). According to the spec for indexed source maps, they
   * have the following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - file: Optional. The generated file this source map is associated with.
   *   - sections: A list of section definitions.
   *
   * Each value under the "sections" field has two fields:
   *   - offset: The offset into the original specified at which this section
   *       begins to apply, defined as an object with a "line" and "column"
   *       field.
   *   - map: A source map definition. This source map could also be indexed,
   *       but doesn't have to be.
   *
   * Instead of the "map" field, it's also possible to have a "url" field
   * specifying a URL to retrieve a source map from, but that's currently
   * unsupported.
   *
   * Here's an example source map, taken from the source map spec[0], but
   * modified to omit a section which uses the "url" field.
   *
   *  {
   *    version : 3,
   *    file: "app.js",
   *    sections: [{
   *      offset: {line:100, column:10},
   *      map: {
   *        version : 3,
   *        file: "section.js",
   *        sources: ["foo.js", "bar.js"],
   *        names: ["src", "maps", "are", "fun"],
   *        mappings: "AAAA,E;;ABCDE;"
   *      }
   *    }],
   *  }
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
   */
  function IndexedSourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util.getArg(sourceMap, 'version');
    var sections = util.getArg(sourceMap, 'sections');

    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map(function (s) {
      if (s.url) {
        // The url field will require support for asynchronicity.
        // See https://github.com/mozilla/source-map/issues/16
        throw new Error('Support for url field in sections not implemented.');
      }
      var offset = util.getArg(s, 'offset');
      var offsetLine = util.getArg(offset, 'line');
      var offsetColumn = util.getArg(offset, 'column');

      if (offsetLine < lastOffset.line ||
          (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
        throw new Error('Section offsets must be ordered and non-overlapping.');
      }
      lastOffset = offset;

      return {
        generatedOffset: {
          // The offset fields are 0-based, but we use 1-based indices when
          // encoding/decoding from VLQ.
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer(util.getArg(s, 'map'))
      }
    });
  }

  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

  /**
   * The version of the source mapping spec that we are consuming.
   */
  IndexedSourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
    get: function () {
      var sources = [];
      for (var i = 0; i < this._sections.length; i++) {
        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
          sources.push(this._sections[i].consumer.sources[j]);
        }
      };
      return sources;
    }
  });

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.
   *   - column: The column number in the generated source.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.
   *   - column: The column number in the original source, or null.
   *   - name: The original identifier, or null.
   */
  IndexedSourceMapConsumer.prototype.originalPositionFor =
    function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
      };

      // Find the section containing the generated position we're trying to map
      // to an original position.
      var sectionIndex = binarySearch.search(needle, this._sections,
        function(needle, section) {
          var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
          if (cmp) {
            return cmp;
          }

          return (needle.generatedColumn -
                  section.generatedOffset.generatedColumn);
        });
      var section = this._sections[sectionIndex];

      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }

      return section.consumer.originalPositionFor({
        line: needle.generatedLine -
          (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn -
          (section.generatedOffset.generatedLine === needle.generatedLine
           ? section.generatedOffset.generatedColumn - 1
           : 0)
      });
    };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * available.
   */
  IndexedSourceMapConsumer.prototype.sourceContentFor =
    function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];

        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      }
      else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: The column number in the original source.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  IndexedSourceMapConsumer.prototype.generatedPositionFor =
    function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];

        // Only consider this section if the requested source is in the list of
        // sources of the consumer.
        if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line +
              (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column +
              (section.generatedOffset.generatedLine === generatedPosition.line
               ? section.generatedOffset.generatedColumn - 1
               : 0)
          };
          return ret;
        }
      }

      return {
        line: null,
        column: null
      };
    };

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  IndexedSourceMapConsumer.prototype._parseMappings =
    function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[i];

          var source = mapping.source;
          var sourceRoot = section.consumer.sourceRoot;

          if (source != null && sourceRoot != null) {
            source = util.join(sourceRoot, source);
          }

          // The mappings coming from the consumer for the section have
          // generated positions relative to the start of the section, so we
          // need to offset them to be relative to the start of the concatenated
          // generated file.
          var adjustedMapping = {
            source: source,
            generatedLine: mapping.generatedLine +
              (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.column +
              (section.generatedOffset.generatedLine === mapping.generatedLine)
              ? section.generatedOffset.generatedColumn - 1
              : 0,
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: mapping.name
          };

          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === 'number') {
            this.__originalMappings.push(adjustedMapping);
          }
        };
      };

    this.__generatedMappings.sort(util.compareByGeneratedPositions);
    this.__originalMappings.sort(util.compareByOriginalPositions);
  };

  exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
});

},{"./basic-source-map-consumer":9,"./binary-search":10,"./source-map-consumer":13,"./util":16,"amdefine":2}],12:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');

  /**
   * Determine whether mappingB is after mappingA with respect to generated
   * position.
   */
  function generatedPositionAfter(mappingA, mappingB) {
    // Optimized for most common case
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA ||
           util.compareByGeneratedPositions(mappingA, mappingB) <= 0;
  }

  /**
   * A data structure to provide a sorted view of accumulated mappings in a
   * performance conscious manner. It trades a neglibable overhead in general
   * case for a large speedup in case of mappings being added in order.
   */
  function MappingList() {
    this._array = [];
    this._sorted = true;
    // Serves as infimum
    this._last = {generatedLine: -1, generatedColumn: 0};
  }

  /**
   * Iterate through internal items. This method takes the same arguments that
   * `Array.prototype.forEach` takes.
   *
   * NOTE: The order of the mappings is NOT guaranteed.
   */
  MappingList.prototype.unsortedForEach =
    function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };

  /**
   * Add the given source mapping.
   *
   * @param Object aMapping
   */
  MappingList.prototype.add = function MappingList_add(aMapping) {
    var mapping;
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };

  /**
   * Returns the flat, sorted array of mappings. The mappings are sorted by
   * generated position.
   *
   * WARNING: This method returns internal data without copying, for
   * performance. The return value must NOT be mutated, and should be treated as
   * an immutable borrow. If you want to take ownership, you must make your own
   * copy.
   */
  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositions);
      this._sorted = true;
    }
    return this._array;
  };

  exports.MappingList = MappingList;

});

},{"./util":16,"amdefine":2}],13:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');

  function SourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    // We do late requires because the subclasses require() this file.
    if (sourceMap.sections != null) {
      var indexedSourceMapConsumer = require('./indexed-source-map-consumer');
      return new indexedSourceMapConsumer.IndexedSourceMapConsumer(sourceMap);
    } else {
      var basicSourceMapConsumer = require('./basic-source-map-consumer');
      return new basicSourceMapConsumer.BasicSourceMapConsumer(sourceMap);
    }
  }

  SourceMapConsumer.fromSourceMap = function(aSourceMap) {
    var basicSourceMapConsumer = require('./basic-source-map-consumer');
    return basicSourceMapConsumer.BasicSourceMapConsumer
            .fromSourceMap(aSourceMap);
  }

  /**
   * The version of the source mapping spec that we are consuming.
   */
  SourceMapConsumer.prototype._version = 3;


  // `__generatedMappings` and `__originalMappings` are arrays that hold the
  // parsed mapping coordinates from the source map's "mappings" attribute. They
  // are lazily instantiated, accessed via the `_generatedMappings` and
  // `_originalMappings` getters respectively, and we only parse the mappings
  // and create these arrays once queried for a source location. We jump through
  // these hoops because there can be many thousands of mappings, and parsing
  // them is expensive, so we only want to do it if we must.
  //
  // Each object in the arrays is of the form:
  //
  //     {
  //       generatedLine: The line number in the generated code,
  //       generatedColumn: The column number in the generated code,
  //       source: The path to the original source file that generated this
  //               chunk of code,
  //       originalLine: The line number in the original source that
  //                     corresponds to this chunk of generated code,
  //       originalColumn: The column number in the original source that
  //                       corresponds to this chunk of generated code,
  //       name: The name of the original symbol which generated this chunk of
  //             code.
  //     }
  //
  // All properties except for `generatedLine` and `generatedColumn` can be
  // `null`.
  //
  // `_generatedMappings` is ordered by the generated positions.
  //
  // `_originalMappings` is ordered by the original positions.

  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
    get: function () {
      if (!this.__generatedMappings) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__generatedMappings;
    }
  });

  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
    get: function () {
      if (!this.__originalMappings) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__originalMappings;
    }
  });

  SourceMapConsumer.prototype._nextCharIsMappingSeparator =
    function SourceMapConsumer_nextCharIsMappingSeparator(aStr) {
      var c = aStr.charAt(0);
      return c === ";" || c === ",";
    };

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  SourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };

  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;

  /**
   * Iterate over each mapping between an original source/line/column and a
   * generated line/column in this source map.
   *
   * @param Function aCallback
   *        The function that is called with each mapping.
   * @param Object aContext
   *        Optional. If specified, this object will be the value of `this` every
   *        time that `aCallback` is called.
   * @param aOrder
   *        Either `SourceMapConsumer.GENERATED_ORDER` or
   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
   *        iterate over the mappings sorted by the generated file's line/column
   *        order or the original's source/line/column order, respectively. Defaults to
   *        `SourceMapConsumer.GENERATED_ORDER`.
   */
  SourceMapConsumer.prototype.eachMapping =
    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

      var mappings;
      switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
      }

      var sourceRoot = this.sourceRoot;
      mappings.map(function (mapping) {
        var source = mapping.source;
        if (source != null && sourceRoot != null) {
          source = util.join(sourceRoot, source);
        }
        return {
          source: source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name
        };
      }).forEach(aCallback, context);
    };

  /**
   * Returns all generated line and column information for the original source
   * and line provided. The only argument is an object with the following
   * properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *
   * and an array of objects is returned, each with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  SourceMapConsumer.prototype.allGeneratedPositionsFor =
    function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
      // returns the index of the closest mapping less than the needle. By
      // setting needle.originalColumn to Infinity, we thus find the last
      // mapping for the given line, provided such a mapping exists.
      var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: Infinity
      };

      if (this.sourceRoot != null) {
        needle.source = util.relative(this.sourceRoot, needle.source);
      }

      var mappings = [];

      var index = this._findMapping(needle,
                                    this._originalMappings,
                                    "originalLine",
                                    "originalColumn",
                                    util.compareByOriginalPositions);
      if (index >= 0) {
        var mapping = this._originalMappings[index];

        while (mapping && mapping.originalLine === needle.originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[--index];
        }
      }

      return mappings.reverse();
    };

  exports.SourceMapConsumer = SourceMapConsumer;

});

},{"./basic-source-map-consumer":9,"./indexed-source-map-consumer":11,"./util":16,"amdefine":2}],14:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var base64VLQ = require('./base64-vlq');
  var util = require('./util');
  var ArraySet = require('./array-set').ArraySet;
  var MappingList = require('./mapping-list').MappingList;

  /**
   * An instance of the SourceMapGenerator represents a source map which is
   * being built incrementally. You may pass an object with the following
   * properties:
   *
   *   - file: The filename of the generated source.
   *   - sourceRoot: A root for all relative URLs in this source map.
   */
  function SourceMapGenerator(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, 'file', null);
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }

  SourceMapGenerator.prototype._version = 3;

  /**
   * Creates a new SourceMapGenerator based on a SourceMapConsumer
   *
   * @param aSourceMapConsumer The SourceMap.
   */
  SourceMapGenerator.fromSourceMap =
    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot: sourceRoot
      });
      aSourceMapConsumer.eachMapping(function (mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };

        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }

          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };

          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }

        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };

  /**
   * Add a single mapping from original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */
  SourceMapGenerator.prototype.addMapping =
    function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, 'generated');
      var original = util.getArg(aArgs, 'original', null);
      var source = util.getArg(aArgs, 'source', null);
      var name = util.getArg(aArgs, 'name', null);

      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }

      if (source != null && !this._sources.has(source)) {
        this._sources.add(source);
      }

      if (name != null && !this._names.has(name)) {
        this._names.add(name);
      }

      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source,
        name: name
      });
    };

  /**
   * Set the source content for a source file.
   */
  SourceMapGenerator.prototype.setSourceContent =
    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }

      if (aSourceContent != null) {
        // Add the source content to the _sourcesContents map.
        // Create a new _sourcesContents map if the property is null.
        if (!this._sourcesContents) {
          this._sourcesContents = {};
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        // Remove the source file from the _sourcesContents map.
        // If the _sourcesContents map is empty, set the property to null.
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };

  /**
   * Applies the mappings of a sub-source-map for a specific source file to the
   * source map being generated. Each mapping to the supplied source file is
   * rewritten using the supplied source map. Note: The resolution for the
   * resulting mappings is the minimium of this map and the supplied map.
   *
   * @param aSourceMapConsumer The source map to be applied.
   * @param aSourceFile Optional. The filename of the source file.
   *        If omitted, SourceMapConsumer's file property will be used.
   * @param aSourceMapPath Optional. The dirname of the path to the source map
   *        to be applied. If relative, it is relative to the SourceMapConsumer.
   *        This parameter is needed when the two source maps aren't in the same
   *        directory, and the source map to be applied contains relative source
   *        paths. If so, those relative source paths need to be rewritten
   *        relative to the SourceMapGenerator.
   */
  SourceMapGenerator.prototype.applySourceMap =
    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      // If aSourceFile is omitted, we will use the file property of the SourceMap
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
            'or the source map\'s "file" property. Both were omitted.'
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      // Make "sourceFile" relative if an absolute Url is passed.
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      // Applying the SourceMap can add and remove items from the sources and
      // the names array.
      var newSources = new ArraySet();
      var newNames = new ArraySet();

      // Find mappings for the "sourceFile"
      this._mappings.unsortedForEach(function (mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          // Check if it can be mapped by the source map, then update the mapping.
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            // Copy mapping
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source)
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }

        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }

        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }

      }, this);
      this._sources = newSources;
      this._names = newNames;

      // Copy sourcesContents of applied map.
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile = util.join(aSourceMapPath, sourceFile);
          }
          if (sourceRoot != null) {
            sourceFile = util.relative(sourceRoot, sourceFile);
          }
          this.setSourceContent(sourceFile, content);
        }
      }, this);
    };

  /**
   * A mapping can have one of the three levels of data:
   *
   *   1. Just the generated position.
   *   2. The Generated position, original position, and original source.
   *   3. Generated and original position, original source, as well as a name
   *      token.
   *
   * To maintain consistency, we validate that any new mapping being added falls
   * in to one of these categories.
   */
  SourceMapGenerator.prototype._validateMapping =
    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                                aName) {
      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
          && aGenerated.line > 0 && aGenerated.column >= 0
          && !aOriginal && !aSource && !aName) {
        // Case 1.
        return;
      }
      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
               && aOriginal && 'line' in aOriginal && 'column' in aOriginal
               && aGenerated.line > 0 && aGenerated.column >= 0
               && aOriginal.line > 0 && aOriginal.column >= 0
               && aSource) {
        // Cases 2 and 3.
        return;
      }
      else {
        throw new Error('Invalid mapping: ' + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };

  /**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */
  SourceMapGenerator.prototype._serializeMappings =
    function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = '';
      var mapping;

      var mappings = this._mappings.toArray();

      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];

        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            result += ';';
            previousGeneratedLine++;
          }
        }
        else {
          if (i > 0) {
            if (!util.compareByGeneratedPositions(mapping, mappings[i - 1])) {
              continue;
            }
            result += ',';
          }
        }

        result += base64VLQ.encode(mapping.generatedColumn
                                   - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;

        if (mapping.source != null) {
          result += base64VLQ.encode(this._sources.indexOf(mapping.source)
                                     - previousSource);
          previousSource = this._sources.indexOf(mapping.source);

          // lines are stored 0-based in SourceMap spec version 3
          result += base64VLQ.encode(mapping.originalLine - 1
                                     - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;

          result += base64VLQ.encode(mapping.originalColumn
                                     - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;

          if (mapping.name != null) {
            result += base64VLQ.encode(this._names.indexOf(mapping.name)
                                       - previousName);
            previousName = this._names.indexOf(mapping.name);
          }
        }
      }

      return result;
    };

  SourceMapGenerator.prototype._generateSourcesContent =
    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function (source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents,
                                                    key)
          ? this._sourcesContents[key]
          : null;
      }, this);
    };

  /**
   * Externalize the source map.
   */
  SourceMapGenerator.prototype.toJSON =
    function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }

      return map;
    };

  /**
   * Render the source map being generated to a string.
   */
  SourceMapGenerator.prototype.toString =
    function SourceMapGenerator_toString() {
      return JSON.stringify(this);
    };

  exports.SourceMapGenerator = SourceMapGenerator;

});

},{"./array-set":6,"./base64-vlq":7,"./mapping-list":12,"./util":16,"amdefine":2}],15:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
  var util = require('./util');

  // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
  // operating systems these days (capturing the result).
  var REGEX_NEWLINE = /(\r?\n)/;

  // Newline character code for charCodeAt() comparisons
  var NEWLINE_CODE = 10;

  // Private symbol for identifying `SourceNode`s when multiple versions of
  // the source-map library are loaded. This MUST NOT CHANGE across
  // versions!
  var isSourceNode = "$$$isSourceNode$$$";

  /**
   * SourceNodes provide a way to abstract over interpolating/concatenating
   * snippets of generated JavaScript source code while maintaining the line and
   * column information associated with the original source code.
   *
   * @param aLine The original line number.
   * @param aColumn The original column number.
   * @param aSource The original source's filename.
   * @param aChunks Optional. An array of strings which are snippets of
   *        generated JS, or other SourceNodes.
   * @param aName The original identifier.
   */
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null) this.add(aChunks);
  }

  /**
   * Creates a SourceNode from generated code and a SourceMapConsumer.
   *
   * @param aGeneratedCode The generated code
   * @param aSourceMapConsumer The SourceMap for the generated code
   * @param aRelativePath Optional. The path that relative sources in the
   *        SourceMapConsumer should be relative to.
   */
  SourceNode.fromStringWithSourceMap =
    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      // The SourceNode we want to fill with the generated code
      // and the SourceMap
      var node = new SourceNode();

      // All even indices of this array are one line of the generated code,
      // while all odd indices are the newlines between two adjacent lines
      // (since `REGEX_NEWLINE` captures its match).
      // Processed fragments are removed from this array, by calling `shiftNextLine`.
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var shiftNextLine = function() {
        var lineContents = remainingLines.shift();
        // The last line of a file might not have a newline.
        var newLine = remainingLines.shift() || "";
        return lineContents + newLine;
      };

      // We need to remember the position of "remainingLines"
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;

      // The generate SourceNodes we need a code range.
      // To extract it current and last mapping is used.
      // Here we store the last mapping.
      var lastMapping = null;

      aSourceMapConsumer.eachMapping(function (mapping) {
        if (lastMapping !== null) {
          // We add the code from "lastMapping" to "mapping":
          // First check if there is a new line in between.
          if (lastGeneratedLine < mapping.generatedLine) {
            var code = "";
            // Associate first line with "lastMapping"
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
            // The remaining code is added without mapping
          } else {
            // There is no new line in between.
            // Associate the code between "lastGeneratedColumn" and
            // "mapping.generatedColumn" with "lastMapping"
            var nextLine = remainingLines[0];
            var code = nextLine.substr(0, mapping.generatedColumn -
                                          lastGeneratedColumn);
            remainingLines[0] = nextLine.substr(mapping.generatedColumn -
                                                lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            // No more remaining code, continue
            lastMapping = mapping;
            return;
          }
        }
        // We add the generated code until the first mapping
        // to the SourceNode without any mapping.
        // Each line is added as separate string.
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[0];
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[0] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      // We have processed all mappings.
      if (remainingLines.length > 0) {
        if (lastMapping) {
          // Associate the remaining code in the current line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        // and add the remaining lines without any mapping
        node.add(remainingLines.join(""));
      }

      // Copy sourcesContent into SourceNode
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });

      return node;

      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === undefined) {
          node.add(code);
        } else {
          var source = aRelativePath
            ? util.join(aRelativePath, mapping.source)
            : mapping.source;
          node.add(new SourceNode(mapping.originalLine,
                                  mapping.originalColumn,
                                  source,
                                  code,
                                  mapping.name));
        }
      }
    };

  /**
   * Add a chunk of generated JS to this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function (chunk) {
        this.add(chunk);
      }, this);
    }
    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Add a chunk of generated JS to the beginning of this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length-1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    }
    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Walk over the tree of JS snippets in this node and its children. The
   * walking function is called once for each snippet of JS and is passed that
   * snippet and the its original associated source's line/column location.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      }
      else {
        if (chunk !== '') {
          aFn(chunk, { source: this.source,
                       line: this.line,
                       column: this.column,
                       name: this.name });
        }
      }
    }
  };

  /**
   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
   * each of `this.children`.
   *
   * @param aSep The separator.
   */
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len-1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };

  /**
   * Call String.prototype.replace on the very right-most source snippet. Useful
   * for trimming whitespace from the end of a source node, etc.
   *
   * @param aPattern The pattern to replace.
   * @param aReplacement The thing to replace the pattern with.
   */
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    }
    else if (typeof lastChild === 'string') {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    }
    else {
      this.children.push(''.replace(aPattern, aReplacement));
    }
    return this;
  };

  /**
   * Set the source content for a source file. This will be added to the SourceMapGenerator
   * in the sourcesContent field.
   *
   * @param aSourceFile The filename of the source file
   * @param aSourceContent The content of the source file
   */
  SourceNode.prototype.setSourceContent =
    function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };

  /**
   * Walk over the tree of SourceNodes. The walking function is called for each
   * source file content and is passed the filename and source content.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walkSourceContents =
    function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }

      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };

  /**
   * Return the string representation of this source node. Walks over the tree
   * and concatenates all the various snippets together to one string.
   */
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function (chunk) {
      str += chunk;
    });
    return str;
  };

  /**
   * Returns the string representation of this source node along with a source
   * map.
   */
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function (chunk, original) {
      generated.code += chunk;
      if (original.source !== null
          && original.line !== null
          && original.column !== null) {
        if(lastOriginalSource !== original.source
           || lastOriginalLine !== original.line
           || lastOriginalColumn !== original.column
           || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      for (var idx = 0, length = chunk.length; idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0;
          // Mappings end at eol
          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function (sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });

    return { code: generated.code, map: map };
  };

  exports.SourceNode = SourceNode;

});

},{"./source-map-generator":14,"./util":16,"amdefine":2}],16:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  /**
   * This is a helper function for getting values from parameter/options
   * objects.
   *
   * @param args The object we are extracting values from
   * @param name The name of the property we are getting.
   * @param defaultValue An optional value to return if the property is missing
   * from the object. If this is not specified and the property is missing, an
   * error will be thrown.
   */
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }
  exports.getArg = getArg;

  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;

  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  }
  exports.urlParse = urlParse;

  function urlGenerate(aParsedUrl) {
    var url = '';
    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ':';
    }
    url += '//';
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + '@';
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  }
  exports.urlGenerate = urlGenerate;

  /**
   * Normalizes a path, or the path portion of a URL:
   *
   * - Replaces consequtive slashes with one slash.
   * - Removes unnecessary '.' parts.
   * - Removes unnecessary '<dir>/..' parts.
   *
   * Based on code in the Node.js 'path' core module.
   *
   * @param aPath The path or url to normalize.
   */
  function normalize(aPath) {
    var path = aPath;
    var url = urlParse(aPath);
    if (url) {
      if (!url.path) {
        return aPath;
      }
      path = url.path;
    }
    var isAbsolute = (path.charAt(0) === '/');

    var parts = path.split(/\/+/);
    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
      part = parts[i];
      if (part === '.') {
        parts.splice(i, 1);
      } else if (part === '..') {
        up++;
      } else if (up > 0) {
        if (part === '') {
          // The first part is blank if the path is absolute. Trying to go
          // above the root is a no-op. Therefore we can remove all '..' parts
          // directly after the root.
          parts.splice(i + 1, up);
          up = 0;
        } else {
          parts.splice(i, 2);
          up--;
        }
      }
    }
    path = parts.join('/');

    if (path === '') {
      path = isAbsolute ? '/' : '.';
    }

    if (url) {
      url.path = path;
      return urlGenerate(url);
    }
    return path;
  }
  exports.normalize = normalize;

  /**
   * Joins two paths/URLs.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be joined with the root.
   *
   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
   *   first.
   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
   *   is updated with the result and aRoot is returned. Otherwise the result
   *   is returned.
   *   - If aPath is absolute, the result is aPath.
   *   - Otherwise the two paths are joined with a slash.
   * - Joining for example 'http://' and 'www.example.com' is also supported.
   */
  function join(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    if (aPath === "") {
      aPath = ".";
    }
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
      aRoot = aRootUrl.path || '/';
    }

    // `join(foo, '//www.example.org')`
    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }
      return urlGenerate(aPathUrl);
    }

    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }

    // `join('http://', 'www.example.com')`
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }

    var joined = aPath.charAt(0) === '/'
      ? aPath
      : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }
    return joined;
  }
  exports.join = join;

  /**
   * Make a path relative to a URL or another path.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be made relative to aRoot.
   */
  function relative(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }

    aRoot = aRoot.replace(/\/$/, '');

    // XXX: It is possible to remove this block, and the tests still pass!
    var url = urlParse(aRoot);
    if (aPath.charAt(0) == "/" && url && url.path == "/") {
      return aPath.slice(1);
    }

    return aPath.indexOf(aRoot + '/') === 0
      ? aPath.substr(aRoot.length + 1)
      : aPath;
  }
  exports.relative = relative;

  /**
   * Because behavior goes wacky when you set `__proto__` on objects, we
   * have to prefix all the strings in our set with an arbitrary character.
   *
   * See https://github.com/mozilla/source-map/pull/31 and
   * https://github.com/mozilla/source-map/issues/30
   *
   * @param String aStr
   */
  function toSetString(aStr) {
    return '$' + aStr;
  }
  exports.toSetString = toSetString;

  function fromSetString(aStr) {
    return aStr.substr(1);
  }
  exports.fromSetString = fromSetString;

  function strcmp(aStr1, aStr2) {
    var s1 = aStr1 || "";
    var s2 = aStr2 || "";
    return (s1 > s2) - (s1 < s2);
  }

  /**
   * Comparator between two mappings where the original positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same original source/line/column, but different generated
   * line and column the same. Useful when searching for a mapping with a
   * stubbed out mapping.
   */
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp;

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp || onlyCompareOriginal) {
      return cmp;
    }

    cmp = strcmp(mappingA.name, mappingB.name);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp) {
      return cmp;
    }

    return mappingA.generatedColumn - mappingB.generatedColumn;
  };
  exports.compareByOriginalPositions = compareByOriginalPositions;

  /**
   * Comparator between two mappings where the generated positions are
   * compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same generated line and column, but different
   * source/name/original line and column the same. Useful when searching for a
   * mapping with a stubbed out mapping.
   */
  function compareByGeneratedPositions(mappingA, mappingB, onlyCompareGenerated) {
    var cmp;

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp || onlyCompareGenerated) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  };
  exports.compareByGeneratedPositions = compareByGeneratedPositions;

});

},{"amdefine":2}],17:[function(require,module,exports){
module.exports={
  "_args": [
    [
      "escodegen@^1.6.1",
      "/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/pausable"
    ]
  ],
  "_from": "escodegen@>=1.6.1 <2.0.0",
  "_id": "escodegen@1.8.1",
  "_inCache": true,
  "_installable": true,
  "_location": "/escodegen",
  "_nodeVersion": "6.3.0",
  "_npmOperationalInternal": {
    "host": "packages-12-west.internal.npmjs.com",
    "tmp": "tmp/escodegen-1.8.1.tgz_1470506723009_0.12818681285716593"
  },
  "_npmUser": {
    "email": "npm@michael.ficarra.me",
    "name": "michaelficarra"
  },
  "_npmVersion": "3.10.3",
  "_phantomChildren": {
    "amdefine": "1.0.0"
  },
  "_requested": {
    "name": "escodegen",
    "raw": "escodegen@^1.6.1",
    "rawSpec": "^1.6.1",
    "scope": null,
    "spec": ">=1.6.1 <2.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/pausable"
  ],
  "_resolved": "https://registry.npmjs.org/escodegen/-/escodegen-1.8.1.tgz",
  "_shasum": "5a5b53af4693110bebb0867aa3430dd3b70a1018",
  "_shrinkwrap": null,
  "_spec": "escodegen@^1.6.1",
  "_where": "/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/pausable",
  "bin": {
    "escodegen": "./bin/escodegen.js",
    "esgenerate": "./bin/esgenerate.js"
  },
  "bugs": {
    "url": "https://github.com/estools/escodegen/issues"
  },
  "dependencies": {
    "esprima": "^2.7.1",
    "estraverse": "^1.9.1",
    "esutils": "^2.0.2",
    "optionator": "^0.8.1",
    "source-map": "~0.2.0"
  },
  "description": "ECMAScript code generator",
  "devDependencies": {
    "acorn": "^2.7.0",
    "bluebird": "^2.3.11",
    "bower-registry-client": "^0.2.1",
    "chai": "^1.10.0",
    "commonjs-everywhere": "^0.9.7",
    "gulp": "^3.8.10",
    "gulp-eslint": "^0.2.0",
    "gulp-mocha": "^2.0.0",
    "semver": "^5.1.0"
  },
  "directories": {},
  "dist": {
    "shasum": "5a5b53af4693110bebb0867aa3430dd3b70a1018",
    "tarball": "https://registry.npmjs.org/escodegen/-/escodegen-1.8.1.tgz"
  },
  "engines": {
    "node": ">=0.12.0"
  },
  "files": [
    "LICENSE.BSD",
    "LICENSE.source-map",
    "README.md",
    "bin",
    "escodegen.js",
    "package.json"
  ],
  "gitHead": "ba4faabb224b2d5e0080c8e4f964702b699c7d1f",
  "homepage": "http://github.com/estools/escodegen",
  "license": "BSD-2-Clause",
  "main": "escodegen.js",
  "maintainers": [
    {
      "email": "utatane.tea@gmail.com",
      "name": "constellation"
    },
    {
      "email": "npm@michael.ficarra.me",
      "name": "michaelficarra"
    }
  ],
  "name": "escodegen",
  "optionalDependencies": {
    "source-map": "~0.2.0"
  },
  "readme": "ERROR: No README data found!",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/estools/escodegen.git"
  },
  "scripts": {
    "build": "cjsify -a path: tools/entry-point.js > escodegen.browser.js",
    "build-min": "cjsify -ma path: tools/entry-point.js > escodegen.browser.min.js",
    "lint": "gulp lint",
    "release": "node tools/release.js",
    "test": "gulp travis",
    "unit-test": "gulp test"
  },
  "version": "1.8.1"
}

},{}],18:[function(require,module,exports){
/*
  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*jslint vars:false, bitwise:true*/
/*jshint indent:4*/
/*global exports:true*/
(function clone(exports) {
    'use strict';

    var Syntax,
        isArray,
        VisitorOption,
        VisitorKeys,
        objectCreate,
        objectKeys,
        BREAK,
        SKIP,
        REMOVE;

    function ignoreJSHintError() { }

    isArray = Array.isArray;
    if (!isArray) {
        isArray = function isArray(array) {
            return Object.prototype.toString.call(array) === '[object Array]';
        };
    }

    function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                val = obj[key];
                if (typeof val === 'object' && val !== null) {
                    ret[key] = deepCopy(val);
                } else {
                    ret[key] = val;
                }
            }
        }
        return ret;
    }

    function shallowCopy(obj) {
        var ret = {}, key;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                ret[key] = obj[key];
            }
        }
        return ret;
    }
    ignoreJSHintError(shallowCopy);

    // based on LLVM libc++ upper_bound / lower_bound
    // MIT License

    function upperBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                len = diff;
            } else {
                i = current + 1;
                len -= diff + 1;
            }
        }
        return i;
    }

    function lowerBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                i = current + 1;
                len -= diff + 1;
            } else {
                len = diff;
            }
        }
        return i;
    }
    ignoreJSHintError(lowerBound);

    objectCreate = Object.create || (function () {
        function F() { }

        return function (o) {
            F.prototype = o;
            return new F();
        };
    })();

    objectKeys = Object.keys || function (o) {
        var keys = [], key;
        for (key in o) {
            keys.push(key);
        }
        return keys;
    };

    function extend(to, from) {
        var keys = objectKeys(from), key, i, len;
        for (i = 0, len = keys.length; i < len; i += 1) {
            key = keys[i];
            to[key] = from[key];
        }
        return to;
    }

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        AssignmentPattern: 'AssignmentPattern',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        AwaitExpression: 'AwaitExpression', // CAUTION: It's deferred to ES7.
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ComprehensionBlock: 'ComprehensionBlock',  // CAUTION: It's deferred to ES7.
        ComprehensionExpression: 'ComprehensionExpression',  // CAUTION: It's deferred to ES7.
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DebuggerStatement: 'DebuggerStatement',
        DirectiveStatement: 'DirectiveStatement',
        DoWhileStatement: 'DoWhileStatement',
        EmptyStatement: 'EmptyStatement',
        ExportAllDeclaration: 'ExportAllDeclaration',
        ExportDefaultDeclaration: 'ExportDefaultDeclaration',
        ExportNamedDeclaration: 'ExportNamedDeclaration',
        ExportSpecifier: 'ExportSpecifier',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        ForOfStatement: 'ForOfStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        GeneratorExpression: 'GeneratorExpression',  // CAUTION: It's deferred to ES7.
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        ImportDeclaration: 'ImportDeclaration',
        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
        ImportSpecifier: 'ImportSpecifier',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MetaProperty: 'MetaProperty',
        MethodDefinition: 'MethodDefinition',
        ModuleSpecifier: 'ModuleSpecifier',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        RestElement: 'RestElement',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SpreadElement: 'SpreadElement',
        Super: 'Super',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        TaggedTemplateExpression: 'TaggedTemplateExpression',
        TemplateElement: 'TemplateElement',
        TemplateLiteral: 'TemplateLiteral',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
    };

    VisitorKeys = {
        AssignmentExpression: ['left', 'right'],
        AssignmentPattern: ['left', 'right'],
        ArrayExpression: ['elements'],
        ArrayPattern: ['elements'],
        ArrowFunctionExpression: ['params', 'body'],
        AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.
        BlockStatement: ['body'],
        BinaryExpression: ['left', 'right'],
        BreakStatement: ['label'],
        CallExpression: ['callee', 'arguments'],
        CatchClause: ['param', 'body'],
        ClassBody: ['body'],
        ClassDeclaration: ['id', 'superClass', 'body'],
        ClassExpression: ['id', 'superClass', 'body'],
        ComprehensionBlock: ['left', 'right'],  // CAUTION: It's deferred to ES7.
        ComprehensionExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
        ConditionalExpression: ['test', 'consequent', 'alternate'],
        ContinueStatement: ['label'],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ['body', 'test'],
        EmptyStatement: [],
        ExportAllDeclaration: ['source'],
        ExportDefaultDeclaration: ['declaration'],
        ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],
        ExportSpecifier: ['exported', 'local'],
        ExpressionStatement: ['expression'],
        ForStatement: ['init', 'test', 'update', 'body'],
        ForInStatement: ['left', 'right', 'body'],
        ForOfStatement: ['left', 'right', 'body'],
        FunctionDeclaration: ['id', 'params', 'body'],
        FunctionExpression: ['id', 'params', 'body'],
        GeneratorExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
        Identifier: [],
        IfStatement: ['test', 'consequent', 'alternate'],
        ImportDeclaration: ['specifiers', 'source'],
        ImportDefaultSpecifier: ['local'],
        ImportNamespaceSpecifier: ['local'],
        ImportSpecifier: ['imported', 'local'],
        Literal: [],
        LabeledStatement: ['label', 'body'],
        LogicalExpression: ['left', 'right'],
        MemberExpression: ['object', 'property'],
        MetaProperty: ['meta', 'property'],
        MethodDefinition: ['key', 'value'],
        ModuleSpecifier: [],
        NewExpression: ['callee', 'arguments'],
        ObjectExpression: ['properties'],
        ObjectPattern: ['properties'],
        Program: ['body'],
        Property: ['key', 'value'],
        RestElement: [ 'argument' ],
        ReturnStatement: ['argument'],
        SequenceExpression: ['expressions'],
        SpreadElement: ['argument'],
        Super: [],
        SwitchStatement: ['discriminant', 'cases'],
        SwitchCase: ['test', 'consequent'],
        TaggedTemplateExpression: ['tag', 'quasi'],
        TemplateElement: [],
        TemplateLiteral: ['quasis', 'expressions'],
        ThisExpression: [],
        ThrowStatement: ['argument'],
        TryStatement: ['block', 'handler', 'finalizer'],
        UnaryExpression: ['argument'],
        UpdateExpression: ['argument'],
        VariableDeclaration: ['declarations'],
        VariableDeclarator: ['id', 'init'],
        WhileStatement: ['test', 'body'],
        WithStatement: ['object', 'body'],
        YieldExpression: ['argument']
    };

    // unique id
    BREAK = {};
    SKIP = {};
    REMOVE = {};

    VisitorOption = {
        Break: BREAK,
        Skip: SKIP,
        Remove: REMOVE
    };

    function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
    }

    Reference.prototype.replace = function replace(node) {
        this.parent[this.key] = node;
    };

    Reference.prototype.remove = function remove() {
        if (isArray(this.parent)) {
            this.parent.splice(this.key, 1);
            return true;
        } else {
            this.replace(null);
            return false;
        }
    };

    function Element(node, path, wrap, ref) {
        this.node = node;
        this.path = path;
        this.wrap = wrap;
        this.ref = ref;
    }

    function Controller() { }

    // API:
    // return property path array from root to current node
    Controller.prototype.path = function path() {
        var i, iz, j, jz, result, element;

        function addToPath(result, path) {
            if (isArray(path)) {
                for (j = 0, jz = path.length; j < jz; ++j) {
                    result.push(path[j]);
                }
            } else {
                result.push(path);
            }
        }

        // root node
        if (!this.__current.path) {
            return null;
        }

        // first node is sentinel, second node is root element
        result = [];
        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
            element = this.__leavelist[i];
            addToPath(result, element.path);
        }
        addToPath(result, this.__current.path);
        return result;
    };

    // API:
    // return type of current node
    Controller.prototype.type = function () {
        var node = this.current();
        return node.type || this.__current.wrap;
    };

    // API:
    // return array of parent elements
    Controller.prototype.parents = function parents() {
        var i, iz, result;

        // first node is sentinel
        result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
            result.push(this.__leavelist[i].node);
        }

        return result;
    };

    // API:
    // return current node
    Controller.prototype.current = function current() {
        return this.__current.node;
    };

    Controller.prototype.__execute = function __execute(callback, element) {
        var previous, result;

        result = undefined;

        previous  = this.__current;
        this.__current = element;
        this.__state = null;
        if (callback) {
            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;

        return result;
    };

    // API:
    // notify control skip / break
    Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
    };

    // API:
    // skip child nodes of current node
    Controller.prototype.skip = function () {
        this.notify(SKIP);
    };

    // API:
    // break traversals
    Controller.prototype['break'] = function () {
        this.notify(BREAK);
    };

    // API:
    // remove node
    Controller.prototype.remove = function () {
        this.notify(REMOVE);
    };

    Controller.prototype.__initialize = function(root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
        this.__fallback = null;
        if (visitor.fallback === 'iteration') {
            this.__fallback = objectKeys;
        } else if (typeof visitor.fallback === 'function') {
            this.__fallback = visitor.fallback;
        }

        this.__keys = VisitorKeys;
        if (visitor.keys) {
            this.__keys = extend(objectCreate(this.__keys), visitor.keys);
        }
    };

    function isNode(node) {
        if (node == null) {
            return false;
        }
        return typeof node === 'object' && typeof node.type === 'string';
    }

    function isProperty(nodeType, key) {
        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
    }

    Controller.prototype.traverse = function traverse(root, visitor) {
        var worklist,
            leavelist,
            element,
            node,
            nodeType,
            ret,
            key,
            current,
            current2,
            candidates,
            candidate,
            sentinel;

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        worklist.push(new Element(root, null, null, null));
        leavelist.push(new Element(null, null, null, null));

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                ret = this.__execute(visitor.leave, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }
                continue;
            }

            if (element.node) {

                ret = this.__execute(visitor.enter, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }

                worklist.push(sentinel);
                leavelist.push(element);

                if (this.__state === SKIP || ret === SKIP) {
                    continue;
                }

                node = element.node;
                nodeType = node.type || element.wrap;
                candidates = this.__keys[nodeType];
                if (!candidates) {
                    if (this.__fallback) {
                        candidates = this.__fallback(node);
                    } else {
                        throw new Error('Unknown node type ' + nodeType + '.');
                    }
                }

                current = candidates.length;
                while ((current -= 1) >= 0) {
                    key = candidates[current];
                    candidate = node[key];
                    if (!candidate) {
                        continue;
                    }

                    if (isArray(candidate)) {
                        current2 = candidate.length;
                        while ((current2 -= 1) >= 0) {
                            if (!candidate[current2]) {
                                continue;
                            }
                            if (isProperty(nodeType, candidates[current])) {
                                element = new Element(candidate[current2], [key, current2], 'Property', null);
                            } else if (isNode(candidate[current2])) {
                                element = new Element(candidate[current2], [key, current2], null, null);
                            } else {
                                continue;
                            }
                            worklist.push(element);
                        }
                    } else if (isNode(candidate)) {
                        worklist.push(new Element(candidate, key, null, null));
                    }
                }
            }
        }
    };

    Controller.prototype.replace = function replace(root, visitor) {
        var worklist,
            leavelist,
            node,
            nodeType,
            target,
            element,
            current,
            current2,
            candidates,
            candidate,
            sentinel,
            outer,
            key;

        function removeElem(element) {
            var i,
                key,
                nextElem,
                parent;

            if (element.ref.remove()) {
                // When the reference is an element of an array.
                key = element.ref.key;
                parent = element.ref.parent;

                // If removed from array, then decrease following items' keys.
                i = worklist.length;
                while (i--) {
                    nextElem = worklist[i];
                    if (nextElem.ref && nextElem.ref.parent === parent) {
                        if  (nextElem.ref.key < key) {
                            break;
                        }
                        --nextElem.ref.key;
                    }
                }
            }
        }

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        outer = {
            root: root
        };
        element = new Element(root, null, null, new Reference(outer, 'root'));
        worklist.push(element);
        leavelist.push(element);

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                target = this.__execute(visitor.leave, element);

                // node may be replaced with null,
                // so distinguish between undefined and null in this place
                if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                    // replace
                    element.ref.replace(target);
                }

                if (this.__state === REMOVE || target === REMOVE) {
                    removeElem(element);
                }

                if (this.__state === BREAK || target === BREAK) {
                    return outer.root;
                }
                continue;
            }

            target = this.__execute(visitor.enter, element);

            // node may be replaced with null,
            // so distinguish between undefined and null in this place
            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                // replace
                element.ref.replace(target);
                element.node = target;
            }

            if (this.__state === REMOVE || target === REMOVE) {
                removeElem(element);
                element.node = null;
            }

            if (this.__state === BREAK || target === BREAK) {
                return outer.root;
            }

            // node may be null
            node = element.node;
            if (!node) {
                continue;
            }

            worklist.push(sentinel);
            leavelist.push(element);

            if (this.__state === SKIP || target === SKIP) {
                continue;
            }

            nodeType = node.type || element.wrap;
            candidates = this.__keys[nodeType];
            if (!candidates) {
                if (this.__fallback) {
                    candidates = this.__fallback(node);
                } else {
                    throw new Error('Unknown node type ' + nodeType + '.');
                }
            }

            current = candidates.length;
            while ((current -= 1) >= 0) {
                key = candidates[current];
                candidate = node[key];
                if (!candidate) {
                    continue;
                }

                if (isArray(candidate)) {
                    current2 = candidate.length;
                    while ((current2 -= 1) >= 0) {
                        if (!candidate[current2]) {
                            continue;
                        }
                        if (isProperty(nodeType, candidates[current])) {
                            element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
                        } else if (isNode(candidate[current2])) {
                            element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
                        } else {
                            continue;
                        }
                        worklist.push(element);
                    }
                } else if (isNode(candidate)) {
                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));
                }
            }
        }

        return outer.root;
    };

    function traverse(root, visitor) {
        var controller = new Controller();
        return controller.traverse(root, visitor);
    }

    function replace(root, visitor) {
        var controller = new Controller();
        return controller.replace(root, visitor);
    }

    function extendCommentRange(comment, tokens) {
        var target;

        target = upperBound(tokens, function search(token) {
            return token.range[0] > comment.range[0];
        });

        comment.extendedRange = [comment.range[0], comment.range[1]];

        if (target !== tokens.length) {
            comment.extendedRange[1] = tokens[target].range[0];
        }

        target -= 1;
        if (target >= 0) {
            comment.extendedRange[0] = tokens[target].range[1];
        }

        return comment;
    }

    function attachComments(tree, providedComments, tokens) {
        // At first, we should calculate extended comment ranges.
        var comments = [], comment, len, i, cursor;

        if (!tree.range) {
            throw new Error('attachComments needs range information');
        }

        // tokens array is empty, we attach comments to tree as 'leadingComments'
        if (!tokens.length) {
            if (providedComments.length) {
                for (i = 0, len = providedComments.length; i < len; i += 1) {
                    comment = deepCopy(providedComments[i]);
                    comment.extendedRange = [0, tree.range[0]];
                    comments.push(comment);
                }
                tree.leadingComments = comments;
            }
            return tree;
        }

        for (i = 0, len = providedComments.length; i < len; i += 1) {
            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        }

        // This is based on John Freeman's implementation.
        cursor = 0;
        traverse(tree, {
            enter: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (comment.extendedRange[1] > node.range[0]) {
                        break;
                    }

                    if (comment.extendedRange[1] === node.range[0]) {
                        if (!node.leadingComments) {
                            node.leadingComments = [];
                        }
                        node.leadingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        cursor = 0;
        traverse(tree, {
            leave: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (node.range[1] < comment.extendedRange[0]) {
                        break;
                    }

                    if (node.range[1] === comment.extendedRange[0]) {
                        if (!node.trailingComments) {
                            node.trailingComments = [];
                        }
                        node.trailingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        return tree;
    }

    exports.version = require('./package.json').version;
    exports.Syntax = Syntax;
    exports.traverse = traverse;
    exports.replace = replace;
    exports.attachComments = attachComments;
    exports.VisitorKeys = VisitorKeys;
    exports.VisitorOption = VisitorOption;
    exports.Controller = Controller;
    exports.cloneEnvironment = function () { return clone({}); };

    return exports;
}(exports));
/* vim: set sw=4 ts=4 et tw=80 : */

},{"./package.json":19}],19:[function(require,module,exports){
module.exports={
  "_args": [
    [
      "estraverse@^4.1.0",
      "/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/pausable"
    ]
  ],
  "_from": "estraverse@>=4.1.0 <5.0.0",
  "_id": "estraverse@4.2.0",
  "_inCache": true,
  "_installable": true,
  "_location": "/estraverse",
  "_nodeVersion": "0.12.9",
  "_npmOperationalInternal": {
    "host": "packages-12-west.internal.npmjs.com",
    "tmp": "tmp/estraverse-4.2.0.tgz_1457646738925_0.7118953282479197"
  },
  "_npmUser": {
    "email": "nicholas@nczconsulting.com",
    "name": "nzakas"
  },
  "_npmVersion": "2.14.9",
  "_phantomChildren": {},
  "_requested": {
    "name": "estraverse",
    "raw": "estraverse@^4.1.0",
    "rawSpec": "^4.1.0",
    "scope": null,
    "spec": ">=4.1.0 <5.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/pausable"
  ],
  "_resolved": "https://registry.npmjs.org/estraverse/-/estraverse-4.2.0.tgz",
  "_shasum": "0dee3fed31fcd469618ce7342099fc1afa0bdb13",
  "_shrinkwrap": null,
  "_spec": "estraverse@^4.1.0",
  "_where": "/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/pausable",
  "bugs": {
    "url": "https://github.com/estools/estraverse/issues"
  },
  "dependencies": {},
  "description": "ECMAScript JS AST traversal functions",
  "devDependencies": {
    "babel-preset-es2015": "^6.3.13",
    "babel-register": "^6.3.13",
    "chai": "^2.1.1",
    "espree": "^1.11.0",
    "gulp": "^3.8.10",
    "gulp-bump": "^0.2.2",
    "gulp-filter": "^2.0.0",
    "gulp-git": "^1.0.1",
    "gulp-tag-version": "^1.2.1",
    "jshint": "^2.5.6",
    "mocha": "^2.1.0"
  },
  "directories": {},
  "dist": {
    "shasum": "0dee3fed31fcd469618ce7342099fc1afa0bdb13",
    "tarball": "https://registry.npmjs.org/estraverse/-/estraverse-4.2.0.tgz"
  },
  "engines": {
    "node": ">=0.10.0"
  },
  "gitHead": "6f6a4e99653908e859c7c10d04d9518bf4844ede",
  "homepage": "https://github.com/estools/estraverse",
  "license": "BSD-2-Clause",
  "main": "estraverse.js",
  "maintainers": [
    {
      "email": "utatane.tea@gmail.com",
      "name": "constellation"
    },
    {
      "email": "npm@michael.ficarra.me",
      "name": "michaelficarra"
    },
    {
      "email": "nicholas@nczconsulting.com",
      "name": "nzakas"
    }
  ],
  "name": "estraverse",
  "optionalDependencies": {},
  "readme": "ERROR: No README data found!",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/estools/estraverse.git"
  },
  "scripts": {
    "lint": "jshint estraverse.js",
    "test": "npm run-script lint && npm run-script unit-test",
    "unit-test": "mocha --compilers js:babel-register"
  },
  "version": "4.2.0"
}

},{}],20:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    function isExpression(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'ArrayExpression':
            case 'AssignmentExpression':
            case 'BinaryExpression':
            case 'CallExpression':
            case 'ConditionalExpression':
            case 'FunctionExpression':
            case 'Identifier':
            case 'Literal':
            case 'LogicalExpression':
            case 'MemberExpression':
            case 'NewExpression':
            case 'ObjectExpression':
            case 'SequenceExpression':
            case 'ThisExpression':
            case 'UnaryExpression':
            case 'UpdateExpression':
                return true;
        }
        return false;
    }

    function isIterationStatement(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'DoWhileStatement':
            case 'ForInStatement':
            case 'ForStatement':
            case 'WhileStatement':
                return true;
        }
        return false;
    }

    function isStatement(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'BlockStatement':
            case 'BreakStatement':
            case 'ContinueStatement':
            case 'DebuggerStatement':
            case 'DoWhileStatement':
            case 'EmptyStatement':
            case 'ExpressionStatement':
            case 'ForInStatement':
            case 'ForStatement':
            case 'IfStatement':
            case 'LabeledStatement':
            case 'ReturnStatement':
            case 'SwitchStatement':
            case 'ThrowStatement':
            case 'TryStatement':
            case 'VariableDeclaration':
            case 'WhileStatement':
            case 'WithStatement':
                return true;
        }
        return false;
    }

    function isSourceElement(node) {
      return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
    }

    function trailingStatement(node) {
        switch (node.type) {
        case 'IfStatement':
            if (node.alternate != null) {
                return node.alternate;
            }
            return node.consequent;

        case 'LabeledStatement':
        case 'ForStatement':
        case 'ForInStatement':
        case 'WhileStatement':
        case 'WithStatement':
            return node.body;
        }
        return null;
    }

    function isProblematicIfStatement(node) {
        var current;

        if (node.type !== 'IfStatement') {
            return false;
        }
        if (node.alternate == null) {
            return false;
        }
        current = node.consequent;
        do {
            if (current.type === 'IfStatement') {
                if (current.alternate == null)  {
                    return true;
                }
            }
            current = trailingStatement(current);
        } while (current);

        return false;
    }

    module.exports = {
        isExpression: isExpression,
        isStatement: isStatement,
        isIterationStatement: isIterationStatement,
        isSourceElement: isSourceElement,
        isProblematicIfStatement: isProblematicIfStatement,

        trailingStatement: trailingStatement
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],21:[function(require,module,exports){
/*
  Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;

    // See `tools/generate-identifier-regex.js`.
    ES5Regex = {
        // ECMAScript 5.1/Unicode v7.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
        // ECMAScript 5.1/Unicode v7.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
    };

    ES6Regex = {
        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,
        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
    };

    function isDecimalDigit(ch) {
        return 0x30 <= ch && ch <= 0x39;  // 0..9
    }

    function isHexDigit(ch) {
        return 0x30 <= ch && ch <= 0x39 ||  // 0..9
            0x61 <= ch && ch <= 0x66 ||     // a..f
            0x41 <= ch && ch <= 0x46;       // A..F
    }

    function isOctalDigit(ch) {
        return ch >= 0x30 && ch <= 0x37;  // 0..7
    }

    // 7.2 White Space

    NON_ASCII_WHITESPACES = [
        0x1680, 0x180E,
        0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A,
        0x202F, 0x205F,
        0x3000,
        0xFEFF
    ];

    function isWhiteSpace(ch) {
        return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 ||
            ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
    }

    // 7.6 Identifier Names and Identifiers

    function fromCodePoint(cp) {
        if (cp <= 0xFFFF) { return String.fromCharCode(cp); }
        var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);
        var cu2 = String.fromCharCode(((cp - 0x10000) % 0x400) + 0xDC00);
        return cu1 + cu2;
    }

    IDENTIFIER_START = new Array(0x80);
    for(ch = 0; ch < 0x80; ++ch) {
        IDENTIFIER_START[ch] =
            ch >= 0x61 && ch <= 0x7A ||  // a..z
            ch >= 0x41 && ch <= 0x5A ||  // A..Z
            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
    }

    IDENTIFIER_PART = new Array(0x80);
    for(ch = 0; ch < 0x80; ++ch) {
        IDENTIFIER_PART[ch] =
            ch >= 0x61 && ch <= 0x7A ||  // a..z
            ch >= 0x41 && ch <= 0x5A ||  // A..Z
            ch >= 0x30 && ch <= 0x39 ||  // 0..9
            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
    }

    function isIdentifierStartES5(ch) {
        return ch < 0x80 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
    }

    function isIdentifierPartES5(ch) {
        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
    }

    function isIdentifierStartES6(ch) {
        return ch < 0x80 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
    }

    function isIdentifierPartES6(ch) {
        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
    }

    module.exports = {
        isDecimalDigit: isDecimalDigit,
        isHexDigit: isHexDigit,
        isOctalDigit: isOctalDigit,
        isWhiteSpace: isWhiteSpace,
        isLineTerminator: isLineTerminator,
        isIdentifierStartES5: isIdentifierStartES5,
        isIdentifierPartES5: isIdentifierPartES5,
        isIdentifierStartES6: isIdentifierStartES6,
        isIdentifierPartES6: isIdentifierPartES6
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],22:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var code = require('./code');

    function isStrictModeReservedWordES6(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isKeywordES5(id, strict) {
        // yield should not be treated as keyword under non-strict mode.
        if (!strict && id === 'yield') {
            return false;
        }
        return isKeywordES6(id, strict);
    }

    function isKeywordES6(id, strict) {
        if (strict && isStrictModeReservedWordES6(id)) {
            return true;
        }

        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    function isReservedWordES5(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
    }

    function isReservedWordES6(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    function isIdentifierNameES5(id) {
        var i, iz, ch;

        if (id.length === 0) { return false; }

        ch = id.charCodeAt(0);
        if (!code.isIdentifierStartES5(ch)) {
            return false;
        }

        for (i = 1, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (!code.isIdentifierPartES5(ch)) {
                return false;
            }
        }
        return true;
    }

    function decodeUtf16(lead, trail) {
        return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
    }

    function isIdentifierNameES6(id) {
        var i, iz, ch, lowCh, check;

        if (id.length === 0) { return false; }

        check = code.isIdentifierStartES6;
        for (i = 0, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (0xD800 <= ch && ch <= 0xDBFF) {
                ++i;
                if (i >= iz) { return false; }
                lowCh = id.charCodeAt(i);
                if (!(0xDC00 <= lowCh && lowCh <= 0xDFFF)) {
                    return false;
                }
                ch = decodeUtf16(ch, lowCh);
            }
            if (!check(ch)) {
                return false;
            }
            check = code.isIdentifierPartES6;
        }
        return true;
    }

    function isIdentifierES5(id, strict) {
        return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
    }

    function isIdentifierES6(id, strict) {
        return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
    }

    module.exports = {
        isKeywordES5: isKeywordES5,
        isKeywordES6: isKeywordES6,
        isReservedWordES5: isReservedWordES5,
        isReservedWordES6: isReservedWordES6,
        isRestrictedWord: isRestrictedWord,
        isIdentifierNameES5: isIdentifierNameES5,
        isIdentifierNameES6: isIdentifierNameES6,
        isIdentifierES5: isIdentifierES5,
        isIdentifierES6: isIdentifierES6
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{"./code":21}],23:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


(function () {
    'use strict';

    exports.ast = require('./ast');
    exports.code = require('./code');
    exports.keyword = require('./keyword');
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{"./ast":20,"./code":21,"./keyword":22}],24:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],25:[function(require,module,exports){
(function (global){
'use strict';
var Mutation = global.MutationObserver || global.WebKitMutationObserver;

var scheduleDrain;

{
  if (Mutation) {
    var called = 0;
    var observer = new Mutation(nextTick);
    var element = global.document.createTextNode('');
    observer.observe(element, {
      characterData: true
    });
    scheduleDrain = function () {
      element.data = (called = ++called % 2);
    };
  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
    var channel = new global.MessageChannel();
    channel.port1.onmessage = nextTick;
    scheduleDrain = function () {
      channel.port2.postMessage(0);
    };
  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
    scheduleDrain = function () {

      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var scriptEl = global.document.createElement('script');
      scriptEl.onreadystatechange = function () {
        nextTick();

        scriptEl.onreadystatechange = null;
        scriptEl.parentNode.removeChild(scriptEl);
        scriptEl = null;
      };
      global.document.documentElement.appendChild(scriptEl);
    };
  } else {
    scheduleDrain = function () {
      setTimeout(nextTick, 0);
    };
  }
}

var draining;
var queue = [];
//named nextTick for less confusing stack traces
function nextTick() {
  draining = true;
  var i, oldQueue;
  var len = queue.length;
  while (len) {
    oldQueue = queue;
    queue = [];
    i = -1;
    while (++i < len) {
      oldQueue[i]();
    }
    len = queue.length;
  }
  draining = false;
}

module.exports = immediate;
function immediate(task) {
  if (queue.push(task) === 1 && !draining) {
    scheduleDrain();
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],26:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],27:[function(require,module,exports){
'use strict';
var immediate = require('immediate');

/* istanbul ignore next */
function INTERNAL() {}

var handlers = {};

var REJECTED = ['REJECTED'];
var FULFILLED = ['FULFILLED'];
var PENDING = ['PENDING'];

module.exports = Promise;

function Promise(resolver) {
  if (typeof resolver !== 'function') {
    throw new TypeError('resolver must be a function');
  }
  this.state = PENDING;
  this.queue = [];
  this.outcome = void 0;
  if (resolver !== INTERNAL) {
    safelyResolveThenable(this, resolver);
  }
}

Promise.prototype["catch"] = function (onRejected) {
  return this.then(null, onRejected);
};
Promise.prototype.then = function (onFulfilled, onRejected) {
  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||
    typeof onRejected !== 'function' && this.state === REJECTED) {
    return this;
  }
  var promise = new this.constructor(INTERNAL);
  if (this.state !== PENDING) {
    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
    unwrap(promise, resolver, this.outcome);
  } else {
    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
  }

  return promise;
};
function QueueItem(promise, onFulfilled, onRejected) {
  this.promise = promise;
  if (typeof onFulfilled === 'function') {
    this.onFulfilled = onFulfilled;
    this.callFulfilled = this.otherCallFulfilled;
  }
  if (typeof onRejected === 'function') {
    this.onRejected = onRejected;
    this.callRejected = this.otherCallRejected;
  }
}
QueueItem.prototype.callFulfilled = function (value) {
  handlers.resolve(this.promise, value);
};
QueueItem.prototype.otherCallFulfilled = function (value) {
  unwrap(this.promise, this.onFulfilled, value);
};
QueueItem.prototype.callRejected = function (value) {
  handlers.reject(this.promise, value);
};
QueueItem.prototype.otherCallRejected = function (value) {
  unwrap(this.promise, this.onRejected, value);
};

function unwrap(promise, func, value) {
  immediate(function () {
    var returnValue;
    try {
      returnValue = func(value);
    } catch (e) {
      return handlers.reject(promise, e);
    }
    if (returnValue === promise) {
      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
    } else {
      handlers.resolve(promise, returnValue);
    }
  });
}

handlers.resolve = function (self, value) {
  var result = tryCatch(getThen, value);
  if (result.status === 'error') {
    return handlers.reject(self, result.value);
  }
  var thenable = result.value;

  if (thenable) {
    safelyResolveThenable(self, thenable);
  } else {
    self.state = FULFILLED;
    self.outcome = value;
    var i = -1;
    var len = self.queue.length;
    while (++i < len) {
      self.queue[i].callFulfilled(value);
    }
  }
  return self;
};
handlers.reject = function (self, error) {
  self.state = REJECTED;
  self.outcome = error;
  var i = -1;
  var len = self.queue.length;
  while (++i < len) {
    self.queue[i].callRejected(error);
  }
  return self;
};

function getThen(obj) {
  // Make sure we only access the accessor once as required by the spec
  var then = obj && obj.then;
  if (obj && typeof obj === 'object' && typeof then === 'function') {
    return function appyThen() {
      then.apply(obj, arguments);
    };
  }
}

function safelyResolveThenable(self, thenable) {
  // Either fulfill, reject or reject with error
  var called = false;
  function onError(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.reject(self, value);
  }

  function onSuccess(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.resolve(self, value);
  }

  function tryToUnwrap() {
    thenable(onSuccess, onError);
  }

  var result = tryCatch(tryToUnwrap);
  if (result.status === 'error') {
    onError(result.value);
  }
}

function tryCatch(func, value) {
  var out = {};
  try {
    out.value = func(value);
    out.status = 'success';
  } catch (e) {
    out.status = 'error';
    out.value = e;
  }
  return out;
}

Promise.resolve = resolve;
function resolve(value) {
  if (value instanceof this) {
    return value;
  }
  return handlers.resolve(new this(INTERNAL), value);
}

Promise.reject = reject;
function reject(reason) {
  var promise = new this(INTERNAL);
  return handlers.reject(promise, reason);
}

Promise.all = all;
function all(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var values = new Array(len);
  var resolved = 0;
  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    allResolver(iterable[i], i);
  }
  return promise;
  function allResolver(value, i) {
    self.resolve(value).then(resolveFromAll, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
    function resolveFromAll(outValue) {
      values[i] = outValue;
      if (++resolved === len && !called) {
        called = true;
        handlers.resolve(promise, values);
      }
    }
  }
}

Promise.race = race;
function race(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    resolver(iterable[i]);
  }
  return promise;
  function resolver(value) {
    self.resolve(value).then(function (response) {
      if (!called) {
        called = true;
        handlers.resolve(promise, response);
      }
    }, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
  }
}

},{"immediate":25}],28:[function(require,module,exports){
/*
 * Microdash - Tiny utilities for Node and the browser
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/asmblah/microdash
 *
 * Released under the MIT license
 * https://github.com/asmblah/microdash/raw/master/MIT-LICENSE.txt
 */

'use strict';

var each = require('./src/each'),
    escapeRegExp = require('./src/escapeRegExp'),
    extend = require('./src/extend'),
    filter = require('./src/filter'),
    forOwn = require('./src/forOwn'),
    isArray = require('./src/isArray'),
    isBoolean = require('./src/isBoolean'),
    isFunction = require('./src/isFunction'),
    isNumber = require('./src/isNumber'),
    isPlainObject = require('./src/isPlainObject'),
    isString = require('./src/isString'),
    map = require('./src/map');

module.exports = {
    each: each,
    escapeRegExp: escapeRegExp,
    extend: extend,
    filter: filter,
    forOwn: forOwn,
    isArray: isArray,
    isBoolean: isBoolean,
    isFunction: isFunction,
    isNumber: isNumber,
    isPlainObject: isPlainObject,
    isString: isString,
    map: map
};

},{"./src/each":29,"./src/escapeRegExp":30,"./src/extend":31,"./src/filter":32,"./src/forOwn":33,"./src/isArray":35,"./src/isBoolean":36,"./src/isFunction":37,"./src/isNumber":38,"./src/isPlainObject":39,"./src/isString":40,"./src/map":41}],29:[function(require,module,exports){
/*
 * Microdash - Tiny utilities for Node and the browser
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/asmblah/microdash
 *
 * Released under the MIT license
 * https://github.com/asmblah/microdash/raw/master/MIT-LICENSE.txt
 */

'use strict';

var hasOwn = {}.hasOwnProperty,
    isArray = require('./isArray');

module.exports = function (object, iterator, thisArg) {
    var key,
        length;

    if (!object) {
        return;
    }

    if (isArray(object) || hasOwn.call(object, 'length')) {
        for (key = 0, length = object.length; key < length; key++) {
            if (iterator.call(thisArg, object[key], key, object) === false) {
                break;
            }
        }

        return;
    }

    /*jshint forin: false */
    for (key in object) {
        if (hasOwn.call(object, key)) {
            if (iterator.call(thisArg, object[key], key, object) === false) {
                break;
            }
        }
    }
};

},{"./isArray":35}],30:[function(require,module,exports){
'use strict';

var REGEX = /[|\\{}()[\]^$+*?.]/g;

// From https://github.com/sindresorhus/escape-string-regexp/blob/master/index.js
module.exports = function (string) {
    if (typeof string !== 'string') {
        throw new TypeError('Expected a string');
    }

    return string.replace(REGEX,  '\\$&');
};

},{}],31:[function(require,module,exports){
/*
 * Microdash - Tiny utilities for Node and the browser
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/asmblah/microdash
 *
 * Released under the MIT license
 * https://github.com/asmblah/microdash/raw/master/MIT-LICENSE.txt
 */

'use strict';

var each = require('./each'),
    forOwn = require('./forOwn');

module.exports = function (object) {
    var sources = [].slice.call(arguments, 1);

    each(sources, function (source) {
        forOwn(source, function (value, key) {
            object[key] = value;
        });
    });

    return object;
};

},{"./each":29,"./forOwn":33}],32:[function(require,module,exports){
/*
 * Microdash - Tiny utilities for Node and the browser
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/asmblah/microdash
 *
 * Released under the MIT license
 * https://github.com/asmblah/microdash/raw/master/MIT-LICENSE.txt
 */

'use strict';

var each = require('./each');

module.exports = function (collection, iteratee, thisArg) {
    var result = [];

    each(collection, function (value, key) {
        if (iteratee.call(thisArg, value, key, collection)) {
            result.push(value);
        }
    });

    return result;
};

},{"./each":29}],33:[function(require,module,exports){
/*
 * Microdash - Tiny utilities for Node and the browser
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/asmblah/microdash
 *
 * Released under the MIT license
 * https://github.com/asmblah/microdash/raw/master/MIT-LICENSE.txt
 */

'use strict';

var hasOwn = {}.hasOwnProperty;

module.exports = function (object, iterator, thisArg) {
    var key;

    /*jshint forin: false */
    for (key in object) {
        if (hasOwn.call(object, key)) {
            if (iterator.call(thisArg, object[key], key, object) === false) {
                break;
            }
        }
    }
};

},{}],34:[function(require,module,exports){
/*
 * Microdash - Tiny utilities for Node and the browser
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/asmblah/microdash
 *
 * Released under the MIT license
 * https://github.com/asmblah/microdash/raw/master/MIT-LICENSE.txt
 */

'use strict';

var REGEX = /\[object ([^\]]+)\]/;

module.exports = function (object) {
    return {}.toString.call(object).match(REGEX)[1];
};

},{}],35:[function(require,module,exports){
/*
 * Microdash - Tiny utilities for Node and the browser
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/asmblah/microdash
 *
 * Released under the MIT license
 * https://github.com/asmblah/microdash/raw/master/MIT-LICENSE.txt
 */

'use strict';

var getType = require('./getType');

module.exports = function (object) {
    return getType(object) === 'Array';
};

},{"./getType":34}],36:[function(require,module,exports){
/*
 * Microdash - Tiny utilities for Node and the browser
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/asmblah/microdash
 *
 * Released under the MIT license
 * https://github.com/asmblah/microdash/raw/master/MIT-LICENSE.txt
 */

'use strict';

var getType = require('./getType');

module.exports = function (object) {
    return getType(object) === 'Boolean';
};

},{"./getType":34}],37:[function(require,module,exports){
/*
 * Microdash - Tiny utilities for Node and the browser
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/asmblah/microdash
 *
 * Released under the MIT license
 * https://github.com/asmblah/microdash/raw/master/MIT-LICENSE.txt
 */

'use strict';

var getType = require('./getType');

module.exports = function (object) {
    return getType(object) === 'Function';
};

},{"./getType":34}],38:[function(require,module,exports){
/*
 * Microdash - Tiny utilities for Node and the browser
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/asmblah/microdash
 *
 * Released under the MIT license
 * https://github.com/asmblah/microdash/raw/master/MIT-LICENSE.txt
 */

'use strict';

var getType = require('./getType');

module.exports = function (object) {
    return getType(object) === 'Number';
};

},{"./getType":34}],39:[function(require,module,exports){
/*
 * Microdash - Tiny utilities for Node and the browser
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/asmblah/microdash
 *
 * Released under the MIT license
 * https://github.com/asmblah/microdash/raw/master/MIT-LICENSE.txt
 */

'use strict';

var getType = require('./getType');

module.exports = function (object) {
    return getType(object) === 'Object';
};

},{"./getType":34}],40:[function(require,module,exports){
/*
 * Microdash - Tiny utilities for Node and the browser
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/asmblah/microdash
 *
 * Released under the MIT license
 * https://github.com/asmblah/microdash/raw/master/MIT-LICENSE.txt
 */

'use strict';

var getType = require('./getType');

module.exports = function (object) {
    return getType(object) === 'String';
};

},{"./getType":34}],41:[function(require,module,exports){
/*
 * Microdash - Tiny utilities for Node and the browser
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/asmblah/microdash
 *
 * Released under the MIT license
 * https://github.com/asmblah/microdash/raw/master/MIT-LICENSE.txt
 */

'use strict';

var each = require('./each');

module.exports = function (collection, iteratee, thisArg) {
    var result = [];

    each(collection, function (value, key) {
        result[key] = iteratee.call(thisArg, value, key, collection);
    });

    return result;
};

},{"./each":29}],42:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))
},{"_process":169}],43:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var Resumable = require('./src/Resumable'),
    Transpiler = require('./src/Transpiler');

module.exports = new Resumable(new Transpiler());

},{"./src/Resumable":63,"./src/Transpiler":84}],44:[function(require,module,exports){
(function (global){
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.acorn = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
// A recursive descent parser operates by defining functions for all
// syntactic elements, and recursively calling those, each function
// advancing the input stream and returning an AST node. Precedence
// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
// instead of `(!x)[1]` is handled by the fact that the parser
// function that parses unary prefix operators is called first, and
// in turn calls the function that parses `[]` subscripts  that
// way, it'll receive the node for `x[1]` already parsed, and wraps
// *that* in the unary operator node.
//
// Acorn uses an [operator precedence parser][opp] to handle binary
// operator precedence, because it is much more compact than using
// the technique outlined above, which uses different, nesting
// functions to specify precedence, for all of the ten binary
// precedence levels that JavaScript defines.
//
// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser

"use strict";

var _tokentype = _dereq_("./tokentype");

var _state = _dereq_("./state");

var pp = _state.Parser.prototype;

// Check if property name clashes with already added.
// Object/class getters and setters are not allowed to clash 
// either with each other or with an init property  and in
// strict mode, init properties are also not allowed to be repeated.

pp.checkPropClash = function (prop, propHash) {
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) return;
  var key = prop.key;var name = undefined;
  switch (key.type) {
    case "Identifier":
      name = key.name;break;
    case "Literal":
      name = String(key.value);break;
    default:
      return;
  }
  var kind = prop.kind;

  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) this.raise(key.start, "Redefinition of __proto__ property");
      propHash.proto = true;
    }
    return;
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
    var isGetSet = kind !== "init";
    if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init)) this.raise(key.start, "Redefinition of property");
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};

// ### Expression parsing

// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function(s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.

// Parse a full expression. The optional arguments are used to
// forbid the `in` operator (in for loops initalization expressions)
// and provide reference for storing '=' operator inside shorthand
// property assignment in contexts where both object expression
// and object pattern might appear (so it's possible to raise
// delayed syntax error at correct position).

pp.parseExpression = function (noIn, refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
  if (this.type === _tokentype.types.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(_tokentype.types.comma)) node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors));
    return this.finishNode(node, "SequenceExpression");
  }
  return expr;
};

// Parse an assignment expression. This includes applications of
// operators like `+=`.

pp.parseMaybeAssign = function (noIn, refDestructuringErrors, afterLeftParse) {
  if (this.type == _tokentype.types._yield && this.inGenerator) return this.parseYield();

  var validateDestructuring = false;
  if (!refDestructuringErrors) {
    refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 };
    validateDestructuring = true;
  }
  var startPos = this.start,
      startLoc = this.startLoc;
  if (this.type == _tokentype.types.parenL || this.type == _tokentype.types.name) this.potentialArrowAt = this.start;
  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
  if (this.type.isAssign) {
    if (validateDestructuring) this.checkPatternErrors(refDestructuringErrors, true);
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    node.left = this.type === _tokentype.types.eq ? this.toAssignable(left) : left;
    refDestructuringErrors.shorthandAssign = 0; // reset because shorthand default was used correctly
    this.checkLVal(left);
    this.next();
    node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "AssignmentExpression");
  } else {
    if (validateDestructuring) this.checkExpressionErrors(refDestructuringErrors, true);
  }
  return left;
};

// Parse a ternary conditional (`?:`) operator.

pp.parseMaybeConditional = function (noIn, refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseExprOps(noIn, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
  if (this.eat(_tokentype.types.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(_tokentype.types.colon);
    node.alternate = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "ConditionalExpression");
  }
  return expr;
};

// Start the precedence parser.

pp.parseExprOps = function (noIn, refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
  return this.parseExprOp(expr, startPos, startLoc, -1, noIn);
};

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.

pp.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {
  var prec = this.type.binop;
  if (prec != null && (!noIn || this.type !== _tokentype.types._in)) {
    if (prec > minPrec) {
      var node = this.startNodeAt(leftStartPos, leftStartLoc);
      node.left = left;
      node.operator = this.value;
      var op = this.type;
      this.next();
      var startPos = this.start,
          startLoc = this.startLoc;
      node.right = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, prec, noIn);
      this.finishNode(node, op === _tokentype.types.logicalOR || op === _tokentype.types.logicalAND ? "LogicalExpression" : "BinaryExpression");
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
    }
  }
  return left;
};

// Parse unary operators, both prefix and postfix.

pp.parseMaybeUnary = function (refDestructuringErrors) {
  if (this.type.prefix) {
    var node = this.startNode(),
        update = this.type === _tokentype.types.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary();
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) this.checkLVal(node.argument);else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") this.raise(node.start, "Deleting local variable in strict mode");
    return this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  }
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseExprSubscripts(refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
  while (this.type.postfix && !this.canInsertSemicolon()) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    node.prefix = false;
    node.argument = expr;
    this.checkLVal(expr);
    this.next();
    expr = this.finishNode(node, "UpdateExpression");
  }
  return expr;
};

// Parse call, dot, and `[]`-subscript expressions.

pp.parseExprSubscripts = function (refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors);
  var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";
  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr;
  return this.parseSubscripts(expr, startPos, startLoc);
};

pp.parseSubscripts = function (base, startPos, startLoc, noCalls) {
  for (;;) {
    if (this.eat(_tokentype.types.dot)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = this.parseIdent(true);
      node.computed = false;
      base = this.finishNode(node, "MemberExpression");
    } else if (this.eat(_tokentype.types.bracketL)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = this.parseExpression();
      node.computed = true;
      this.expect(_tokentype.types.bracketR);
      base = this.finishNode(node, "MemberExpression");
    } else if (!noCalls && this.eat(_tokentype.types.parenL)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.callee = base;
      node.arguments = this.parseExprList(_tokentype.types.parenR, false);
      base = this.finishNode(node, "CallExpression");
    } else if (this.type === _tokentype.types.backQuote) {
      var node = this.startNodeAt(startPos, startLoc);
      node.tag = base;
      node.quasi = this.parseTemplate();
      base = this.finishNode(node, "TaggedTemplateExpression");
    } else {
      return base;
    }
  }
};

// Parse an atomic expression  either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.

pp.parseExprAtom = function (refDestructuringErrors) {
  var node = undefined,
      canBeArrow = this.potentialArrowAt == this.start;
  switch (this.type) {
    case _tokentype.types._super:
      if (!this.inFunction) this.raise(this.start, "'super' outside of function or class");
    case _tokentype.types._this:
      var type = this.type === _tokentype.types._this ? "ThisExpression" : "Super";
      node = this.startNode();
      this.next();
      return this.finishNode(node, type);

    case _tokentype.types._yield:
      if (this.inGenerator) this.unexpected();

    case _tokentype.types.name:
      var startPos = this.start,
          startLoc = this.startLoc;
      var id = this.parseIdent(this.type !== _tokentype.types.name);
      if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokentype.types.arrow)) return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id]);
      return id;

    case _tokentype.types.regexp:
      var value = this.value;
      node = this.parseLiteral(value.value);
      node.regex = { pattern: value.pattern, flags: value.flags };
      return node;

    case _tokentype.types.num:case _tokentype.types.string:
      return this.parseLiteral(this.value);

    case _tokentype.types._null:case _tokentype.types._true:case _tokentype.types._false:
      node = this.startNode();
      node.value = this.type === _tokentype.types._null ? null : this.type === _tokentype.types._true;
      node.raw = this.type.keyword;
      this.next();
      return this.finishNode(node, "Literal");

    case _tokentype.types.parenL:
      return this.parseParenAndDistinguishExpression(canBeArrow);

    case _tokentype.types.bracketL:
      node = this.startNode();
      this.next();
      // check whether this is array comprehension or regular array
      if (this.options.ecmaVersion >= 7 && this.type === _tokentype.types._for) {
        return this.parseComprehension(node, false);
      }
      node.elements = this.parseExprList(_tokentype.types.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node, "ArrayExpression");

    case _tokentype.types.braceL:
      return this.parseObj(false, refDestructuringErrors);

    case _tokentype.types._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, false);

    case _tokentype.types._class:
      return this.parseClass(this.startNode(), false);

    case _tokentype.types._new:
      return this.parseNew();

    case _tokentype.types.backQuote:
      return this.parseTemplate();

    default:
      this.unexpected();
  }
};

pp.parseLiteral = function (value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  this.next();
  return this.finishNode(node, "Literal");
};

pp.parseParenExpression = function () {
  this.expect(_tokentype.types.parenL);
  var val = this.parseExpression();
  this.expect(_tokentype.types.parenR);
  return val;
};

pp.parseParenAndDistinguishExpression = function (canBeArrow) {
  var startPos = this.start,
      startLoc = this.startLoc,
      val = undefined;
  if (this.options.ecmaVersion >= 6) {
    this.next();

    if (this.options.ecmaVersion >= 7 && this.type === _tokentype.types._for) {
      return this.parseComprehension(this.startNodeAt(startPos, startLoc), true);
    }

    var innerStartPos = this.start,
        innerStartLoc = this.startLoc;
    var exprList = [],
        first = true;
    var refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 },
        spreadStart = undefined,
        innerParenStart = undefined;
    while (this.type !== _tokentype.types.parenR) {
      first ? first = false : this.expect(_tokentype.types.comma);
      if (this.type === _tokentype.types.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRest()));
        break;
      } else {
        if (this.type === _tokentype.types.parenL && !innerParenStart) {
          innerParenStart = this.start;
        }
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.start,
        innerEndLoc = this.startLoc;
    this.expect(_tokentype.types.parenR);

    if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokentype.types.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, true);
      if (innerParenStart) this.unexpected(innerParenStart);
      return this.parseParenArrowList(startPos, startLoc, exprList);
    }

    if (!exprList.length) this.unexpected(this.lastTokStart);
    if (spreadStart) this.unexpected(spreadStart);
    this.checkExpressionErrors(refDestructuringErrors, true);

    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }

  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression");
  } else {
    return val;
  }
};

pp.parseParenItem = function (item) {
  return item;
};

pp.parseParenArrowList = function (startPos, startLoc, exprList) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);
};

// New's precedence is slightly tricky. It must allow its argument to
// be a `[]` or dot subscript expression, but not a call  at least,
// not without wrapping it in parentheses. Thus, it uses the noCalls
// argument to parseSubscripts to prevent it from consuming the
// argument list.

var empty = [];

pp.parseNew = function () {
  var node = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(_tokentype.types.dot)) {
    node.meta = meta;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target") this.raise(node.property.start, "The only valid meta property for new is new.target");
    if (!this.inFunction) this.raise(node.start, "new.target can only be used in functions");
    return this.finishNode(node, "MetaProperty");
  }
  var startPos = this.start,
      startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
  if (this.eat(_tokentype.types.parenL)) node.arguments = this.parseExprList(_tokentype.types.parenR, false);else node.arguments = empty;
  return this.finishNode(node, "NewExpression");
};

// Parse template expression.

pp.parseTemplateElement = function () {
  var elem = this.startNode();
  elem.value = {
    raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, '\n'),
    cooked: this.value
  };
  this.next();
  elem.tail = this.type === _tokentype.types.backQuote;
  return this.finishNode(elem, "TemplateElement");
};

pp.parseTemplate = function () {
  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement();
  node.quasis = [curElt];
  while (!curElt.tail) {
    this.expect(_tokentype.types.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(_tokentype.types.braceR);
    node.quasis.push(curElt = this.parseTemplateElement());
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral");
};

// Parse an object literal or binding pattern.

pp.parseObj = function (isPattern, refDestructuringErrors) {
  var node = this.startNode(),
      first = true,
      propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(_tokentype.types.braceR)) {
    if (!first) {
      this.expect(_tokentype.types.comma);
      if (this.afterTrailingComma(_tokentype.types.braceR)) break;
    } else first = false;

    var prop = this.startNode(),
        isGenerator = undefined,
        startPos = undefined,
        startLoc = undefined;
    if (this.options.ecmaVersion >= 6) {
      prop.method = false;
      prop.shorthand = false;
      if (isPattern || refDestructuringErrors) {
        startPos = this.start;
        startLoc = this.startLoc;
      }
      if (!isPattern) isGenerator = this.eat(_tokentype.types.star);
    }
    this.parsePropertyName(prop);
    this.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors);
    this.checkPropClash(prop, propHash);
    node.properties.push(this.finishNode(prop, "Property"));
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};

pp.parsePropertyValue = function (prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors) {
  if (this.eat(_tokentype.types.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === _tokentype.types.parenL) {
    if (isPattern) this.unexpected();
    prop.kind = "init";
    prop.method = true;
    prop.value = this.parseMethod(isGenerator);
  } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type != _tokentype.types.comma && this.type != _tokentype.types.braceR)) {
    if (isGenerator || isPattern) this.unexpected();
    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    prop.value = this.parseMethod(false);
    var paramCount = prop.kind === "get" ? 0 : 1;
    if (prop.value.params.length !== paramCount) {
      var start = prop.value.start;
      if (prop.kind === "get") this.raise(start, "getter should have no params");else this.raise(start, "setter should have exactly one param");
    }
    if (prop.kind === "set" && prop.value.params[0].type === "RestElement") this.raise(prop.value.params[0].start, "Setter cannot use rest params");
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    prop.kind = "init";
    if (isPattern) {
      if (this.keywords.test(prop.key.name) || (this.strict ? this.reservedWordsStrictBind : this.reservedWords).test(prop.key.name)) this.raise(prop.key.start, "Binding " + prop.key.name);
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else if (this.type === _tokentype.types.eq && refDestructuringErrors) {
      if (!refDestructuringErrors.shorthandAssign) refDestructuringErrors.shorthandAssign = this.start;
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else {
      prop.value = prop.key;
    }
    prop.shorthand = true;
  } else this.unexpected();
};

pp.parsePropertyName = function (prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(_tokentype.types.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(_tokentype.types.bracketR);
      return prop.key;
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === _tokentype.types.num || this.type === _tokentype.types.string ? this.parseExprAtom() : this.parseIdent(true);
};

// Initialize empty function node.

pp.initFunction = function (node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) {
    node.generator = false;
    node.expression = false;
  }
};

// Parse object or class method.

pp.parseMethod = function (isGenerator) {
  var node = this.startNode();
  this.initFunction(node);
  this.expect(_tokentype.types.parenL);
  node.params = this.parseBindingList(_tokentype.types.parenR, false, false);
  if (this.options.ecmaVersion >= 6) node.generator = isGenerator;
  this.parseFunctionBody(node, false);
  return this.finishNode(node, "FunctionExpression");
};

// Parse arrow function expression with given parameters.

pp.parseArrowExpression = function (node, params) {
  this.initFunction(node);
  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true);
  return this.finishNode(node, "ArrowFunctionExpression");
};

// Parse function body and check parameters.

pp.parseFunctionBody = function (node, isArrowFunction) {
  var isExpression = isArrowFunction && this.type !== _tokentype.types.braceL;

  if (isExpression) {
    node.body = this.parseMaybeAssign();
    node.expression = true;
  } else {
    // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).
    var oldInFunc = this.inFunction,
        oldInGen = this.inGenerator,
        oldLabels = this.labels;
    this.inFunction = true;this.inGenerator = node.generator;this.labels = [];
    node.body = this.parseBlock(true);
    node.expression = false;
    this.inFunction = oldInFunc;this.inGenerator = oldInGen;this.labels = oldLabels;
  }

  // If this is a strict mode function, verify that argument names
  // are not repeated, and it does not try to bind the words `eval`
  // or `arguments`.
  if (this.strict || !isExpression && node.body.body.length && this.isUseStrict(node.body.body[0])) {
    var oldStrict = this.strict;
    this.strict = true;
    if (node.id) this.checkLVal(node.id, true);
    this.checkParams(node);
    this.strict = oldStrict;
  } else if (isArrowFunction) {
    this.checkParams(node);
  }
};

// Checks function params for various disallowed patterns such as using "eval"
// or "arguments" and duplicate parameters.

pp.checkParams = function (node) {
  var nameHash = {};
  for (var i = 0; i < node.params.length; i++) {
    this.checkLVal(node.params[i], true, nameHash);
  }
};

// Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).

pp.parseExprList = function (close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [],
      first = true;
  while (!this.eat(close)) {
    if (!first) {
      this.expect(_tokentype.types.comma);
      if (this.type === close && refDestructuringErrors && !refDestructuringErrors.trailingComma) {
        refDestructuringErrors.trailingComma = this.lastTokStart;
      }
      if (allowTrailingComma && this.afterTrailingComma(close)) break;
    } else first = false;

    var elt = undefined;
    if (allowEmpty && this.type === _tokentype.types.comma) elt = null;else if (this.type === _tokentype.types.ellipsis) elt = this.parseSpread(refDestructuringErrors);else elt = this.parseMaybeAssign(false, refDestructuringErrors);
    elts.push(elt);
  }
  return elts;
};

// Parse the next token as an identifier. If `liberal` is true (used
// when parsing properties), it will also convert keywords into
// identifiers.

pp.parseIdent = function (liberal) {
  var node = this.startNode();
  if (liberal && this.options.allowReserved == "never") liberal = false;
  if (this.type === _tokentype.types.name) {
    if (!liberal && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) && (this.options.ecmaVersion >= 6 || this.input.slice(this.start, this.end).indexOf("\\") == -1)) this.raise(this.start, "The keyword '" + this.value + "' is reserved");
    node.name = this.value;
  } else if (liberal && this.type.keyword) {
    node.name = this.type.keyword;
  } else {
    this.unexpected();
  }
  this.next();
  return this.finishNode(node, "Identifier");
};

// Parses yield expression inside generator.

pp.parseYield = function () {
  var node = this.startNode();
  this.next();
  if (this.type == _tokentype.types.semi || this.canInsertSemicolon() || this.type != _tokentype.types.star && !this.type.startsExpr) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(_tokentype.types.star);
    node.argument = this.parseMaybeAssign();
  }
  return this.finishNode(node, "YieldExpression");
};

// Parses array and generator comprehensions.

pp.parseComprehension = function (node, isGenerator) {
  node.blocks = [];
  while (this.type === _tokentype.types._for) {
    var block = this.startNode();
    this.next();
    this.expect(_tokentype.types.parenL);
    block.left = this.parseBindingAtom();
    this.checkLVal(block.left, true);
    this.expectContextual("of");
    block.right = this.parseExpression();
    this.expect(_tokentype.types.parenR);
    node.blocks.push(this.finishNode(block, "ComprehensionBlock"));
  }
  node.filter = this.eat(_tokentype.types._if) ? this.parseParenExpression() : null;
  node.body = this.parseExpression();
  this.expect(isGenerator ? _tokentype.types.parenR : _tokentype.types.bracketR);
  node.generator = isGenerator;
  return this.finishNode(node, "ComprehensionExpression");
};

},{"./state":10,"./tokentype":14}],2:[function(_dereq_,module,exports){
// This is a trick taken from Esprima. It turns out that, on
// non-Chrome browsers, to check whether a string is in a set, a
// predicate containing a big ugly `switch` statement is faster than
// a regular expression, and on Chrome the two are about on par.
// This function uses `eval` (non-lexical) to produce such a
// predicate from a space-separated string of words.
//
// It starts by sorting the words by length.

// Reserved word lists for various dialects of the language

"use strict";

exports.__esModule = true;
exports.isIdentifierStart = isIdentifierStart;
exports.isIdentifierChar = isIdentifierChar;
var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};

exports.reservedWords = reservedWords;
// And the keywords

var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

var keywords = {
  5: ecma5AndLessKeywords,
  6: ecma5AndLessKeywords + " let const class extends export import yield super"
};

exports.keywords = keywords;
// ## Character categories

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.
// Generated by `bin/generate-identifier-regex.js`.

var nonASCIIidentifierStartChars = "-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------";
var nonASCIIidentifierChars = "-------------------------------------------------------------------------------------------------------------------------------------------------";

var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;

// These are a run-length and offset encoded representation of the
// >0xffff code points that are a valid part of identifiers. The
// offset starts at 0x10000, and each pair of numbers represents an
// offset to the next range, and then a size of the range. They were
// generated by tools/generate-identifier-regex.js
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 17, 26, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 99, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 98, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 955, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 38, 17, 2, 24, 133, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 32, 4, 287, 47, 21, 1, 2, 0, 185, 46, 82, 47, 21, 0, 60, 42, 502, 63, 32, 0, 449, 56, 1288, 920, 104, 110, 2962, 1070, 13266, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 16481, 1, 3071, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 1340, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 16355, 541];
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 16, 9, 83, 11, 168, 11, 6, 9, 8, 2, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 316, 19, 13, 9, 214, 6, 3, 8, 112, 16, 16, 9, 82, 12, 9, 9, 535, 9, 20855, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 4305, 6, 792618, 239];

// This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.
function isInAstralSet(code, set) {
  var pos = 0x10000;
  for (var i = 0; i < set.length; i += 2) {
    pos += set[i];
    if (pos > code) return false;
    pos += set[i + 1];
    if (pos >= code) return true;
  }
}

// Test whether a given character code starts an identifier.

function isIdentifierStart(code, astral) {
  if (code < 65) return code === 36;
  if (code < 91) return true;
  if (code < 97) return code === 95;
  if (code < 123) return true;
  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
  if (astral === false) return false;
  return isInAstralSet(code, astralIdentifierStartCodes);
}

// Test whether a given character is part of an identifier.

function isIdentifierChar(code, astral) {
  if (code < 48) return code === 36;
  if (code < 58) return true;
  if (code < 65) return false;
  if (code < 91) return true;
  if (code < 97) return code === 95;
  if (code < 123) return true;
  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
  if (astral === false) return false;
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}

},{}],3:[function(_dereq_,module,exports){
// Acorn is a tiny, fast JavaScript parser written in JavaScript.
//
// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
// various contributors and released under an MIT license.
//
// Git repositories for Acorn are available at
//
//     http://marijnhaverbeke.nl/git/acorn
//     https://github.com/ternjs/acorn.git
//
// Please use the [github bug tracker][ghbt] to report issues.
//
// [ghbt]: https://github.com/ternjs/acorn/issues
//
// This file defines the main parser interface. The library also comes
// with a [error-tolerant parser][dammit] and an
// [abstract syntax tree walker][walk], defined in other files.
//
// [dammit]: acorn_loose.js
// [walk]: util/walk.js

"use strict";

exports.__esModule = true;
exports.parse = parse;
exports.parseExpressionAt = parseExpressionAt;
exports.tokenizer = tokenizer;

var _state = _dereq_("./state");

_dereq_("./parseutil");

_dereq_("./statement");

_dereq_("./lval");

_dereq_("./expression");

_dereq_("./location");

exports.Parser = _state.Parser;
exports.plugins = _state.plugins;

var _options = _dereq_("./options");

exports.defaultOptions = _options.defaultOptions;

var _locutil = _dereq_("./locutil");

exports.Position = _locutil.Position;
exports.SourceLocation = _locutil.SourceLocation;
exports.getLineInfo = _locutil.getLineInfo;

var _node = _dereq_("./node");

exports.Node = _node.Node;

var _tokentype = _dereq_("./tokentype");

exports.TokenType = _tokentype.TokenType;
exports.tokTypes = _tokentype.types;

var _tokencontext = _dereq_("./tokencontext");

exports.TokContext = _tokencontext.TokContext;
exports.tokContexts = _tokencontext.types;

var _identifier = _dereq_("./identifier");

exports.isIdentifierChar = _identifier.isIdentifierChar;
exports.isIdentifierStart = _identifier.isIdentifierStart;

var _tokenize = _dereq_("./tokenize");

exports.Token = _tokenize.Token;

var _whitespace = _dereq_("./whitespace");

exports.isNewLine = _whitespace.isNewLine;
exports.lineBreak = _whitespace.lineBreak;
exports.lineBreakG = _whitespace.lineBreakG;
var version = "2.7.0";

exports.version = version;
// The main exported interface (under `self.acorn` when in the
// browser) is a `parse` function that takes a code string and
// returns an abstract syntax tree as specified by [Mozilla parser
// API][api].
//
// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

function parse(input, options) {
  return new _state.Parser(options, input).parse();
}

// This function tries to parse a single expression at a given
// offset in a string. Useful for parsing mixed-language formats
// that embed JavaScript expressions.

function parseExpressionAt(input, pos, options) {
  var p = new _state.Parser(options, input, pos);
  p.nextToken();
  return p.parseExpression();
}

// Acorn is organized as a tokenizer and a recursive-descent parser.
// The `tokenizer` export provides an interface to the tokenizer.

function tokenizer(input, options) {
  return new _state.Parser(options, input);
}

},{"./expression":1,"./identifier":2,"./location":4,"./locutil":5,"./lval":6,"./node":7,"./options":8,"./parseutil":9,"./state":10,"./statement":11,"./tokencontext":12,"./tokenize":13,"./tokentype":14,"./whitespace":16}],4:[function(_dereq_,module,exports){
"use strict";

var _state = _dereq_("./state");

var _locutil = _dereq_("./locutil");

var pp = _state.Parser.prototype;

// This function is used to raise exceptions on parse errors. It
// takes an offset integer (into the current `input`) to indicate
// the location of the error, attaches the position to the end
// of the error message, and then raises a `SyntaxError` with that
// message.

pp.raise = function (pos, message) {
  var loc = _locutil.getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos;err.loc = loc;err.raisedAt = this.pos;
  throw err;
};

pp.curPosition = function () {
  if (this.options.locations) {
    return new _locutil.Position(this.curLine, this.pos - this.lineStart);
  }
};

},{"./locutil":5,"./state":10}],5:[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;
exports.getLineInfo = getLineInfo;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _whitespace = _dereq_("./whitespace");

// These are used when `options.locations` is on, for the
// `startLoc` and `endLoc` properties.

var Position = (function () {
  function Position(line, col) {
    _classCallCheck(this, Position);

    this.line = line;
    this.column = col;
  }

  Position.prototype.offset = function offset(n) {
    return new Position(this.line, this.column + n);
  };

  return Position;
})();

exports.Position = Position;

var SourceLocation = function SourceLocation(p, start, end) {
  _classCallCheck(this, SourceLocation);

  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) this.source = p.sourceFile;
}

// The `getLineInfo` function is mostly useful when the
// `locations` option is off (for performance reasons) and you
// want to find the line/column position for a given character
// offset. `input` should be the code string that the offset refers
// into.

;

exports.SourceLocation = SourceLocation;

function getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
    _whitespace.lineBreakG.lastIndex = cur;
    var match = _whitespace.lineBreakG.exec(input);
    if (match && match.index < offset) {
      ++line;
      cur = match.index + match[0].length;
    } else {
      return new Position(line, offset - cur);
    }
  }
}

},{"./whitespace":16}],6:[function(_dereq_,module,exports){
"use strict";

var _tokentype = _dereq_("./tokentype");

var _state = _dereq_("./state");

var _util = _dereq_("./util");

var pp = _state.Parser.prototype;

// Convert existing expression atom to assignable pattern
// if possible.

pp.toAssignable = function (node, isBinding) {
  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
        break;

      case "ObjectExpression":
        node.type = "ObjectPattern";
        for (var i = 0; i < node.properties.length; i++) {
          var prop = node.properties[i];
          if (prop.kind !== "init") this.raise(prop.key.start, "Object pattern can't contain getter or setter");
          this.toAssignable(prop.value, isBinding);
        }
        break;

      case "ArrayExpression":
        node.type = "ArrayPattern";
        this.toAssignableList(node.elements, isBinding);
        break;

      case "AssignmentExpression":
        if (node.operator === "=") {
          node.type = "AssignmentPattern";
          delete node.operator;
          // falls through to AssignmentPattern
        } else {
            this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
            break;
          }

      case "AssignmentPattern":
        if (node.right.type === "YieldExpression") this.raise(node.right.start, "Yield expression cannot be a default value");
        break;

      case "ParenthesizedExpression":
        node.expression = this.toAssignable(node.expression, isBinding);
        break;

      case "MemberExpression":
        if (!isBinding) break;

      default:
        this.raise(node.start, "Assigning to rvalue");
    }
  }
  return node;
};

// Convert list of expression atoms to binding list.

pp.toAssignableList = function (exprList, isBinding) {
  var end = exprList.length;
  if (end) {
    var last = exprList[end - 1];
    if (last && last.type == "RestElement") {
      --end;
    } else if (last && last.type == "SpreadElement") {
      last.type = "RestElement";
      var arg = last.argument;
      this.toAssignable(arg, isBinding);
      if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern") this.unexpected(arg.start);
      --end;
    }

    if (isBinding && last.type === "RestElement" && last.argument.type !== "Identifier") this.unexpected(last.argument.start);
  }
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) this.toAssignable(elt, isBinding);
  }
  return exprList;
};

// Parses spread element.

pp.parseSpread = function (refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(refDestructuringErrors);
  return this.finishNode(node, "SpreadElement");
};

pp.parseRest = function (allowNonIdent) {
  var node = this.startNode();
  this.next();

  // RestElement inside of a function parameter must be an identifier
  if (allowNonIdent) node.argument = this.type === _tokentype.types.name ? this.parseIdent() : this.unexpected();else node.argument = this.type === _tokentype.types.name || this.type === _tokentype.types.bracketL ? this.parseBindingAtom() : this.unexpected();

  return this.finishNode(node, "RestElement");
};

// Parses lvalue (assignable) atom.

pp.parseBindingAtom = function () {
  if (this.options.ecmaVersion < 6) return this.parseIdent();
  switch (this.type) {
    case _tokentype.types.name:
      return this.parseIdent();

    case _tokentype.types.bracketL:
      var node = this.startNode();
      this.next();
      node.elements = this.parseBindingList(_tokentype.types.bracketR, true, true);
      return this.finishNode(node, "ArrayPattern");

    case _tokentype.types.braceL:
      return this.parseObj(true);

    default:
      this.unexpected();
  }
};

pp.parseBindingList = function (close, allowEmpty, allowTrailingComma, allowNonIdent) {
  var elts = [],
      first = true;
  while (!this.eat(close)) {
    if (first) first = false;else this.expect(_tokentype.types.comma);
    if (allowEmpty && this.type === _tokentype.types.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
      break;
    } else if (this.type === _tokentype.types.ellipsis) {
      var rest = this.parseRest(allowNonIdent);
      this.parseBindingListItem(rest);
      elts.push(rest);
      this.expect(close);
      break;
    } else {
      var elem = this.parseMaybeDefault(this.start, this.startLoc);
      this.parseBindingListItem(elem);
      elts.push(elem);
    }
  }
  return elts;
};

pp.parseBindingListItem = function (param) {
  return param;
};

// Parses assignment pattern around given atom if possible.

pp.parseMaybeDefault = function (startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(_tokentype.types.eq)) return left;
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern");
};

// Verify that a node is an lval  something that can be assigned
// to.

pp.checkLVal = function (expr, isBinding, checkClashes) {
  switch (expr.type) {
    case "Identifier":
      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) this.raise(expr.start, (isBinding ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
      if (checkClashes) {
        if (_util.has(checkClashes, expr.name)) this.raise(expr.start, "Argument name clash");
        checkClashes[expr.name] = true;
      }
      break;

    case "MemberExpression":
      if (isBinding) this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " member expression");
      break;

    case "ObjectPattern":
      for (var i = 0; i < expr.properties.length; i++) {
        this.checkLVal(expr.properties[i].value, isBinding, checkClashes);
      }break;

    case "ArrayPattern":
      for (var i = 0; i < expr.elements.length; i++) {
        var elem = expr.elements[i];
        if (elem) this.checkLVal(elem, isBinding, checkClashes);
      }
      break;

    case "AssignmentPattern":
      this.checkLVal(expr.left, isBinding, checkClashes);
      break;

    case "RestElement":
      this.checkLVal(expr.argument, isBinding, checkClashes);
      break;

    case "ParenthesizedExpression":
      this.checkLVal(expr.expression, isBinding, checkClashes);
      break;

    default:
      this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " rvalue");
  }
};

},{"./state":10,"./tokentype":14,"./util":15}],7:[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _state = _dereq_("./state");

var _locutil = _dereq_("./locutil");

var Node = function Node(parser, pos, loc) {
  _classCallCheck(this, Node);

  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations) this.loc = new _locutil.SourceLocation(parser, loc);
  if (parser.options.directSourceFile) this.sourceFile = parser.options.directSourceFile;
  if (parser.options.ranges) this.range = [pos, 0];
}

// Start an AST node, attaching a start offset.

;

exports.Node = Node;
var pp = _state.Parser.prototype;

pp.startNode = function () {
  return new Node(this, this.start, this.startLoc);
};

pp.startNodeAt = function (pos, loc) {
  return new Node(this, pos, loc);
};

// Finish an AST node, adding `type` and `end` properties.

function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations) node.loc.end = loc;
  if (this.options.ranges) node.range[1] = pos;
  return node;
}

pp.finishNode = function (node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
};

// Finish node at given position

pp.finishNodeAt = function (node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc);
};

},{"./locutil":5,"./state":10}],8:[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;
exports.getOptions = getOptions;

var _util = _dereq_("./util");

var _locutil = _dereq_("./locutil");

// A second optional argument can be given to further configure
// the parser process. These options are recognized:

var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must
  // be either 3, or 5, or 6. This influences support for strict
  // mode, the set of reserved words, support for getters and
  // setters and other features.
  ecmaVersion: 5,
  // Source type ("script" or "module") for different semantics
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called
  // when a semicolon is automatically inserted. It will be passed
  // th position of the comma as an offset, and if `locations` is
  // enabled, it is given the location as a `{line, column}` object
  // as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program.
  allowImportExportEverywhere: false,
  // When enabled, hashbang directive in the beginning of file
  // is allowed and treated as a line comment.
  allowHashBang: false,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callbackthat will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callbackthat will corrupt its internal state.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false,
  plugins: {}
};

exports.defaultOptions = defaultOptions;
// Interpret and default an options object

function getOptions(opts) {
  var options = {};
  for (var opt in defaultOptions) {
    options[opt] = opts && _util.has(opts, opt) ? opts[opt] : defaultOptions[opt];
  }if (options.allowReserved == null) options.allowReserved = options.ecmaVersion < 5;

  if (_util.isArray(options.onToken)) {
    (function () {
      var tokens = options.onToken;
      options.onToken = function (token) {
        return tokens.push(token);
      };
    })();
  }
  if (_util.isArray(options.onComment)) options.onComment = pushComment(options, options.onComment);

  return options;
}

function pushComment(options, array) {
  return function (block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? 'Block' : 'Line',
      value: text,
      start: start,
      end: end
    };
    if (options.locations) comment.loc = new _locutil.SourceLocation(this, startLoc, endLoc);
    if (options.ranges) comment.range = [start, end];
    array.push(comment);
  };
}

},{"./locutil":5,"./util":15}],9:[function(_dereq_,module,exports){
"use strict";

var _tokentype = _dereq_("./tokentype");

var _state = _dereq_("./state");

var _whitespace = _dereq_("./whitespace");

var pp = _state.Parser.prototype;

// ## Parser utilities

// Test whether a statement node is the string literal `"use strict"`.

pp.isUseStrict = function (stmt) {
  return this.options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && stmt.expression.raw.slice(1, -1) === "use strict";
};

// Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.

pp.eat = function (type) {
  if (this.type === type) {
    this.next();
    return true;
  } else {
    return false;
  }
};

// Tests whether parsed token is a contextual keyword.

pp.isContextual = function (name) {
  return this.type === _tokentype.types.name && this.value === name;
};

// Consumes contextual keyword if possible.

pp.eatContextual = function (name) {
  return this.value === name && this.eat(_tokentype.types.name);
};

// Asserts that following token is given contextual keyword.

pp.expectContextual = function (name) {
  if (!this.eatContextual(name)) this.unexpected();
};

// Test whether a semicolon can be inserted at the current position.

pp.canInsertSemicolon = function () {
  return this.type === _tokentype.types.eof || this.type === _tokentype.types.braceR || _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};

pp.insertSemicolon = function () {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon) this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
    return true;
  }
};

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.

pp.semicolon = function () {
  if (!this.eat(_tokentype.types.semi) && !this.insertSemicolon()) this.unexpected();
};

pp.afterTrailingComma = function (tokType) {
  if (this.type == tokType) {
    if (this.options.onTrailingComma) this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
    this.next();
    return true;
  }
};

// Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error.

pp.expect = function (type) {
  this.eat(type) || this.unexpected();
};

// Raise an unexpected token error.

pp.unexpected = function (pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};

pp.checkPatternErrors = function (refDestructuringErrors, andThrow) {
  var pos = refDestructuringErrors && refDestructuringErrors.trailingComma;
  if (!andThrow) return !!pos;
  if (pos) this.raise(pos, "Trailing comma is not permitted in destructuring patterns");
};

pp.checkExpressionErrors = function (refDestructuringErrors, andThrow) {
  var pos = refDestructuringErrors && refDestructuringErrors.shorthandAssign;
  if (!andThrow) return !!pos;
  if (pos) this.raise(pos, "Shorthand property assignments are valid only in destructuring patterns");
};

},{"./state":10,"./tokentype":14,"./whitespace":16}],10:[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _identifier = _dereq_("./identifier");

var _tokentype = _dereq_("./tokentype");

var _whitespace = _dereq_("./whitespace");

var _options = _dereq_("./options");

// Registered plugins
var plugins = {};

exports.plugins = plugins;
function keywordRegexp(words) {
  return new RegExp("^(" + words.replace(/ /g, "|") + ")$");
}

var Parser = (function () {
  function Parser(options, input, startPos) {
    _classCallCheck(this, Parser);

    this.options = options = _options.getOptions(options);
    this.sourceFile = options.sourceFile;
    this.keywords = keywordRegexp(_identifier.keywords[options.ecmaVersion >= 6 ? 6 : 5]);
    var reserved = options.allowReserved ? "" : _identifier.reservedWords[options.ecmaVersion] + (options.sourceType == "module" ? " await" : "");
    this.reservedWords = keywordRegexp(reserved);
    var reservedStrict = (reserved ? reserved + " " : "") + _identifier.reservedWords.strict;
    this.reservedWordsStrict = keywordRegexp(reservedStrict);
    this.reservedWordsStrictBind = keywordRegexp(reservedStrict + " " + _identifier.reservedWords.strictBind);
    this.input = String(input);

    // Used to signal to callers of `readWord1` whether the word
    // contained any escape sequences. This is needed because words with
    // escape sequences must not be interpreted as keywords.
    this.containsEsc = false;

    // Load plugins
    this.loadPlugins(options.plugins);

    // Set up token state

    // The current position of the tokenizer in the input.
    if (startPos) {
      this.pos = startPos;
      this.lineStart = Math.max(0, this.input.lastIndexOf("\n", startPos));
      this.curLine = this.input.slice(0, this.lineStart).split(_whitespace.lineBreak).length;
    } else {
      this.pos = this.lineStart = 0;
      this.curLine = 1;
    }

    // Properties of the current token:
    // Its type
    this.type = _tokentype.types.eof;
    // For tokens that include more information than their type, the value
    this.value = null;
    // Its start and end offset
    this.start = this.end = this.pos;
    // And, if locations are used, the {line, column} object
    // corresponding to those offsets
    this.startLoc = this.endLoc = this.curPosition();

    // Position information for the previous token
    this.lastTokEndLoc = this.lastTokStartLoc = null;
    this.lastTokStart = this.lastTokEnd = this.pos;

    // The context stack is used to superficially track syntactic
    // context to predict whether a regular expression is allowed in a
    // given position.
    this.context = this.initialContext();
    this.exprAllowed = true;

    // Figure out if it's a module code.
    this.strict = this.inModule = options.sourceType === "module";

    // Used to signify the start of a potential arrow function
    this.potentialArrowAt = -1;

    // Flags to track whether we are in a function, a generator.
    this.inFunction = this.inGenerator = false;
    // Labels in scope.
    this.labels = [];

    // If enabled, skip leading hashbang line.
    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === '#!') this.skipLineComment(2);
  }

  // DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them

  Parser.prototype.isKeyword = function isKeyword(word) {
    return this.keywords.test(word);
  };

  Parser.prototype.isReservedWord = function isReservedWord(word) {
    return this.reservedWords.test(word);
  };

  Parser.prototype.extend = function extend(name, f) {
    this[name] = f(this[name]);
  };

  Parser.prototype.loadPlugins = function loadPlugins(pluginConfigs) {
    for (var _name in pluginConfigs) {
      var plugin = plugins[_name];
      if (!plugin) throw new Error("Plugin '" + _name + "' not found");
      plugin(this, pluginConfigs[_name]);
    }
  };

  Parser.prototype.parse = function parse() {
    var node = this.options.program || this.startNode();
    this.nextToken();
    return this.parseTopLevel(node);
  };

  return Parser;
})();

exports.Parser = Parser;

},{"./identifier":2,"./options":8,"./tokentype":14,"./whitespace":16}],11:[function(_dereq_,module,exports){
"use strict";

var _tokentype = _dereq_("./tokentype");

var _state = _dereq_("./state");

var _whitespace = _dereq_("./whitespace");

var pp = _state.Parser.prototype;

// ### Statement parsing

// Parse a program. Initializes the parser, reads any number of
// statements, and wraps them in a Program node.  Optionally takes a
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.

pp.parseTopLevel = function (node) {
  var first = true;
  if (!node.body) node.body = [];
  while (this.type !== _tokentype.types.eof) {
    var stmt = this.parseStatement(true, true);
    node.body.push(stmt);
    if (first) {
      if (this.isUseStrict(stmt)) this.setStrict(true);
      first = false;
    }
  }
  this.next();
  if (this.options.ecmaVersion >= 6) {
    node.sourceType = this.options.sourceType;
  }
  return this.finishNode(node, "Program");
};

var loopLabel = { kind: "loop" },
    switchLabel = { kind: "switch" };

// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.

pp.parseStatement = function (declaration, topLevel) {
  var starttype = this.type,
      node = this.startNode();

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
    case _tokentype.types._break:case _tokentype.types._continue:
      return this.parseBreakContinueStatement(node, starttype.keyword);
    case _tokentype.types._debugger:
      return this.parseDebuggerStatement(node);
    case _tokentype.types._do:
      return this.parseDoStatement(node);
    case _tokentype.types._for:
      return this.parseForStatement(node);
    case _tokentype.types._function:
      if (!declaration && this.options.ecmaVersion >= 6) this.unexpected();
      return this.parseFunctionStatement(node);
    case _tokentype.types._class:
      if (!declaration) this.unexpected();
      return this.parseClass(node, true);
    case _tokentype.types._if:
      return this.parseIfStatement(node);
    case _tokentype.types._return:
      return this.parseReturnStatement(node);
    case _tokentype.types._switch:
      return this.parseSwitchStatement(node);
    case _tokentype.types._throw:
      return this.parseThrowStatement(node);
    case _tokentype.types._try:
      return this.parseTryStatement(node);
    case _tokentype.types._let:case _tokentype.types._const:
      if (!declaration) this.unexpected(); // NOTE: falls through to _var
    case _tokentype.types._var:
      return this.parseVarStatement(node, starttype);
    case _tokentype.types._while:
      return this.parseWhileStatement(node);
    case _tokentype.types._with:
      return this.parseWithStatement(node);
    case _tokentype.types.braceL:
      return this.parseBlock();
    case _tokentype.types.semi:
      return this.parseEmptyStatement(node);
    case _tokentype.types._export:
    case _tokentype.types._import:
      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) this.raise(this.start, "'import' and 'export' may only appear at the top level");
        if (!this.inModule) this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
      }
      return starttype === _tokentype.types._import ? this.parseImport(node) : this.parseExport(node);

    // If the statement does not start with a statement keyword or a
    // brace, it's an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
    default:
      var maybeName = this.value,
          expr = this.parseExpression();
      if (starttype === _tokentype.types.name && expr.type === "Identifier" && this.eat(_tokentype.types.colon)) return this.parseLabeledStatement(node, maybeName, expr);else return this.parseExpressionStatement(node, expr);
  }
};

pp.parseBreakContinueStatement = function (node, keyword) {
  var isBreak = keyword == "break";
  this.next();
  if (this.eat(_tokentype.types.semi) || this.insertSemicolon()) node.label = null;else if (this.type !== _tokentype.types.name) this.unexpected();else {
    node.label = this.parseIdent();
    this.semicolon();
  }

  // Verify that there is an actual destination to break or
  // continue to.
  for (var i = 0; i < this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
      if (node.label && isBreak) break;
    }
  }
  if (i === this.labels.length) this.raise(node.start, "Unsyntactic " + keyword);
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};

pp.parseDebuggerStatement = function (node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement");
};

pp.parseDoStatement = function (node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.labels.pop();
  this.expect(_tokentype.types._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6) this.eat(_tokentype.types.semi);else this.semicolon();
  return this.finishNode(node, "DoWhileStatement");
};

// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.

pp.parseForStatement = function (node) {
  this.next();
  this.labels.push(loopLabel);
  this.expect(_tokentype.types.parenL);
  if (this.type === _tokentype.types.semi) return this.parseFor(node, null);
  if (this.type === _tokentype.types._var || this.type === _tokentype.types._let || this.type === _tokentype.types._const) {
    var _init = this.startNode(),
        varKind = this.type;
    this.next();
    this.parseVar(_init, true, varKind);
    this.finishNode(_init, "VariableDeclaration");
    if ((this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && _init.declarations.length === 1 && !(varKind !== _tokentype.types._var && _init.declarations[0].init)) return this.parseForIn(node, _init);
    return this.parseFor(node, _init);
  }
  var refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 };
  var init = this.parseExpression(true, refDestructuringErrors);
  if (this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) {
    this.checkPatternErrors(refDestructuringErrors, true);
    this.toAssignable(init);
    this.checkLVal(init);
    return this.parseForIn(node, init);
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  return this.parseFor(node, init);
};

pp.parseFunctionStatement = function (node) {
  this.next();
  return this.parseFunction(node, true);
};

pp.parseIfStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression();
  node.consequent = this.parseStatement(false);
  node.alternate = this.eat(_tokentype.types._else) ? this.parseStatement(false) : null;
  return this.finishNode(node, "IfStatement");
};

pp.parseReturnStatement = function (node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction) this.raise(this.start, "'return' outside of function");
  this.next();

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.eat(_tokentype.types.semi) || this.insertSemicolon()) node.argument = null;else {
    node.argument = this.parseExpression();this.semicolon();
  }
  return this.finishNode(node, "ReturnStatement");
};

pp.parseSwitchStatement = function (node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(_tokentype.types.braceL);
  this.labels.push(switchLabel);

  // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  for (var cur, sawDefault = false; this.type != _tokentype.types.braceR;) {
    if (this.type === _tokentype.types._case || this.type === _tokentype.types._default) {
      var isCase = this.type === _tokentype.types._case;
      if (cur) this.finishNode(cur, "SwitchCase");
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) this.raise(this.lastTokStart, "Multiple default clauses");
        sawDefault = true;
        cur.test = null;
      }
      this.expect(_tokentype.types.colon);
    } else {
      if (!cur) this.unexpected();
      cur.consequent.push(this.parseStatement(true));
    }
  }
  if (cur) this.finishNode(cur, "SwitchCase");
  this.next(); // Closing brace
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement");
};

pp.parseThrowStatement = function (node) {
  this.next();
  if (_whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) this.raise(this.lastTokEnd, "Illegal newline after throw");
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement");
};

// Reused empty array added for node fields that are always empty.

var empty = [];

pp.parseTryStatement = function (node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === _tokentype.types._catch) {
    var clause = this.startNode();
    this.next();
    this.expect(_tokentype.types.parenL);
    clause.param = this.parseBindingAtom();
    this.checkLVal(clause.param, true);
    this.expect(_tokentype.types.parenR);
    clause.body = this.parseBlock();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(_tokentype.types._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer) this.raise(node.start, "Missing catch or finally clause");
  return this.finishNode(node, "TryStatement");
};

pp.parseVarStatement = function (node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration");
};

pp.parseWhileStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, "WhileStatement");
};

pp.parseWithStatement = function (node) {
  if (this.strict) this.raise(this.start, "'with' in strict mode");
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement(false);
  return this.finishNode(node, "WithStatement");
};

pp.parseEmptyStatement = function (node) {
  this.next();
  return this.finishNode(node, "EmptyStatement");
};

pp.parseLabeledStatement = function (node, maybeName, expr) {
  for (var i = 0; i < this.labels.length; ++i) {
    if (this.labels[i].name === maybeName) this.raise(expr.start, "Label '" + maybeName + "' is already declared");
  }var kind = this.type.isLoop ? "loop" : this.type === _tokentype.types._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label = this.labels[i];
    if (label.statementStart == node.start) {
      label.statementStart = this.start;
      label.kind = kind;
    } else break;
  }
  this.labels.push({ name: maybeName, kind: kind, statementStart: this.start });
  node.body = this.parseStatement(true);
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement");
};

pp.parseExpressionStatement = function (node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement");
};

// Parse a semicolon-enclosed block of statements, handling `"use
// strict"` declarations when `allowStrict` is true (used for
// function bodies).

pp.parseBlock = function (allowStrict) {
  var node = this.startNode(),
      first = true,
      oldStrict = undefined;
  node.body = [];
  this.expect(_tokentype.types.braceL);
  while (!this.eat(_tokentype.types.braceR)) {
    var stmt = this.parseStatement(true);
    node.body.push(stmt);
    if (first && allowStrict && this.isUseStrict(stmt)) {
      oldStrict = this.strict;
      this.setStrict(this.strict = true);
    }
    first = false;
  }
  if (oldStrict === false) this.setStrict(false);
  return this.finishNode(node, "BlockStatement");
};

// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.

pp.parseFor = function (node, init) {
  node.init = init;
  this.expect(_tokentype.types.semi);
  node.test = this.type === _tokentype.types.semi ? null : this.parseExpression();
  this.expect(_tokentype.types.semi);
  node.update = this.type === _tokentype.types.parenR ? null : this.parseExpression();
  this.expect(_tokentype.types.parenR);
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, "ForStatement");
};

// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.

pp.parseForIn = function (node, init) {
  var type = this.type === _tokentype.types._in ? "ForInStatement" : "ForOfStatement";
  this.next();
  node.left = init;
  node.right = this.parseExpression();
  this.expect(_tokentype.types.parenR);
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, type);
};

// Parse a list of variable declarations.

pp.parseVar = function (node, isFor, kind) {
  node.declarations = [];
  node.kind = kind.keyword;
  for (;;) {
    var decl = this.startNode();
    this.parseVarId(decl);
    if (this.eat(_tokentype.types.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (kind === _tokentype.types._const && !(this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      this.unexpected();
    } else if (decl.id.type != "Identifier" && !(isFor && (this.type === _tokentype.types._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(_tokentype.types.comma)) break;
  }
  return node;
};

pp.parseVarId = function (decl) {
  decl.id = this.parseBindingAtom();
  this.checkLVal(decl.id, true);
};

// Parse a function declaration or literal (depending on the
// `isStatement` parameter).

pp.parseFunction = function (node, isStatement, allowExpressionBody) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 6) node.generator = this.eat(_tokentype.types.star);
  if (isStatement || this.type === _tokentype.types.name) node.id = this.parseIdent();
  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody);
  return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
};

pp.parseFunctionParams = function (node) {
  this.expect(_tokentype.types.parenL);
  node.params = this.parseBindingList(_tokentype.types.parenR, false, false, true);
};

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

pp.parseClass = function (node, isStatement) {
  this.next();
  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(_tokentype.types.braceL);
  while (!this.eat(_tokentype.types.braceR)) {
    if (this.eat(_tokentype.types.semi)) continue;
    var method = this.startNode();
    var isGenerator = this.eat(_tokentype.types.star);
    var isMaybeStatic = this.type === _tokentype.types.name && this.value === "static";
    this.parsePropertyName(method);
    method["static"] = isMaybeStatic && this.type !== _tokentype.types.parenL;
    if (method["static"]) {
      if (isGenerator) this.unexpected();
      isGenerator = this.eat(_tokentype.types.star);
      this.parsePropertyName(method);
    }
    method.kind = "method";
    var isGetSet = false;
    if (!method.computed) {
      var key = method.key;

      if (!isGenerator && key.type === "Identifier" && this.type !== _tokentype.types.parenL && (key.name === "get" || key.name === "set")) {
        isGetSet = true;
        method.kind = key.name;
        key = this.parsePropertyName(method);
      }
      if (!method["static"] && (key.type === "Identifier" && key.name === "constructor" || key.type === "Literal" && key.value === "constructor")) {
        if (hadConstructor) this.raise(key.start, "Duplicate constructor in the same class");
        if (isGetSet) this.raise(key.start, "Constructor can't have get/set modifier");
        if (isGenerator) this.raise(key.start, "Constructor can't be a generator");
        method.kind = "constructor";
        hadConstructor = true;
      }
    }
    this.parseClassMethod(classBody, method, isGenerator);
    if (isGetSet) {
      var paramCount = method.kind === "get" ? 0 : 1;
      if (method.value.params.length !== paramCount) {
        var start = method.value.start;
        if (method.kind === "get") this.raise(start, "getter should have no params");else this.raise(start, "setter should have exactly one param");
      }
      if (method.kind === "set" && method.value.params[0].type === "RestElement") this.raise(method.value.params[0].start, "Setter cannot use rest params");
    }
  }
  node.body = this.finishNode(classBody, "ClassBody");
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};

pp.parseClassMethod = function (classBody, method, isGenerator) {
  method.value = this.parseMethod(isGenerator);
  classBody.body.push(this.finishNode(method, "MethodDefinition"));
};

pp.parseClassId = function (node, isStatement) {
  node.id = this.type === _tokentype.types.name ? this.parseIdent() : isStatement ? this.unexpected() : null;
};

pp.parseClassSuper = function (node) {
  node.superClass = this.eat(_tokentype.types._extends) ? this.parseExprSubscripts() : null;
};

// Parses module export declaration.

pp.parseExport = function (node) {
  this.next();
  // export * from '...'
  if (this.eat(_tokentype.types.star)) {
    this.expectContextual("from");
    node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
    this.semicolon();
    return this.finishNode(node, "ExportAllDeclaration");
  }
  if (this.eat(_tokentype.types._default)) {
    // export default ...
    var expr = this.parseMaybeAssign();
    var needsSemi = true;
    if (expr.type == "FunctionExpression" || expr.type == "ClassExpression") {
      needsSemi = false;
      if (expr.id) {
        expr.type = expr.type == "FunctionExpression" ? "FunctionDeclaration" : "ClassDeclaration";
      }
    }
    node.declaration = expr;
    if (needsSemi) this.semicolon();
    return this.finishNode(node, "ExportDefaultDeclaration");
  }
  // export var|const|let|function|class ...
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseStatement(true);
    node.specifiers = [];
    node.source = null;
  } else {
    // export { x, y as z } [from '...']
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers();
    if (this.eatContextual("from")) {
      node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
    } else {
      // check for keywords used as local names
      for (var i = 0; i < node.specifiers.length; i++) {
        if (this.keywords.test(node.specifiers[i].local.name) || this.reservedWords.test(node.specifiers[i].local.name)) {
          this.unexpected(node.specifiers[i].local.start);
        }
      }

      node.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration");
};

pp.shouldParseExportStatement = function () {
  return this.type.keyword;
};

// Parses a comma-separated list of module exports.

pp.parseExportSpecifiers = function () {
  var nodes = [],
      first = true;
  // export { x, y as z } [from '...']
  this.expect(_tokentype.types.braceL);
  while (!this.eat(_tokentype.types.braceR)) {
    if (!first) {
      this.expect(_tokentype.types.comma);
      if (this.afterTrailingComma(_tokentype.types.braceR)) break;
    } else first = false;

    var node = this.startNode();
    node.local = this.parseIdent(this.type === _tokentype.types._default);
    node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
    nodes.push(this.finishNode(node, "ExportSpecifier"));
  }
  return nodes;
};

// Parses import declaration.

pp.parseImport = function (node) {
  this.next();
  // import '...'
  if (this.type === _tokentype.types.string) {
    node.specifiers = empty;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration");
};

// Parses a comma-separated list of module imports.

pp.parseImportSpecifiers = function () {
  var nodes = [],
      first = true;
  if (this.type === _tokentype.types.name) {
    // import defaultObj, { x, y as z } from '...'
    var node = this.startNode();
    node.local = this.parseIdent();
    this.checkLVal(node.local, true);
    nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
    if (!this.eat(_tokentype.types.comma)) return nodes;
  }
  if (this.type === _tokentype.types.star) {
    var node = this.startNode();
    this.next();
    this.expectContextual("as");
    node.local = this.parseIdent();
    this.checkLVal(node.local, true);
    nodes.push(this.finishNode(node, "ImportNamespaceSpecifier"));
    return nodes;
  }
  this.expect(_tokentype.types.braceL);
  while (!this.eat(_tokentype.types.braceR)) {
    if (!first) {
      this.expect(_tokentype.types.comma);
      if (this.afterTrailingComma(_tokentype.types.braceR)) break;
    } else first = false;

    var node = this.startNode();
    node.imported = this.parseIdent(true);
    if (this.eatContextual("as")) {
      node.local = this.parseIdent();
    } else {
      node.local = node.imported;
      if (this.isKeyword(node.local.name)) this.unexpected(node.local.start);
      if (this.reservedWordsStrict.test(node.local.name)) this.raise(node.local.start, "The keyword '" + node.local.name + "' is reserved");
    }
    this.checkLVal(node.local, true);
    nodes.push(this.finishNode(node, "ImportSpecifier"));
  }
  return nodes;
};

},{"./state":10,"./tokentype":14,"./whitespace":16}],12:[function(_dereq_,module,exports){
// The algorithm used to determine whether a regexp can appear at a
// given point in the program is loosely based on sweet.js' approach.
// See https://github.com/mozilla/sweet.js/wiki/design

"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _state = _dereq_("./state");

var _tokentype = _dereq_("./tokentype");

var _whitespace = _dereq_("./whitespace");

var TokContext = function TokContext(token, isExpr, preserveSpace, override) {
  _classCallCheck(this, TokContext);

  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
};

exports.TokContext = TokContext;
var types = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", true),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function (p) {
    return p.readTmplToken();
  }),
  f_expr: new TokContext("function", true)
};

exports.types = types;
var pp = _state.Parser.prototype;

pp.initialContext = function () {
  return [types.b_stat];
};

pp.braceIsBlock = function (prevType) {
  if (prevType === _tokentype.types.colon) {
    var _parent = this.curContext();
    if (_parent === types.b_stat || _parent === types.b_expr) return !_parent.isExpr;
  }
  if (prevType === _tokentype.types._return) return _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  if (prevType === _tokentype.types._else || prevType === _tokentype.types.semi || prevType === _tokentype.types.eof || prevType === _tokentype.types.parenR) return true;
  if (prevType == _tokentype.types.braceL) return this.curContext() === types.b_stat;
  return !this.exprAllowed;
};

pp.updateContext = function (prevType) {
  var update = undefined,
      type = this.type;
  if (type.keyword && prevType == _tokentype.types.dot) this.exprAllowed = false;else if (update = type.updateContext) update.call(this, prevType);else this.exprAllowed = type.beforeExpr;
};

// Token-specific context update code

_tokentype.types.parenR.updateContext = _tokentype.types.braceR.updateContext = function () {
  if (this.context.length == 1) {
    this.exprAllowed = true;
    return;
  }
  var out = this.context.pop();
  if (out === types.b_stat && this.curContext() === types.f_expr) {
    this.context.pop();
    this.exprAllowed = false;
  } else if (out === types.b_tmpl) {
    this.exprAllowed = true;
  } else {
    this.exprAllowed = !out.isExpr;
  }
};

_tokentype.types.braceL.updateContext = function (prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
  this.exprAllowed = true;
};

_tokentype.types.dollarBraceL.updateContext = function () {
  this.context.push(types.b_tmpl);
  this.exprAllowed = true;
};

_tokentype.types.parenL.updateContext = function (prevType) {
  var statementParens = prevType === _tokentype.types._if || prevType === _tokentype.types._for || prevType === _tokentype.types._with || prevType === _tokentype.types._while;
  this.context.push(statementParens ? types.p_stat : types.p_expr);
  this.exprAllowed = true;
};

_tokentype.types.incDec.updateContext = function () {
  // tokExprAllowed stays unchanged
};

_tokentype.types._function.updateContext = function () {
  if (this.curContext() !== types.b_stat) this.context.push(types.f_expr);
  this.exprAllowed = false;
};

_tokentype.types.backQuote.updateContext = function () {
  if (this.curContext() === types.q_tmpl) this.context.pop();else this.context.push(types.q_tmpl);
  this.exprAllowed = false;
};

},{"./state":10,"./tokentype":14,"./whitespace":16}],13:[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _identifier = _dereq_("./identifier");

var _tokentype = _dereq_("./tokentype");

var _state = _dereq_("./state");

var _locutil = _dereq_("./locutil");

var _whitespace = _dereq_("./whitespace");

// Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.

var Token = function Token(p) {
  _classCallCheck(this, Token);

  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations) this.loc = new _locutil.SourceLocation(p, p.startLoc, p.endLoc);
  if (p.options.ranges) this.range = [p.start, p.end];
}

// ## Tokenizer

;

exports.Token = Token;
var pp = _state.Parser.prototype;

// Are we running under Rhino?
var isRhino = typeof Packages == "object" && Object.prototype.toString.call(Packages) == "[object JavaPackage]";

// Move to the next token

pp.next = function () {
  if (this.options.onToken) this.options.onToken(new Token(this));

  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};

pp.getToken = function () {
  this.next();
  return new Token(this);
};

// If we're in an ES6 environment, make parsers iterable
if (typeof Symbol !== "undefined") pp[Symbol.iterator] = function () {
  var self = this;
  return { next: function next() {
      var token = self.getToken();
      return {
        done: token.type === _tokentype.types.eof,
        value: token
      };
    } };
};

// Toggle strict mode. Re-reads the next number or string to please
// pedantic tests (`"use strict"; 010;` should fail).

pp.setStrict = function (strict) {
  this.strict = strict;
  if (this.type !== _tokentype.types.num && this.type !== _tokentype.types.string) return;
  this.pos = this.start;
  if (this.options.locations) {
    while (this.pos < this.lineStart) {
      this.lineStart = this.input.lastIndexOf("\n", this.lineStart - 2) + 1;
      --this.curLine;
    }
  }
  this.nextToken();
};

pp.curContext = function () {
  return this.context[this.context.length - 1];
};

// Read a single token, updating the parser object's token-related
// properties.

pp.nextToken = function () {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) this.skipSpace();

  this.start = this.pos;
  if (this.options.locations) this.startLoc = this.curPosition();
  if (this.pos >= this.input.length) return this.finishToken(_tokentype.types.eof);

  if (curContext.override) return curContext.override(this);else this.readToken(this.fullCharCodeAtPos());
};

pp.readToken = function (code) {
  // Identifier or keyword. '\uXXXX' sequences are allowed in
  // identifiers, so '\' also dispatches to that.
  if (_identifier.isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */) return this.readWord();

  return this.getTokenFromCode(code);
};

pp.fullCharCodeAtPos = function () {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 0xd7ff || code >= 0xe000) return code;
  var next = this.input.charCodeAt(this.pos + 1);
  return (code << 10) + next - 0x35fdc00;
};

pp.skipBlockComment = function () {
  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos,
      end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) this.raise(this.pos - 2, "Unterminated comment");
  this.pos = end + 2;
  if (this.options.locations) {
    _whitespace.lineBreakG.lastIndex = start;
    var match = undefined;
    while ((match = _whitespace.lineBreakG.exec(this.input)) && match.index < this.pos) {
      ++this.curLine;
      this.lineStart = match.index + match[0].length;
    }
  }
  if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
};

pp.skipLineComment = function (startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
    ++this.pos;
    ch = this.input.charCodeAt(this.pos);
  }
  if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
};

// Called at the start of the parse and after every token. Skips
// whitespace and comments, and.

pp.skipSpace = function () {
  loop: while (this.pos < this.input.length) {
    var ch = this.input.charCodeAt(this.pos);
    switch (ch) {
      case 32:case 160:
        // ' '
        ++this.pos;
        break;
      case 13:
        if (this.input.charCodeAt(this.pos + 1) === 10) {
          ++this.pos;
        }
      case 10:case 8232:case 8233:
        ++this.pos;
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        break;
      case 47:
        // '/'
        switch (this.input.charCodeAt(this.pos + 1)) {
          case 42:
            // '*'
            this.skipBlockComment();
            break;
          case 47:
            this.skipLineComment(2);
            break;
          default:
            break loop;
        }
        break;
      default:
        if (ch > 8 && ch < 14 || ch >= 5760 && _whitespace.nonASCIIwhitespace.test(String.fromCharCode(ch))) {
          ++this.pos;
        } else {
          break loop;
        }
    }
  }
};

// Called at the end of every token. Sets `end`, `val`, and
// maintains `context` and `exprAllowed`, and skips the space after
// the token, so that the next one's `start` will point at the
// right position.

pp.finishToken = function (type, val) {
  this.end = this.pos;
  if (this.options.locations) this.endLoc = this.curPosition();
  var prevType = this.type;
  this.type = type;
  this.value = val;

  this.updateContext(prevType);
};

// ### Token reading

// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
//
pp.readToken_dot = function () {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) return this.readNumber(true);
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
    // 46 = dot '.'
    this.pos += 3;
    return this.finishToken(_tokentype.types.ellipsis);
  } else {
    ++this.pos;
    return this.finishToken(_tokentype.types.dot);
  }
};

pp.readToken_slash = function () {
  // '/'
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) {
    ++this.pos;return this.readRegexp();
  }
  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
  return this.finishOp(_tokentype.types.slash, 1);
};

pp.readToken_mult_modulo = function (code) {
  // '%*'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
  return this.finishOp(code === 42 ? _tokentype.types.star : _tokentype.types.modulo, 1);
};

pp.readToken_pipe_amp = function (code) {
  // '|&'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) return this.finishOp(code === 124 ? _tokentype.types.logicalOR : _tokentype.types.logicalAND, 2);
  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
  return this.finishOp(code === 124 ? _tokentype.types.bitwiseOR : _tokentype.types.bitwiseAND, 1);
};

pp.readToken_caret = function () {
  // '^'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
  return this.finishOp(_tokentype.types.bitwiseXOR, 1);
};

pp.readToken_plus_min = function (code) {
  // '+-'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 && _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {
      // A `-->` line comment
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken();
    }
    return this.finishOp(_tokentype.types.incDec, 2);
  }
  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
  return this.finishOp(_tokentype.types.plusMin, 1);
};

pp.readToken_lt_gt = function (code) {
  // '<>'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(_tokentype.types.assign, size + 1);
    return this.finishOp(_tokentype.types.bitShift, size);
  }
  if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 && this.input.charCodeAt(this.pos + 3) == 45) {
    if (this.inModule) this.unexpected();
    // `<!--`, an XML-style comment that should be interpreted as a line comment
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken();
  }
  if (next === 61) size = this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2;
  return this.finishOp(_tokentype.types.relational, size);
};

pp.readToken_eq_excl = function (code) {
  // '=!'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) return this.finishOp(_tokentype.types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
    // '=>'
    this.pos += 2;
    return this.finishToken(_tokentype.types.arrow);
  }
  return this.finishOp(code === 61 ? _tokentype.types.eq : _tokentype.types.prefix, 1);
};

pp.getTokenFromCode = function (code) {
  switch (code) {
    // The interpretation of a dot depends on whether it is followed
    // by a digit or another two dots.
    case 46:
      // '.'
      return this.readToken_dot();

    // Punctuation tokens.
    case 40:
      ++this.pos;return this.finishToken(_tokentype.types.parenL);
    case 41:
      ++this.pos;return this.finishToken(_tokentype.types.parenR);
    case 59:
      ++this.pos;return this.finishToken(_tokentype.types.semi);
    case 44:
      ++this.pos;return this.finishToken(_tokentype.types.comma);
    case 91:
      ++this.pos;return this.finishToken(_tokentype.types.bracketL);
    case 93:
      ++this.pos;return this.finishToken(_tokentype.types.bracketR);
    case 123:
      ++this.pos;return this.finishToken(_tokentype.types.braceL);
    case 125:
      ++this.pos;return this.finishToken(_tokentype.types.braceR);
    case 58:
      ++this.pos;return this.finishToken(_tokentype.types.colon);
    case 63:
      ++this.pos;return this.finishToken(_tokentype.types.question);

    case 96:
      // '`'
      if (this.options.ecmaVersion < 6) break;
      ++this.pos;
      return this.finishToken(_tokentype.types.backQuote);

    case 48:
      // '0'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 120 || next === 88) return this.readRadixNumber(16); // '0x', '0X' - hex number
      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) return this.readRadixNumber(8); // '0o', '0O' - octal number
        if (next === 98 || next === 66) return this.readRadixNumber(2); // '0b', '0B' - binary number
      }
    // Anything else beginning with a digit is an integer, octal
    // number, or float.
    case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
      // 1-9
      return this.readNumber(false);

    // Quotes produce strings.
    case 34:case 39:
      // '"', "'"
      return this.readString(code);

    // Operators are parsed inline in tiny state machines. '=' (61) is
    // often referred to. `finishOp` simply skips the amount of
    // characters it is given as second argument, and returns a token
    // of the type given by its first argument.

    case 47:
      // '/'
      return this.readToken_slash();

    case 37:case 42:
      // '%*'
      return this.readToken_mult_modulo(code);

    case 124:case 38:
      // '|&'
      return this.readToken_pipe_amp(code);

    case 94:
      // '^'
      return this.readToken_caret();

    case 43:case 45:
      // '+-'
      return this.readToken_plus_min(code);

    case 60:case 62:
      // '<>'
      return this.readToken_lt_gt(code);

    case 61:case 33:
      // '=!'
      return this.readToken_eq_excl(code);

    case 126:
      // '~'
      return this.finishOp(_tokentype.types.prefix, 1);
  }

  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};

pp.finishOp = function (type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str);
};

// Parse a regular expression. Some context-awareness is necessary,
// since a '/' inside a '[]' set does not end the expression.

function tryCreateRegexp(src, flags, throwErrorAt, parser) {
  try {
    return new RegExp(src, flags);
  } catch (e) {
    if (throwErrorAt !== undefined) {
      if (e instanceof SyntaxError) parser.raise(throwErrorAt, "Error parsing regular expression: " + e.message);
      throw e;
    }
  }
}

var regexpUnicodeSupport = !!tryCreateRegexp("", "u");

pp.readRegexp = function () {
  var _this = this;

  var escaped = undefined,
      inClass = undefined,
      start = this.pos;
  for (;;) {
    if (this.pos >= this.input.length) this.raise(start, "Unterminated regular expression");
    var ch = this.input.charAt(this.pos);
    if (_whitespace.lineBreak.test(ch)) this.raise(start, "Unterminated regular expression");
    if (!escaped) {
      if (ch === "[") inClass = true;else if (ch === "]" && inClass) inClass = false;else if (ch === "/" && !inClass) break;
      escaped = ch === "\\";
    } else escaped = false;
    ++this.pos;
  }
  var content = this.input.slice(start, this.pos);
  ++this.pos;
  // Need to use `readWord1` because '\uXXXX' sequences are allowed
  // here (don't ask).
  var mods = this.readWord1();
  var tmp = content;
  if (mods) {
    var validFlags = /^[gim]*$/;
    if (this.options.ecmaVersion >= 6) validFlags = /^[gimuy]*$/;
    if (!validFlags.test(mods)) this.raise(start, "Invalid regular expression flag");
    if (mods.indexOf('u') >= 0 && !regexpUnicodeSupport) {
      // Replace each astral symbol and every Unicode escape sequence that
      // possibly represents an astral symbol or a paired surrogate with a
      // single ASCII symbol to avoid throwing on regular expressions that
      // are only valid in combination with the `/u` flag.
      // Note: replacing with the ASCII symbol `x` might cause false
      // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
      // perfectly valid pattern that is equivalent to `[a-b]`, but it would
      // be replaced by `[x-b]` which throws an error.
      tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, function (_match, code, offset) {
        code = Number("0x" + code);
        if (code > 0x10FFFF) _this.raise(start + offset + 3, "Code point out of bounds");
        return "x";
      });
      tmp = tmp.replace(/\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
    }
  }
  // Detect invalid regular expressions.
  var value = null;
  // Rhino's regular expression parser is flaky and throws uncatchable exceptions,
  // so don't do detection if we are running under Rhino
  if (!isRhino) {
    tryCreateRegexp(tmp, undefined, start, this);
    // Get a regular expression object for this pattern-flag pair, or `null` in
    // case the current environment doesn't support the flags it uses.
    value = tryCreateRegexp(content, mods);
  }
  return this.finishToken(_tokentype.types.regexp, { pattern: content, flags: mods, value: value });
};

// Read an integer in the given radix. Return null if zero digits
// were read, the integer value otherwise. When `len` is given, this
// will return `null` unless the integer has exactly `len` digits.

pp.readInt = function (radix, len) {
  var start = this.pos,
      total = 0;
  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
    var code = this.input.charCodeAt(this.pos),
        val = undefined;
    if (code >= 97) val = code - 97 + 10; // a
    else if (code >= 65) val = code - 65 + 10; // A
      else if (code >= 48 && code <= 57) val = code - 48; // 0-9
        else val = Infinity;
    if (val >= radix) break;
    ++this.pos;
    total = total * radix + val;
  }
  if (this.pos === start || len != null && this.pos - start !== len) return null;

  return total;
};

pp.readRadixNumber = function (radix) {
  this.pos += 2; // 0x
  var val = this.readInt(radix);
  if (val == null) this.raise(this.start + 2, "Expected number in radix " + radix);
  if (_identifier.isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
  return this.finishToken(_tokentype.types.num, val);
};

// Read an integer, octal integer, or floating-point number.

pp.readNumber = function (startsWithDot) {
  var start = this.pos,
      isFloat = false,
      octal = this.input.charCodeAt(this.pos) === 48;
  if (!startsWithDot && this.readInt(10) === null) this.raise(start, "Invalid number");
  var next = this.input.charCodeAt(this.pos);
  if (next === 46) {
    // '.'
    ++this.pos;
    this.readInt(10);
    isFloat = true;
    next = this.input.charCodeAt(this.pos);
  }
  if (next === 69 || next === 101) {
    // 'eE'
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) ++this.pos; // '+-'
    if (this.readInt(10) === null) this.raise(start, "Invalid number");
    isFloat = true;
  }
  if (_identifier.isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");

  var str = this.input.slice(start, this.pos),
      val = undefined;
  if (isFloat) val = parseFloat(str);else if (!octal || str.length === 1) val = parseInt(str, 10);else if (/[89]/.test(str) || this.strict) this.raise(start, "Invalid number");else val = parseInt(str, 8);
  return this.finishToken(_tokentype.types.num, val);
};

// Read a string value, interpreting backslash-escapes.

pp.readCodePoint = function () {
  var ch = this.input.charCodeAt(this.pos),
      code = undefined;

  if (ch === 123) {
    if (this.options.ecmaVersion < 6) this.unexpected();
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf('}', this.pos) - this.pos);
    ++this.pos;
    if (code > 0x10FFFF) this.raise(codePos, "Code point out of bounds");
  } else {
    code = this.readHexChar(4);
  }
  return code;
};

function codePointToString(code) {
  // UTF-16 Decoding
  if (code <= 0xFFFF) return String.fromCharCode(code);
  code -= 0x10000;
  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);
}

pp.readString = function (quote) {
  var out = "",
      chunkStart = ++this.pos;
  for (;;) {
    if (this.pos >= this.input.length) this.raise(this.start, "Unterminated string constant");
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) break;
    if (ch === 92) {
      // '\'
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else {
      if (_whitespace.isNewLine(ch)) this.raise(this.start, "Unterminated string constant");
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(_tokentype.types.string, out);
};

// Reads template string tokens.

pp.readTmplToken = function () {
  var out = "",
      chunkStart = this.pos;
  for (;;) {
    if (this.pos >= this.input.length) this.raise(this.start, "Unterminated template");
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
      // '`', '${'
      if (this.pos === this.start && this.type === _tokentype.types.template) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(_tokentype.types.dollarBraceL);
        } else {
          ++this.pos;
          return this.finishToken(_tokentype.types.backQuote);
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(_tokentype.types.template, out);
    }
    if (ch === 92) {
      // '\'
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (_whitespace.isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) ++this.pos;
        case 10:
          out += "\n";
          break;
        default:
          out += String.fromCharCode(ch);
          break;
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};

// Used to read escaped characters

pp.readEscapedChar = function (inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
    case 110:
      return "\n"; // 'n' -> '\n'
    case 114:
      return "\r"; // 'r' -> '\r'
    case 120:
      return String.fromCharCode(this.readHexChar(2)); // 'x'
    case 117:
      return codePointToString(this.readCodePoint()); // 'u'
    case 116:
      return "\t"; // 't' -> '\t'
    case 98:
      return "\b"; // 'b' -> '\b'
    case 118:
      return "\u000b"; // 'v' -> '\u000b'
    case 102:
      return "\f"; // 'f' -> '\f'
    case 13:
      if (this.input.charCodeAt(this.pos) === 10) ++this.pos; // '\r\n'
    case 10:
      // ' \n'
      if (this.options.locations) {
        this.lineStart = this.pos;++this.curLine;
      }
      return "";
    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        if (octalStr !== "0" && (this.strict || inTemplate)) {
          this.raise(this.pos - 2, "Octal literal in strict mode");
        }
        this.pos += octalStr.length - 1;
        return String.fromCharCode(octal);
      }
      return String.fromCharCode(ch);
  }
};

// Used to read character escape sequences ('\x', '\u', '\U').

pp.readHexChar = function (len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);
  if (n === null) this.raise(codePos, "Bad character escape sequence");
  return n;
};

// Read an identifier, and return it as a string. Sets `this.containsEsc`
// to whether the word contained a '\u' escape.
//
// Incrementally adds only escaped chars, adding other chunks as-is
// as a micro-optimization.

pp.readWord1 = function () {
  this.containsEsc = false;
  var word = "",
      first = true,
      chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (_identifier.isIdentifierChar(ch, astral)) {
      this.pos += ch <= 0xffff ? 1 : 2;
    } else if (ch === 92) {
      // "\"
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) != 117) // "u"
        this.raise(this.pos, "Expecting Unicode escape sequence \\uXXXX");
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first ? _identifier.isIdentifierStart : _identifier.isIdentifierChar)(esc, astral)) this.raise(escStart, "Invalid Unicode escape");
      word += codePointToString(esc);
      chunkStart = this.pos;
    } else {
      break;
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos);
};

// Read an identifier or keyword token. Will check for reserved
// words when necessary.

pp.readWord = function () {
  var word = this.readWord1();
  var type = _tokentype.types.name;
  if ((this.options.ecmaVersion >= 6 || !this.containsEsc) && this.keywords.test(word)) type = _tokentype.keywords[word];
  return this.finishToken(type, word);
};

},{"./identifier":2,"./locutil":5,"./state":10,"./tokentype":14,"./whitespace":16}],14:[function(_dereq_,module,exports){
// ## Token types

// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.

// All token type variables start with an underscore, to make them
// easy to recognize.

// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// The `startsExpr` property is used to check if the token ends a
// `yield` expression. It is set on all token types that either can
// directly start an expression (like a quotation mark) or can
// continue an expression (like the body of a string).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.

"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TokenType = function TokenType(label) {
  var conf = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  _classCallCheck(this, TokenType);

  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

exports.TokenType = TokenType;

function binop(name, prec) {
  return new TokenType(name, { beforeExpr: true, binop: prec });
}
var beforeExpr = { beforeExpr: true },
    startsExpr = { startsExpr: true };

var types = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  eof: new TokenType("eof"),

  // Punctuation token types.
  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),

  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.

  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
  prefix: new TokenType("prefix", { beforeExpr: true, prefix: true, startsExpr: true }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=", 6),
  relational: binop("</>", 7),
  bitShift: binop("<</>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10)
};

exports.types = types;
// Map keyword names to token types.

var keywords = {};

exports.keywords = keywords;
// Succinct definitions of keyword token types
function kw(name) {
  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  options.keyword = name;
  keywords[name] = types["_" + name] = new TokenType(name, options);
}

kw("break");
kw("case", beforeExpr);
kw("catch");
kw("continue");
kw("debugger");
kw("default", beforeExpr);
kw("do", { isLoop: true, beforeExpr: true });
kw("else", beforeExpr);
kw("finally");
kw("for", { isLoop: true });
kw("function", startsExpr);
kw("if");
kw("return", beforeExpr);
kw("switch");
kw("throw", beforeExpr);
kw("try");
kw("var");
kw("let");
kw("const");
kw("while", { isLoop: true });
kw("with");
kw("new", { beforeExpr: true, startsExpr: true });
kw("this", startsExpr);
kw("super", startsExpr);
kw("class");
kw("extends", beforeExpr);
kw("export");
kw("import");
kw("yield", { beforeExpr: true, startsExpr: true });
kw("null", startsExpr);
kw("true", startsExpr);
kw("false", startsExpr);
kw("in", { beforeExpr: true, binop: 7 });
kw("instanceof", { beforeExpr: true, binop: 7 });
kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true });
kw("void", { beforeExpr: true, prefix: true, startsExpr: true });
kw("delete", { beforeExpr: true, prefix: true, startsExpr: true });

},{}],15:[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;
exports.isArray = isArray;
exports.has = has;

function isArray(obj) {
  return Object.prototype.toString.call(obj) === "[object Array]";
}

// Checks if an object has a property.

function has(obj, propName) {
  return Object.prototype.hasOwnProperty.call(obj, propName);
}

},{}],16:[function(_dereq_,module,exports){
// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

"use strict";

exports.__esModule = true;
exports.isNewLine = isNewLine;
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
exports.lineBreak = lineBreak;
var lineBreakG = new RegExp(lineBreak.source, "g");

exports.lineBreakG = lineBreakG;

function isNewLine(code) {
  return code === 10 || code === 13 || code === 0x2028 || code == 0x2029;
}

var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
exports.nonASCIIwhitespace = nonASCIIwhitespace;

},{}]},{},[3])(3)
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],45:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    acorn = require('acorn'),
    estraverse = require('estraverse'),
    CONSEQUENT = 'consequent',
    Syntax = estraverse.Syntax,
    createSwitchCase = function createSwitchCase(statementNode, index, nextIndex) {
        var consequent = [statementNode];

        if (nextIndex !== null) {
            if (!nextIndex) {
                nextIndex = index + 1;
            }

            consequent.push(acorn.parse('statementIndex = ' + nextIndex + ';').body[0]);
        }

        return {
            type: Syntax.SwitchCase,
            test: {
                type: Syntax.Literal,
                value: index
            },
            consequent: consequent
        };
    };

function BlockContext(functionContext) {
    this.functionContext = functionContext;
    this.switchCases = [];
    this.transforms = [];
    this.transformsStack = [];
}

_.extend(BlockContext.prototype, {
    addAssignment: function (name) {
        var context = this,
            index = context.functionContext.getNextStatementIndex();

        return {
            assign: function (expressionNode) {
                if (!expressionNode) {
                    throw new Error('Expression node must be specified');
                }

                context.functionContext.addAssignment(index, name);

                context.switchCases[index] = createSwitchCase(
                    {
                        'type': Syntax.ExpressionStatement,
                        'expression': {
                            'type': Syntax.AssignmentExpression,
                            'operator': '=',
                            'left': {
                                'type': Syntax.Identifier,
                                'name': name
                            },
                            'right': expressionNode
                        }
                    },
                    index
                );
            }
        };
    },

    addResumeThrow: function () {
        var context = this,
            index = context.functionContext.getCurrentStatementIndex();

        return {
            assign: function (expressionNode) {
                var endIndex = context.functionContext.getCurrentStatementIndex() - 1,
                    i;

                if (!expressionNode) {
                    throw new Error('Expression node must be specified');
                }

                // Previous statement needs to skip over the throw:
                // it will only be needed for resumes
                context.appendToLastStatement({
                    'type': Syntax.BreakStatement,
                    'label': null
                });

                // Add a case that simply throws the error,
                // to allow us to easily resume inside a catch block
                for (i = index; i < endIndex; i++) {
                    context.switchCases[i] = {
                        'type': Syntax.SwitchCase,
                        'test': {
                            type: Syntax.Literal,
                            value: i
                        },
                        'consequent': []
                    };
                }

                context.switchCases[endIndex] = {
                    'type': Syntax.SwitchCase,
                    'test': {
                        type: Syntax.Literal,
                        value: endIndex
                    },
                    'consequent': [
                        {
                            'type': Syntax.ThrowStatement,
                            'argument': {
                                'type': Syntax.NewExpression,
                                'callee': {
                                    'type': Syntax.MemberExpression,
                                    'object': {
                                        'type': Syntax.Identifier,
                                        'name': 'Resumable'
                                    },
                                    'property': {
                                        'type': Syntax.Identifier,
                                        'name': 'ResumeException'
                                    },
                                    'computed': false
                                },
                                'arguments': [expressionNode]
                            }
                        }
                    ]
                };
            }
        };
    },

    appendToLastStatement: function (statementNode) {
        var context = this,
            switchCase = context.switchCases[context.switchCases.length - 1];

        if (!switchCase) {
            return;
        }

        if (_.isArray(switchCase)) {
            switchCase[switchCase.length - 1][CONSEQUENT].push(statementNode);
        } else {
            switchCase.push(statementNode);
        }
    },

    getSwitchStatement: function () {
        var switchCases = [];

        _.each(this.switchCases, function (switchCase) {
            if (switchCase) {
                if (_.isArray(switchCase)) {
                    [].push.apply(switchCases, switchCase);
                } else {
                    switchCases.push(switchCase);
                }
            }
        });

        return {
            'type': Syntax.SwitchStatement,
            'discriminant': {
                'type': Syntax.Identifier,
                'name': 'statementIndex'
            },
            'cases': switchCases
        };
    },

    prepareStatement: function () {
        var context = this,
            endIndex = null,
            index = context.functionContext.getNextStatementIndex(),
            transforms = context.transforms.slice();

        context.transforms = [];

        return {
            append: function (statementNode) {
                var switchCase = context.switchCases[index];

                if (!switchCase) {
                    throw new Error('Cannot append as statement has not been assigned yet!');
                }

                if (_.isArray(switchCase)) {
                    switchCase[switchCase.length - 1][CONSEQUENT].push(statementNode);
                } else {
                    switchCase.push(statementNode);
                }
            },

            assign: function (statementNode, nextIndex) {
                var i,
                    switchCases = [];

                for (i = 0; i < transforms.length; i++) {
                    statementNode = transforms[i](statementNode);
                }

                if (!endIndex) {
                    endIndex = context.functionContext.getCurrentStatementIndex();
                }

                for (i = index; i < endIndex - 1; i++) {
                    switchCases.push({
                        type: Syntax.SwitchCase,
                        test: {
                            type: Syntax.Literal,
                            value: i
                        },
                        consequent: i === index ? [
                            acorn.parse('statementIndex = ' + (index + 1) + ';').body[0]
                        ] : []
                    });
                }

                switchCases.push(createSwitchCase(statementNode, endIndex - 1, nextIndex));

                context.switchCases[index] = switchCases;
            },

            captureEndIndex: function () {
                endIndex = context.functionContext.getCurrentStatementIndex();
            },

            getEndIndex: function () {
                return endIndex;
            },

            getIndex: function () {
                return index;
            },

            prepend: function (statementNode) {
                var switchCase = context.switchCases[index];

                if (!switchCase) {
                    throw new Error('Cannot prepend as statement has not been assigned yet!');
                }

                if (_.isArray(switchCase)) {
                    switchCase[switchCase.length - 1][CONSEQUENT].unshift(statementNode);
                } else {
                    switchCase.unshift(statementNode);
                }
            }
        };
    },

    popTransforms: function () {
        this.transforms = this.transformsStack.pop();
    },

    pushTransforms: function () {
        var context = this;

        context.transformsStack.push(context.transforms);
        context.transforms = [];
    },

    transformNextStatement: function (transformer) {
        // Perform the most recent transformation first
        this.transforms.unshift(transformer);
    }
});

module.exports = BlockContext;

},{"acorn":44,"estraverse":18,"microdash":28}],46:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    estraverse = require('estraverse'),
    ELEMENTS = 'elements',
    Syntax = estraverse.Syntax;

function ArrayExpressionTranspiler(statementTranspiler, expressionTranspiler) {
    this.expressionTranspiler = expressionTranspiler;
    this.statementTranspiler = statementTranspiler;
}

_.extend(ArrayExpressionTranspiler.prototype, {
    getNodeType: function () {
        return Syntax.ArrayExpression;
    },

    transpile: function (node, parent, functionContext, blockContext) {
        var transpiler = this;

        return {
            'type': Syntax.ArrayExpression,
            'elements': transpiler.expressionTranspiler.transpileArray(
                node[ELEMENTS],
                node,
                functionContext,
                blockContext
            )
        };
    }
});

module.exports = ArrayExpressionTranspiler;

},{"estraverse":18,"microdash":28}],47:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    estraverse = require('estraverse'),
    LEFT = 'left',
    OPERATOR = 'operator',
    RIGHT = 'right',
    Syntax = estraverse.Syntax;

function AssignmentExpressionTranspiler(statementTranspiler, expressionTranspiler) {
    this.expressionTranspiler = expressionTranspiler;
    this.statementTranspiler = statementTranspiler;
}

_.extend(AssignmentExpressionTranspiler.prototype, {
    getNodeType: function () {
        return Syntax.AssignmentExpression;
    },

    transpile: function (node, parent, functionContext, blockContext) {
        var left,
            right,
            transpiler = this;

        left = transpiler.expressionTranspiler.transpile(node[LEFT], node, functionContext, blockContext, {
            assignment: true
        });

        if (node[OPERATOR] === '=') {
            right = node[RIGHT];
        } else {
            right = {
                'type': Syntax.BinaryExpression,
                'operator': node[OPERATOR].charAt(0),
                'left': node[LEFT],
                'right': node[RIGHT]
            };
        }

        right = transpiler.expressionTranspiler.transpile(right, node, functionContext, blockContext);

        return {
            'type': Syntax.AssignmentExpression,
            'operator': '=',
            'left': left,
            'right': right
        };
    }
});

module.exports = AssignmentExpressionTranspiler;

},{"estraverse":18,"microdash":28}],48:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    estraverse = require('estraverse'),
    LEFT = 'left',
    OPERATOR = 'operator',
    RIGHT = 'right',
    Syntax = estraverse.Syntax;

function BinaryExpressionTranspiler(statementTranspiler, expressionTranspiler) {
    this.expressionTranspiler = expressionTranspiler;
    this.statementTranspiler = statementTranspiler;
}

_.extend(BinaryExpressionTranspiler.prototype, {
    getNodeType: function () {
        return Syntax.BinaryExpression;
    },

    transpile: function (node, parent, functionContext, blockContext) {
        var left,
            right,
            transpiler = this;

        left = transpiler.expressionTranspiler.transpile(node[LEFT], node, functionContext, blockContext);
        right = transpiler.expressionTranspiler.transpile(node[RIGHT], node, functionContext, blockContext);

        return {
            'type': Syntax.BinaryExpression,
            'operator': node[OPERATOR],
            'left': left,
            'right': right
        };
    }
});

module.exports = BinaryExpressionTranspiler;

},{"estraverse":18,"microdash":28}],49:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    estraverse = require('estraverse'),
    ARGUMENTS = 'arguments',
    CALLEE = 'callee',
    OBJECT = 'object',
    TYPE = 'type',
    Syntax = estraverse.Syntax;

function CallExpressionTranspiler(statementTranspiler, expressionTranspiler) {
    this.expressionTranspiler = expressionTranspiler;
    this.statementTranspiler = statementTranspiler;
}

_.extend(CallExpressionTranspiler.prototype, {
    getNodeType: function () {
        return Syntax.CallExpression;
    },

    transpile: function (node, parent, functionContext, blockContext) {
        var args = node[ARGUMENTS],
            assignments,
            callee,
            callNode,
            transpiler = this,
            tempNameForAssignment;

        functionContext.clearLastAssignments();

        callee = transpiler.expressionTranspiler.transpile(node[CALLEE], node, functionContext, blockContext);

        assignments = functionContext.getLastAssignments();

        args = transpiler.expressionTranspiler.transpileArray(args, node, functionContext, blockContext);

        if (node[CALLEE][TYPE] === Syntax.MemberExpression) {
            // Change callee to a '... .call(...)' to preserve thisObj
            args = [
                assignments.length > 1 ?
                    {
                        'type': Syntax.Identifier,
                        'name': assignments[assignments.length - 2]
                    } :
                    node[CALLEE][OBJECT]
            ].concat(args);

            callee = {
                'type': Syntax.MemberExpression,
                'object': callee,
                'property': {
                    'type': Syntax.Identifier,
                    'name': 'call',
                },
                'computed': false
            };
        }

        callNode = {
            'type': Syntax.CallExpression,
            'callee': callee,
            'arguments': args
        };

        if (parent[TYPE] === Syntax.ExpressionStatement) {
            return callNode;
        }

        tempNameForAssignment = functionContext.getTempName();
        blockContext.addAssignment(tempNameForAssignment).assign(callNode);

        return {
            'type': Syntax.Identifier,
            'name': tempNameForAssignment
        };
    }
});

module.exports = CallExpressionTranspiler;

},{"estraverse":18,"microdash":28}],50:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    TYPE = 'type',
    hasOwn = {}.hasOwnProperty;

function ExpressionTranspiler() {
    this.transpilers = {};
}

_.extend(ExpressionTranspiler.prototype, {
    addTranspiler: function (transpiler) {
        this.transpilers[transpiler.getNodeType()] = transpiler;
    },

    transpile: function (node, parent, functionContext, blockContext) {
        var transpiler = this;

        if (!hasOwn.call(transpiler.transpilers, node[TYPE])) {
            return node;
        }

        return transpiler.transpilers[node[TYPE]].transpile(node, parent, functionContext, blockContext);
    },

    transpileArray: function (array, parent, functionContext, blockContext) {
        var result = [],
            transpiler = this;

        _.each(array, function (expressionNode) {
            result.push(transpiler.transpile(expressionNode, parent, functionContext, blockContext));
        });

        return result;
    }
});

module.exports = ExpressionTranspiler;

},{"microdash":28}],51:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    estraverse = require('estraverse'),
    Syntax = estraverse.Syntax;

function FunctionExpressionTranspiler(statementTranspiler, expressionTranspiler, functionTranspiler) {
    this.expressionTranspiler = expressionTranspiler;
    this.functionTranspiler = functionTranspiler;
    this.statementTranspiler = statementTranspiler;
}

_.extend(FunctionExpressionTranspiler.prototype, {
    getNodeType: function () {
        return Syntax.FunctionExpression;
    },

    transpile: function (node, parent, functionContext, blockContext) {
        return this.functionTranspiler.transpile(node, parent, functionContext, blockContext);
    }
});

module.exports = FunctionExpressionTranspiler;

},{"estraverse":18,"microdash":28}],52:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    estraverse = require('estraverse'),
    LEFT = 'left',
    NAME = 'name',
    TYPE = 'type',
    Syntax = estraverse.Syntax;

function IdentifierTranspiler(statementTranspiler, expressionTranspiler) {
    this.expressionTranspiler = expressionTranspiler;
    this.statementTranspiler = statementTranspiler;
}

_.extend(IdentifierTranspiler.prototype, {
    getNodeType: function () {
        return Syntax.Identifier;
    },

    transpile: function (node, parent, functionContext, blockContext) {
        var isDefined = functionContext.hasVariableDefined(node[NAME]) ||
            (
                parent[TYPE] === Syntax.AssignmentExpression &&
                node === parent[LEFT]
            );

        return {
            'type': Syntax.Identifier,
            'name': isDefined ?
                node[NAME] :
                functionContext.getTempNameForVariable(node[NAME], blockContext)
        };
    }
});

module.exports = IdentifierTranspiler;

},{"estraverse":18,"microdash":28}],53:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    estraverse = require('estraverse'),
    BlockContext = require('../BlockContext'),
    LEFT = 'left',
    OPERATOR = 'operator',
    RIGHT = 'right',
    Syntax = estraverse.Syntax;

function LogicalExpressionTranspiler(statementTranspiler, expressionTranspiler) {
    this.expressionTranspiler = expressionTranspiler;
    this.statementTranspiler = statementTranspiler;
}

_.extend(LogicalExpressionTranspiler.prototype, {
    getNodeType: function () {
        return Syntax.LogicalExpression;
    },

    transpile: function (node, parent, functionContext, blockContext) {
        var condition,
            left,
            right,
            rightSideBlockContext,
            statement,
            tempName,
            transpiler = this;

        left = transpiler.expressionTranspiler.transpile(node[LEFT], node, functionContext, blockContext);

        statement = blockContext.prepareStatement();

        rightSideBlockContext = new BlockContext(functionContext);

        right = transpiler.expressionTranspiler.transpile(node[RIGHT], node, functionContext, rightSideBlockContext);

        /**
         * Support short-circuit evaluation of the operands -
         * when '&&' and left operand is truthy, evaluate right,
         * when '||' and left operand is truthy, do not,
         * and vice versa.
         */
        condition = node[OPERATOR] === '||' ?
            {
                'type': Syntax.UnaryExpression,
                'operator': '!',
                'prefix': true,
                'argument': left
            } :
            left;

        statement.assign({
            'type': Syntax.IfStatement,
            'test': {
                'type': Syntax.LogicalExpression,
                'operator': '||',
                'left': {
                    'type': Syntax.BinaryExpression,
                    'operator': '>',
                    'left': {
                        'type': Syntax.Identifier,
                        'name': 'statementIndex'
                    },
                    'right': {
                        'type': Syntax.Literal,
                        'value': statement.getIndex() + 1
                    }
                },
                'right': condition
            },
            'consequent': {
                'type': Syntax.BlockStatement,
                'body': [
                    rightSideBlockContext.getSwitchStatement()
                ]
            }
        });

        tempName = functionContext.getTempName();

        blockContext.addAssignment(tempName).assign({
            'type': Syntax.LogicalExpression,
            'operator': node[OPERATOR],
            'left': left,
            'right': right
        });

        return {
            'type': Syntax.Identifier,
            'name': tempName
        };
    }
});

module.exports = LogicalExpressionTranspiler;

},{"../BlockContext":45,"estraverse":18,"microdash":28}],54:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    estraverse = require('estraverse'),
    COMPUTED = 'computed',
    OBJECT = 'object',
    PROPERTY = 'property',
    TYPE = 'type',
    Syntax = estraverse.Syntax;

function MemberExpressionTranspiler(statementTranspiler, expressionTranspiler) {
    this.expressionTranspiler = expressionTranspiler;
    this.statementTranspiler = statementTranspiler;
}

_.extend(MemberExpressionTranspiler.prototype, {
    getNodeType: function () {
        return Syntax.MemberExpression;
    },

    transpile: function (node, parent, functionContext, blockContext) {
        var memberExpression,
            object = this.expressionTranspiler.transpile(node[OBJECT], node, functionContext, blockContext),
            property = node[COMPUTED] ?
                this.expressionTranspiler.transpile(node[PROPERTY], node, functionContext, blockContext) :
                node[PROPERTY],
            propertyTempName;

        memberExpression = {
            'type': Syntax.MemberExpression,
            'object': object,
            'property': property,
            'computed': node[COMPUTED]
        };

        if (parent[TYPE] === Syntax.AssignmentExpression) {
            return memberExpression;
        }

        propertyTempName = functionContext.getTempName();

        blockContext.addAssignment(propertyTempName).assign(memberExpression);

        return {
            'type': Syntax.Identifier,
            'name': propertyTempName
        };
    }
});

module.exports = MemberExpressionTranspiler;

},{"estraverse":18,"microdash":28}],55:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    estraverse = require('estraverse'),
    PROPERTIES = 'properties',
    Syntax = estraverse.Syntax;

function ObjectExpressionTranspiler(statementTranspiler, expressionTranspiler) {
    this.expressionTranspiler = expressionTranspiler;
    this.statementTranspiler = statementTranspiler;
}

_.extend(ObjectExpressionTranspiler.prototype, {
    getNodeType: function () {
        return Syntax.ObjectExpression;
    },

    transpile: function (node, parent, functionContext, blockContext) {
        var transpiler = this;

        return {
            'type': Syntax.ObjectExpression,
            'properties': transpiler.expressionTranspiler.transpileArray(
                node[PROPERTIES],
                node,
                functionContext,
                blockContext
            )
        };
    }
});

module.exports = ObjectExpressionTranspiler;

},{"estraverse":18,"microdash":28}],56:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    estraverse = require('estraverse'),
    KEY = 'key',
    KIND = 'kind',
    VALUE = 'value',
    Syntax = estraverse.Syntax;

function PropertyTranspiler(statementTranspiler, expressionTranspiler) {
    this.expressionTranspiler = expressionTranspiler;
    this.statementTranspiler = statementTranspiler;
}

_.extend(PropertyTranspiler.prototype, {
    getNodeType: function () {
        return Syntax.Property;
    },

    transpile: function (node, parent, functionContext, blockContext) {
        var transpiler = this;

        return {
            'type': Syntax.Property,
            'key': node[KEY],
            'value': transpiler.expressionTranspiler.transpile(
                node[VALUE],
                node,
                functionContext,
                blockContext
            ),
            'kind': node[KIND]
        };
    }
});

module.exports = PropertyTranspiler;

},{"estraverse":18,"microdash":28}],57:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    estraverse = require('estraverse'),
    EXPRESSIONS = 'expressions',
    Syntax = estraverse.Syntax;

function SequenceExpressionTranspiler(statementTranspiler, expressionTranspiler) {
    this.expressionTranspiler = expressionTranspiler;
    this.statementTranspiler = statementTranspiler;
}

_.extend(SequenceExpressionTranspiler.prototype, {
    getNodeType: function () {
        return Syntax.SequenceExpression;
    },

    transpile: function (node, parent, functionContext, blockContext) {
        var expressions = [],
            transpiler = this;

        _.each(node[EXPRESSIONS], function (expression) {
            expressions.push(
                transpiler.expressionTranspiler.transpile(
                    expression,
                    node,
                    functionContext,
                    blockContext
                )
            );
        });

        return {
            'type': Syntax.SequenceExpression,
            'expressions': expressions
        };
    }
});

module.exports = SequenceExpressionTranspiler;

},{"estraverse":18,"microdash":28}],58:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    estraverse = require('estraverse'),
    ARGUMENT = 'argument',
    COMPUTED = 'computed',
    NAME = 'name',
    OBJECT = 'object',
    OPERATOR = 'operator',
    PREFIX = 'prefix',
    PROPERTY = 'property',
    TYPE = 'type',
    Syntax = estraverse.Syntax;

function UpdateExpressionTranspiler(statementTranspiler, expressionTranspiler) {
    this.expressionTranspiler = expressionTranspiler;
    this.statementTranspiler = statementTranspiler;
}

_.extend(UpdateExpressionTranspiler.prototype, {
    getNodeType: function () {
        return Syntax.UpdateExpression;
    },

    transpile: function (node, parent, functionContext, blockContext) {
        var expression,
            object = null,
            objectTempName = null,
            resultTempName;

        if (node[ARGUMENT][TYPE] === Syntax.MemberExpression) {
            object = this.expressionTranspiler.transpile(
                node[ARGUMENT][OBJECT],
                node,
                functionContext,
                blockContext
            );
            object = {
                'type': Syntax.MemberExpression,
                'object': object,
                'property': node[ARGUMENT][COMPUTED] ?
                    this.expressionTranspiler.transpile(
                        node[ARGUMENT][PROPERTY],
                        node[ARGUMENT],
                        functionContext,
                        blockContext
                    ) :
                    node[ARGUMENT][PROPERTY],
                'computed': node[ARGUMENT][COMPUTED]
            };
            objectTempName = functionContext.getTempName();
            blockContext.addAssignment(objectTempName).assign(object);
            expression = {
                'type': Syntax.Identifier,
                'name': objectTempName
            };
        } else {
            expression = this.expressionTranspiler.transpile(
                node[ARGUMENT],
                node,
                functionContext,
                blockContext
            );
        }

        // Addition/subtraction of 1
        resultTempName = functionContext.getTempName();
        blockContext.addAssignment(resultTempName).assign({
            'type': Syntax.BinaryExpression,
            'left': expression,
            'operator': node[OPERATOR].charAt(0),
            'right': {
                'type': Syntax.Literal,
                'value': 1
            }
        });

        // Assignment back to variable/property
        blockContext.prepareStatement().assign({
            'type': Syntax.ExpressionStatement,
            'expression': {
                'type': Syntax.AssignmentExpression,
                'left': object ? object : node[ARGUMENT],
                'operator': '=',
                'right': {
                    'type': Syntax.Identifier,
                    'name': resultTempName
                }
            }
        });

        return {
            'type': Syntax.Identifier,
            'name': node[PREFIX] ?
                resultTempName :
                functionContext.getLastTempNameForVariable(node[ARGUMENT][NAME])
        };
    }
});

module.exports = UpdateExpressionTranspiler;

},{"estraverse":18,"microdash":28}],59:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    acorn = require('acorn'),
    estraverse = require('estraverse'),
    hasOwn = {}.hasOwnProperty,
    DECLARATIONS = 'declarations',
    ID = 'id',
    NAME = 'name',
    LabelableContext = require('./LabelableContext'),
    Syntax = estraverse.Syntax;

function FunctionContext() {
    this.assignmentVariables = {};
    this.catches = [];
    this.functionDeclarations = [];
    this.hasFinally = false;
    this.labelableContext = null;
    this.labelableContextStack = [];
    this.lastAssignments = [];
    this.lastTempNames = {};
    this.nextStatementIndex = 0;
    this.nextTempIndex = 0;
    this.parameters = [];
    this.variables = [];
}

_.extend(FunctionContext.prototype, {
    addAssignment: function (index, variableName) {
        var context = this;

        context.assignmentVariables[index] = variableName;
        context.lastAssignments.push(variableName);
    },

    addCatch: function (data) {
        this.catches.push(data);
    },

    addFinally: function () {
        var context = this;

        if (context.hasFinally) {
            return;
        }

        context.addVariable('resumableUncaughtError');
        context.hasFinally = true;
    },

    addFunctionDeclaration: function (declaration) {
        this.functionDeclarations.push(declaration);
    },

    addParameter: function (name) {
        this.parameters.push(name);
    },

    addVariable: function (name) {
        this.variables.push(name);
    },

    clearLastAssignments: function () {
        this.lastAssignments = [];
    },

    getCurrentStatementIndex: function () {
        return this.nextStatementIndex;
    },

    getLabel: function () {
        var context = this,
            labelableContext = context.labelableContext;

        return labelableContext.getPrefixedLabel();
    },

    getLabelableContext: function (label) {
        var context = this,
            i;

        if (!label) {
            return context.labelableContext;
        }

        if (context.labelableContext.getLabel() === label) {
            return context.labelableContext;
        }

        for (i = context.labelableContextStack.length - 1; i >= 0; i--) {
            if (context.labelableContextStack[i].getLabel() === label) {
                return context.labelableContextStack[i];
            }
        }

        return null;
    },

    getLabeledStatement: function (statementNode) {
        return this.labelableContext.getLabeledStatement(statementNode);
    },

    getLastAssignments: function () {
        var context = this,
            lastAssignments = context.lastAssignments;

        context.lastAssignments = [];

        return lastAssignments;
    },

    getNextStatementIndex: function () {
        return this.nextStatementIndex++;
    },

    getStatements: function (switchStatement) {
        var assignmentProperties = [],
            catchesProperties,
            declaration = acorn.parse('var statementIndex = 0;').body[0],
            functionContext = this,
            functionSetup = [],
            index,
            statements = [],
            stateProperties = [],
            stateSetup = acorn.parse('if (Resumable._resumeState_) { statementIndex = Resumable._resumeState_.statementIndex; }').body[0];

        _.each(functionContext.variables, function (name) {
            declaration[DECLARATIONS].push({
                'type': Syntax.VariableDeclarator,
                'id': {
                    'type': Syntax.Identifier,
                    'name': name
                },
                'init': null
            });
        });

        if (functionContext.catches.length > 0) {
            catchesProperties = [];
            _.each(functionContext.catches, function (catchData) {
                catchesProperties.push({
                    'type': Syntax.Property,
                    'kind': 'init',
                    'key': {
                        'type': Syntax.Identifier,
                        'name': catchData.catchStatementIndex
                    },
                    'value': {
                        type: Syntax.ObjectExpression,
                        properties: [
                            {
                                'type': Syntax.Property,
                                'kind': 'init',
                                'key': {
                                    'type': Syntax.Identifier,
                                    'name': 'from'
                                },
                                'value': {
                                    type: Syntax.Literal,
                                    value: catchData.tryStartIndex
                                }
                            },
                            {
                                'type': Syntax.Property,
                                'kind': 'init',
                                'key': {
                                    'type': Syntax.Identifier,
                                    'name': 'to'
                                },
                                'value': {
                                    type: Syntax.Literal,
                                    value: catchData.tryEndIndex
                                }
                            },
                            {
                                'type': Syntax.Property,
                                'kind': 'init',
                                'key': {
                                    'type': Syntax.Identifier,
                                    'name': 'param'
                                },
                                'value': {
                                    type: Syntax.Literal,
                                    value: catchData.catchParameter
                                }
                            }
                        ]
                    }
                });
            });

            stateProperties.push({
                'type': Syntax.Property,
                'kind': 'init',
                'key': {
                    'type': Syntax.Identifier,
                    'name': 'catches'
                },
                'value': {
                    type: Syntax.ObjectExpression,
                    properties: catchesProperties
                }
            });
        }

        if (functionContext.hasFinally) {
            functionSetup.push({
                'type': Syntax.VariableDeclaration,
                'declarations': [{
                    'type': Syntax.VariableDeclarator,
                    'id': {
                        'type': Syntax.Identifier,
                        'name': 'resumablePause'
                    },
                    'init': {
                        'type': Syntax.Literal,
                        'value': null
                    }
                }],
                'kind': 'var'
            });
        }

        for (index = 0; index < functionContext.nextTempIndex; index++) {
            stateProperties.push({
                'type': Syntax.Property,
                'kind': 'init',
                'key': {
                    'type': Syntax.Identifier,
                    'name': 'temp' + index
                },
                'value': {
                    'type': Syntax.Identifier,
                    'name': 'temp' + index
                }
            });

            declaration.declarations.push({
                'type': Syntax.VariableDeclarator,
                'id': {
                    'type': Syntax.Identifier,
                    'name': 'temp' + index
                },
                'init': null
            });

            stateSetup.consequent.body.push({
                'type': Syntax.ExpressionStatement,
                'expression': {
                    'type': Syntax.AssignmentExpression,
                    'operator': '=',
                    'left': {
                        'type': Syntax.Identifier,
                        'name': 'temp' + index,
                    },
                    'right': acorn.parse('Resumable._resumeState_.temp' + index).body[0].expression
                }
            });
        }

        stateSetup.consequent.body.push(acorn.parse('Resumable._resumeState_ = null;').body[0]);

        _.forOwn(functionContext.assignmentVariables, function (variableName, statementIndex) {
            assignmentProperties.push({
                'type': Syntax.Property,
                'kind': 'init',
                'key': {
                    'type': Syntax.Literal,
                    'value': statementIndex
                },
                'value': {
                    'type': Syntax.Literal,
                    'value': variableName
                }
            });
        });

        statements.push(declaration);
        [].push.apply(statements, functionContext.functionDeclarations);
        statements.push({
            type: Syntax.ReturnStatement,
            argument: {
                type: Syntax.CallExpression,
                arguments: [
                    {
                        type: Syntax.ThisExpression
                    },
                    {
                        type: Syntax.Identifier,
                        name: 'arguments'
                    }
                ],
                callee: {
                    type: Syntax.MemberExpression,
                    object: {
                        type: Syntax.FunctionExpression,
                        id: {
                            type: Syntax.Identifier,
                            name: 'resumableScope'
                        },
                        params: [],
                        body: {
                            type: Syntax.BlockStatement,
                            body: functionSetup.concat([
                                stateSetup,
                                {
                                    type: Syntax.TryStatement,
                                    block: {
                                        type: Syntax.BlockStatement,
                                        body: [
                                            switchStatement
                                        ]
                                    },
                                    handler: {
                                        type: Syntax.CatchClause,
                                        param: {
                                            type: Syntax.Identifier,
                                            name: 'e'
                                        },
                                        body: {
                                            type: Syntax.BlockStatement,
                                            body: [
                                                {
                                                    type: Syntax.IfStatement,
                                                    test: acorn.parse('e instanceof Resumable.PauseException').body[0].expression,
                                                    consequent: {
                                                        type: Syntax.BlockStatement,
                                                        body: [
                                                            {
                                                                type: Syntax.ExpressionStatement,
                                                                expression: {
                                                                    type: Syntax.CallExpression,
                                                                    callee: {
                                                                        type: Syntax.MemberExpression,
                                                                        object: {
                                                                            type: Syntax.Identifier,
                                                                            name: 'e'
                                                                        },
                                                                        property: {
                                                                            type: Syntax.Identifier,
                                                                            name: 'add'
                                                                        },
                                                                        computed: false
                                                                    },
                                                                    arguments: [
                                                                        {
                                                                            type: Syntax.ObjectExpression,
                                                                            properties: [
                                                                                {
                                                                                    type: Syntax.Property,
                                                                                    kind: 'init',
                                                                                    key: {
                                                                                        type: Syntax.Identifier,
                                                                                        name: 'func'
                                                                                    },
                                                                                    value: {
                                                                                        type: Syntax.Identifier,
                                                                                        name: 'resumableScope'
                                                                                    }
                                                                                },
                                                                                {
                                                                                    type: Syntax.Property,
                                                                                    kind: 'init',
                                                                                    key: {
                                                                                        type: Syntax.Identifier,
                                                                                        name: 'statementIndex'
                                                                                    },
                                                                                    value: {
                                                                                        type: Syntax.BinaryExpression,
                                                                                        operator: '+',
                                                                                        left: {
                                                                                            type: Syntax.Identifier,
                                                                                            name: 'statementIndex'
                                                                                        },
                                                                                        right: {
                                                                                            type: Syntax.Literal,
                                                                                            value: 1
                                                                                        }
                                                                                    }
                                                                                },
                                                                                {
                                                                                    type: Syntax.Property,
                                                                                    kind: 'init',
                                                                                    key: {
                                                                                        type: Syntax.Identifier,
                                                                                        name: 'assignments'
                                                                                    },
                                                                                    value: {
                                                                                        type: Syntax.ObjectExpression,
                                                                                        properties: assignmentProperties
                                                                                    }
                                                                                }
                                                                            ].concat(stateProperties)
                                                                        }
                                                                    ]
                                                                }
                                                            }
                                                        ]
                                                    }
                                                },
                                                {
                                                    type: Syntax.ThrowStatement,
                                                    argument: {
                                                        type: Syntax.Identifier,
                                                        name: 'e'
                                                    }
                                                }
                                            ]
                                        }
                                    }
                                }
                            ])
                        }
                    },
                    property: {
                        type: Syntax.Identifier,
                        name: 'apply'
                    }
                }
            }
        });

        return statements;
    },

    getTempName: function () {
        return 'temp' + this.nextTempIndex++;
    },

    getTempNameForVariable: function (variableName, blockContext) {
        var context = this,
            tempName;

        tempName = context.getTempName();

        context.lastTempNames[variableName] = tempName;

        blockContext.addAssignment(tempName).assign({
            'type': Syntax.Identifier,
            'name': variableName
        });

        return tempName;
    },

    getLastTempName: function () {
        return 'temp' + (this.nextTempIndex - 1);
    },

    getLastTempNameForVariable: function (variableName) {
        var context = this;

        // Return the variable's name if it has not been assigned a temporary variable
        if (!hasOwn.call(context.lastTempNames, variableName)) {
            return variableName;
        }

        return context.lastTempNames[variableName];
    },

    hasVariableDefined: function (name) {
        var isDefined = false;

        _.each(this.functionDeclarations, function (functionDeclaration) {
            if (functionDeclaration[ID] && functionDeclaration[ID][NAME] === name) {
                isDefined = true;
                return false;
            }
        });

        _.each(this.variables, function (variable) {
            if (variable === name) {
                isDefined = true;
            }
        });

        return isDefined;
    },

    popLabelableContext: function () {
        var context = this;

        context.labelableContext = context.labelableContextStack.pop();
    },

    pushLabelableContext: function (label) {
        var context = this,
            labelableContextIndex = context.labelableContextStack.length,
            labelableContext = new LabelableContext(label, labelableContextIndex);

        context.labelableContextStack.push(context.labelableContext);
        context.labelableContext = labelableContext;

        return labelableContext;
    }
});

module.exports = FunctionContext;

},{"./LabelableContext":61,"acorn":44,"estraverse":18,"microdash":28}],60:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    estraverse = require('estraverse'),
    BlockContext = require('./BlockContext'),
    FunctionContext = require('./FunctionContext'),
    BODY = 'body',
    ID = 'id',
    NAME = 'name',
    PARAMS = 'params',
    TYPE = 'type',
    Syntax = estraverse.Syntax;

function FunctionTranspiler(statementTranspiler) {
    this.statementTranspiler = statementTranspiler;
}

_.extend(FunctionTranspiler.prototype, {
    transpile: function (node) {
        var newNode,
            transpiler = this,
            ownFunctionContext = new FunctionContext(),
            ownBlockContext = new BlockContext(ownFunctionContext),
            statements = [];

        _.each(node[PARAMS], function (param) {
            ownFunctionContext.addParameter(param[NAME]);
        });

        if (node[BODY][BODY].length > 0) {
            transpiler.statementTranspiler.transpileArray(node[BODY][BODY], node, ownFunctionContext, ownBlockContext);
            statements = ownFunctionContext.getStatements(ownBlockContext.getSwitchStatement());
        }

        newNode = {
            'type': node[TYPE],
            'id': node[ID],
            'params': node[PARAMS],
            'body': {
                'type': Syntax.BlockStatement,
                'body': statements
            }
        };

        return newNode;
    }
});

module.exports = FunctionTranspiler;

},{"./BlockContext":45,"./FunctionContext":59,"estraverse":18,"microdash":28}],61:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    estraverse = require('estraverse'),
    Syntax = estraverse.Syntax;

/**
 * @param {string|null} label
 * @param {int} index
 * @constructor
 */
function LabelableContext(label, index) {
    this.continueStatements = [];
    this.index = index;
    this.label = label;
    this.labelAssigned = label || null;
    this.labelUsed = false;
}

_.extend(LabelableContext.prototype, {
    /**
     * Adds a new `continue` statement to the list for this context
     *
     * @param {object} statement
     */
    addContinue: function (statement) {
        this.continueStatements.push(statement);
    },

    /**
     * Returns the original label used for this context, if set
     * (will be null if no label was set)
     *
     * @returns {string|null}
     */
    getLabel: function () {
        return this.label;
    },

    /**
     * Returns the label to use in the generated output code.
     * Will be the assigned label prefixed with `label_*` or a generated name
     * in the form `labelN` if no label was explicitly specified
     *
     * @returns {string}
     */
    getPrefixedLabel: function () {
        var context = this;

        context.labelUsed = true;

        return context.labelAssigned !== null ?
            'label_' + context.labelAssigned :
            'label' + context.index;
    },

    /**
     * Surrounds an AST statement node with a labeled statement for this context, if needed
     *
     * @param {object} statementNode
     * @returns {object}
     */
    getLabeledStatement: function (statementNode) {
        var context = this;

        if (!context.labelUsed || context.labelAssigned !== null) {
            return statementNode;
        }

        return {
            'type': Syntax.LabeledStatement,
            'label': {
                'type': Syntax.Identifier,
                'name': context.getPrefixedLabel()
            },
            'body': statementNode
        };
    },

    /**
     * Prefixes all `continue` statements in the labelable context with a jump to the provided statement
     *
     * @param {int} targetStatementIndex
     */
    prefixContinuesWithJumpTo: function (targetStatementIndex) {
        var context = this;

        _.each(context.continueStatements, function (continueStatement) {
            continueStatement.prepend({
                'type': Syntax.ExpressionStatement,
                'expression': {
                    'type': Syntax.AssignmentExpression,
                    'operator': '=',
                    'left': {
                        'type': Syntax.Identifier,
                        'name': 'statementIndex'
                    },
                    'right': {
                        'type': Syntax.Literal,
                        'value': targetStatementIndex
                    }
                }
            });
        });
    }
});

module.exports = LabelableContext;

},{"estraverse":18,"microdash":28}],62:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    util = require('util');

function PauseException(resumer) {
    this.message = 'PauseException';
    this.reject = null;
    this.resolve = null;
    this.resumer = resumer;
    this.states = [];
}

util.inherits(PauseException, Error);

_.extend(PauseException.prototype, {
    add: function (state) {
        this.states.push(state);
    },

    now: function () {
        throw this;
    },

    resume: function (result) {
        var exception = this;

        try {
            exception.resumer(exception.resolve, exception.reject, null, result, exception.states);
        } catch (e) {
            // Just re-throw if another PauseException gets raised,
            // we're just looking for normal errors
            if (e instanceof PauseException) {
                throw e;
            }

            // Reject the promise for the run with the error thrown
            exception.reject(e);
        }
    },

    setPromise: function (resolve, reject) {
        var exception = this;

        exception.resolve = resolve;
        exception.reject = reject;
    },

    throw: function (error) {
        var exception = this;

        try {
            exception.resumer(exception.resolve, exception.reject, error, null, exception.states);
        } catch (e) {
            // Just re-throw if another PauseException gets raised,
            // we're just looking for normal errors
            if (e instanceof PauseException) {
                throw e;
            }

            // Reject the promise for the run with the error thrown
            exception.reject(e);
        }
    }
});

module.exports = PauseException;

},{"microdash":28,"util":172}],63:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    escodegen = require('escodegen'),
    acorn = require('acorn'),
    PauseException = require('./PauseException'),
    Promise = require('lie'),
    ResumeException = require('./ResumeException'),
    FROM = 'from',
    PARAM = 'param',
    STRICT = 'strict',
    TO = 'to';

function Resumable(transpiler) {
    this.transpiler = transpiler;
}

_.extend(Resumable, {
    _resumeState_: null,
    PauseException: PauseException,
    ResumeException: ResumeException
});

_.extend(Resumable.prototype, {
    call: function (func, args, thisObj) {
        return new Promise(function (resolve, reject) {
            var result;

            try {
                result = func.apply(thisObj, args);
            } catch (e) {
                if (e instanceof PauseException) {
                    e.setPromise(resolve, reject);
                } else {
                    reject(e);
                }

                return;
            }

            resolve(result);
        });
    },

    callSync: function (func, args, thisObj) {
        var result;

        try {
            result = func.apply(thisObj, args);
        } catch (e) {
            if (e instanceof PauseException) {
                throw new Error('Resumable.callSync() :: Main thread must not pause');
            }

            throw e;
        }

        return result;
    },

    createPause: function () {
        var pause = new PauseException(function (resolve, reject, error, result, states) {
                var i = 0,
                    lastResult = result,
                    state;

                if (error) {
                    /*jshint loopfunc: true */
                    for (; i < states.length; i++) {
                        state = states[i];

                        _.each(state.catches, function (data, catchStatementIndex) {
                            if (state.statementIndex < data[FROM] || state.statementIndex > data[TO]) {
                                return;
                            }

                            state.statementIndex = catchStatementIndex * 1;
                            state[data[PARAM]] = error;
                            error = null;

                            Resumable._resumeState_ = state;

                            try {
                                lastResult = state.func();
                            } catch (e) {
                                if (e instanceof PauseException) {
                                    e.setPromise(resolve, reject);

                                    return false;
                                }

                                throw e;
                            }

                            return false;
                        });

                        if (error === null) {
                            break;
                        }
                    }

                    if (i === states.length) {
                        // Error was not handled by anything up the call stack
                        reject(error);
                        return;
                    }
                }

                function handleNextState() {
                    if (i === states.length) {
                        resolve(lastResult);
                        return;
                    }

                    state = states[i];
                    i++;

                    if (state.assignments[state.statementIndex - 1]) {
                        state[state.assignments[state.statementIndex - 1]] = lastResult;
                    }

                    Resumable._resumeState_ = state;

                    try {
                        lastResult = state.func();
                    } catch (e) {
                        if (e instanceof PauseException) {
                            e.setPromise(
                                function (result) {
                                    lastResult = result;
                                    handleNextState();
                                },
                                function (error) {
                                    // FIXME: Probably needs to call catch handlers
                                    reject(error);
                                }
                            );

                            return;
                        }

                        throw e;
                    }

                    handleNextState();
                }

                handleNextState();
            });

        return pause;
    },

    execute: function (code, options) {
        var ast = acorn.parse(code, {'allowReturnOutsideFunction': true}),
            expose,
            func,
            names = ['Resumable'],
            resumable = this,
            transpiledCode,
            values = [Resumable];

        options = options || {};
        expose = options.expose || {};

        _.forOwn(expose, function (value, name) {
            names.push(name);
            values.push(value);
        });

        ast = resumable.transpiler.transpile(ast);

        transpiledCode = escodegen.generate(ast, {
            format: {
                indent: {
                    style: '    ',
                    base: 0
                }
            }
        });

        transpiledCode = 'return ' + transpiledCode;

        if (options[STRICT]) {
            transpiledCode = '"use strict"; ' + transpiledCode;
        }

        /*jshint evil:true */
        func = new Function(names, transpiledCode);

        return resumable.call(func.apply(null, values), [], null);
    },

    executeSync: function (args, fn, options) {
        var code = 'return ' + fn.toString(),
            ast = acorn.parse(code, {'allowReturnOutsideFunction': true}),
            expose,
            func,
            names = ['Resumable'],
            resumable = this,
            transpiledCode,
            values = [Resumable];

        options = options || {};
        expose = options.expose || {};

        _.forOwn(expose, function (value, name) {
            names.push(name);
            values.push(value);
        });

        ast = resumable.transpiler.transpile(ast);

        transpiledCode = escodegen.generate(ast, {
            format: {
                indent: {
                    style: '    ',
                    base: 0
                }
            }
        });

        transpiledCode = 'return ' + transpiledCode;

        if (options[STRICT]) {
            transpiledCode = '"use strict"; ' + transpiledCode;
        }

        /*jshint evil:true */
        func = new Function(names, transpiledCode);

        return resumable.callSync(func.apply(null, values)(), args, null);
    }
});

module.exports = Resumable;

},{"./PauseException":62,"./ResumeException":64,"acorn":44,"escodegen":3,"lie":27,"microdash":28}],64:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var util = require('util');

function ResumeException(error) {
    this.error = error;
}

util.inherits(ResumeException, Error);

module.exports = ResumeException;

},{"util":172}],65:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    estraverse = require('estraverse'),
    BlockContext = require('../BlockContext'),
    BODY = 'body',
    Syntax = estraverse.Syntax;

function BlockStatementTranspiler(statementTranspiler, expressionTranspiler) {
    this.expressionTranspiler = expressionTranspiler;
    this.statementTranspiler = statementTranspiler;
}

_.extend(BlockStatementTranspiler.prototype, {
    getNodeType: function () {
        return Syntax.BlockStatement;
    },

    transpile: function (node, parent, functionContext, blockContext) {
        var transpiler = this,
            ownBlockContext = new BlockContext(functionContext),
            statement = blockContext.prepareStatement();

        transpiler.statementTranspiler.transpileArray(node[BODY], node, functionContext, ownBlockContext);

        statement.assign({
            'type': Syntax.BlockStatement,
            'body': [
                ownBlockContext.getSwitchStatement()
            ]
        });
    }
});

module.exports = BlockStatementTranspiler;

},{"../BlockContext":45,"estraverse":18,"microdash":28}],66:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    estraverse = require('estraverse'),
    LABEL = 'label',
    NAME = 'name',
    Syntax = estraverse.Syntax;

function BreakStatementTranspiler(statementTranspiler, expressionTranspiler) {
    this.expressionTranspiler = expressionTranspiler;
    this.statementTranspiler = statementTranspiler;
}

_.extend(BreakStatementTranspiler.prototype, {
    getNodeType: function () {
        return Syntax.BreakStatement;
    },

    transpile: function (node, parent, functionContext, blockContext) {
        var label = {
                'type': Syntax.Identifier,
                'name': node[LABEL] ?
                    'label_' + node[LABEL][NAME] :
                    functionContext.getLabel()
            };

        blockContext.prepareStatement().assign({
            'type': Syntax.BreakStatement,
            'label': label
        }, null);
    }
});

module.exports = BreakStatementTranspiler;

},{"estraverse":18,"microdash":28}],67:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    estraverse = require('estraverse'),
    LABEL = 'label',
    NAME = 'name',
    Syntax = estraverse.Syntax;

function ContinueStatementTranspiler(statementTranspiler, expressionTranspiler) {
    this.expressionTranspiler = expressionTranspiler;
    this.statementTranspiler = statementTranspiler;
}

_.extend(ContinueStatementTranspiler.prototype, {
    getNodeType: function () {
        return Syntax.ContinueStatement;
    },

    transpile: function (node, parent, functionContext, blockContext) {
        var continueStatement,
            labelNode = {
                'type': Syntax.Identifier,
                'name': node[LABEL] ?
                    'label_' + node[LABEL][NAME] :
                    functionContext.getLabel()
            },
            label = node[LABEL] !== null ? node[LABEL][NAME] : null,
            labelableContext = functionContext.getLabelableContext(label);

        continueStatement = blockContext.prepareStatement();
        labelableContext.addContinue(continueStatement);

        continueStatement.assign({
            'type': Syntax.ContinueStatement,
            'label': labelNode
        }, null);
    }
});

module.exports = ContinueStatementTranspiler;

},{"estraverse":18,"microdash":28}],68:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    estraverse = require('estraverse'),
    Syntax = estraverse.Syntax;

function DebuggerStatementTranspiler(statementTranspiler, expressionTranspiler) {
    this.expressionTranspiler = expressionTranspiler;
    this.statementTranspiler = statementTranspiler;
}

_.extend(DebuggerStatementTranspiler.prototype, {
    getNodeType: function () {
        return Syntax.DebuggerStatement;
    },

    transpile: function (node, parent, functionContext, blockContext) {
        blockContext.prepareStatement().assign({
            'type': Syntax.DebuggerStatement
        });
    }
});

module.exports = DebuggerStatementTranspiler;

},{"estraverse":18,"microdash":28}],69:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    acorn = require('acorn'),
    estraverse = require('estraverse'),
    BlockContext = require('../BlockContext'),
    BODY = 'body',
    LABEL = 'label',
    NAME = 'name',
    TEST = 'test',
    TYPE = 'type',
    Syntax = estraverse.Syntax;

function DoWhileStatementTranspiler(statementTranspiler, expressionTranspiler) {
    this.expressionTranspiler = expressionTranspiler;
    this.statementTranspiler = statementTranspiler;
}

_.extend(DoWhileStatementTranspiler.prototype, {
    getNodeType: function () {
        return Syntax.DoWhileStatement;
    },

    transpile: function (node, parent, functionContext, blockContext) {
        var forNode,
            ownBlockContext = new BlockContext(functionContext),
            transpiler = this,
            expression,
            statement,
            label = parent[TYPE] === Syntax.LabeledStatement ?
                parent[LABEL][NAME] :
                null;

        functionContext.pushLabelableContext(label);

        statement = blockContext.prepareStatement();

        transpiler.statementTranspiler.transpileArray(node[BODY][BODY], node, functionContext, ownBlockContext);

        expression = transpiler.expressionTranspiler.transpile(node[TEST], node, functionContext, ownBlockContext);

        ownBlockContext.prepareStatement().assign({
            'type': Syntax.IfStatement,
            'test': {
                'type': Syntax.UnaryExpression,
                'operator': '!',
                'prefix': true,
                'argument': expression
            },
            'consequent': {
                'type': Syntax.BlockStatement,
                'body': [
                    {
                        'type': Syntax.BreakStatement,
                        'label': {
                            'type': Syntax.Identifier,
                            'name': functionContext.getLabel()
                        }
                    }
                ]
            }
        });

        forNode = {
            'type': Syntax.ForStatement,
            'init': null,
            'test': null,
            'update': null,
            'body': {
                'type': Syntax.BlockStatement,
                'body': [
                    acorn.parse('statementIndex = ' + (statement.getIndex() + 1) + ';').body[0],
                    ownBlockContext.getSwitchStatement()
                ]
            }
        };

        statement.assign(functionContext.getLabeledStatement(forNode));

        functionContext.popLabelableContext();
    }
});

module.exports = DoWhileStatementTranspiler;

},{"../BlockContext":45,"acorn":44,"estraverse":18,"microdash":28}],70:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    estraverse = require('estraverse'),
    Syntax = estraverse.Syntax;

function EmptyStatementTranspiler(statementTranspiler, expressionTranspiler) {
    this.expressionTranspiler = expressionTranspiler;
    this.statementTranspiler = statementTranspiler;
}

_.extend(EmptyStatementTranspiler.prototype, {
    getNodeType: function () {
        return Syntax.EmptyStatement;
    },

    transpile: function () {
        // Discard empty statements
    }
});

module.exports = EmptyStatementTranspiler;

},{"estraverse":18,"microdash":28}],71:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    estraverse = require('estraverse'),
    EXPRESSION = 'expression',
    Syntax = estraverse.Syntax;

function ExpressionStatementTranspiler(statementTranspiler, expressionTranspiler) {
    this.expressionTranspiler = expressionTranspiler;
    this.statementTranspiler = statementTranspiler;
}

_.extend(ExpressionStatementTranspiler.prototype, {
    getNodeType: function () {
        return Syntax.ExpressionStatement;
    },

    transpile: function (node, parent, functionContext, blockContext) {
        var expression = this.expressionTranspiler.transpile(node[EXPRESSION], node, functionContext, blockContext);

        blockContext.prepareStatement().assign({
            'type': Syntax.ExpressionStatement,
            'expression': expression
        });
    }
});

module.exports = ExpressionStatementTranspiler;

},{"estraverse":18,"microdash":28}],72:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    acorn = require('acorn'),
    estraverse = require('estraverse'),
    BlockContext = require('../BlockContext'),
    BODY = 'body',
    INIT = 'init',
    LABEL = 'label',
    NAME = 'name',
    TEST = 'test',
    TYPE = 'type',
    UPDATE = 'update',
    Syntax = estraverse.Syntax;

function ForStatementTranspiler(statementTranspiler, expressionTranspiler) {
    this.expressionTranspiler = expressionTranspiler;
    this.statementTranspiler = statementTranspiler;
}

_.extend(ForStatementTranspiler.prototype, {
    getNodeType: function () {
        return Syntax.ForStatement;
    },

    transpile: function (node, parent, functionContext, blockContext) {
        var forNode,
            ownBlockContext = new BlockContext(functionContext),
            transpiler = this,
            expression,
            statement,
            label = parent[TYPE] === Syntax.LabeledStatement ?
                parent[LABEL][NAME] :
                null,
            labelableContext,
            updateIndex;

        labelableContext = functionContext.pushLabelableContext(label);

        // 'Init' expression
        if (node[INIT]) {
            blockContext.pushTransforms();

            // Init can be a variable declaration, eg. `for (var i = 0; ...)`
            if (node[INIT][TYPE] === Syntax.VariableDeclaration) {
                transpiler.statementTranspiler.transpile(
                    node[INIT],
                    node,
                    functionContext,
                    blockContext
                );
            } else {
                expression = transpiler.expressionTranspiler.transpile(
                    node[INIT],
                    node,
                    functionContext,
                    blockContext
                );
                blockContext.prepareStatement().assign({
                    'type': Syntax.ExpressionStatement,
                    'expression': expression
                });
            }
            blockContext.popTransforms();
        }

        statement = blockContext.prepareStatement();

        // 'Test' expression
        if (node[TEST]) {
            expression = transpiler.expressionTranspiler.transpile(
                node[TEST],
                node,
                functionContext,
                ownBlockContext
            );
            ownBlockContext.prepareStatement().assign({
                'type': Syntax.IfStatement,
                'test': {
                    'type': Syntax.UnaryExpression,
                    'operator': '!',
                    'prefix': true,
                    'argument': expression
                },
                'consequent': {
                    'type': Syntax.BlockStatement,
                    'body': [
                        {
                            'type': Syntax.BreakStatement,
                            'label': {
                                'type': Syntax.Identifier,
                                'name': functionContext.getLabel()
                            }
                        }
                    ]
                }
            });
        }

        transpiler.statementTranspiler.transpileArray(
            node[BODY][BODY],
            node,
            functionContext,
            ownBlockContext
        );

        // 'Update' expression
        if (node[UPDATE]) {
            updateIndex = functionContext.getCurrentStatementIndex();
            expression = transpiler.expressionTranspiler.transpile(
                node[UPDATE],
                node,
                functionContext,
                ownBlockContext
            );
            ownBlockContext.prepareStatement().assign({
                'type': Syntax.ExpressionStatement,
                'expression': expression
            });

            labelableContext.prefixContinuesWithJumpTo(updateIndex);
        }

        forNode = {
            'type': Syntax.ForStatement,
            'init': null,
            'test': null,
            'update': null,
            'body': {
                'type': Syntax.BlockStatement,
                'body': [
                    ownBlockContext.getSwitchStatement(),
                    acorn.parse('statementIndex = ' + (statement.getIndex() + 1) + ';').body[0]
                ]
            }
        };

        statement.assign(functionContext.getLabeledStatement(forNode));

        functionContext.popLabelableContext();
    }
});

module.exports = ForStatementTranspiler;

},{"../BlockContext":45,"acorn":44,"estraverse":18,"microdash":28}],73:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    estraverse = require('estraverse'),
    Syntax = estraverse.Syntax;

function FunctionDeclarationTranspiler(statementTranspiler, expressionTranspiler, functionTranspiler) {
    this.expressionTranspiler = expressionTranspiler;
    this.functionTranspiler = functionTranspiler;
    this.statementTranspiler = statementTranspiler;
}

_.extend(FunctionDeclarationTranspiler.prototype, {
    getNodeType: function () {
        return Syntax.FunctionDeclaration;
    },

    transpile: function (node, parent, functionContext, blockContext) {
        var newNode = this.functionTranspiler.transpile(node, parent, functionContext, blockContext);

        functionContext.addFunctionDeclaration(newNode);
    }
});

module.exports = FunctionDeclarationTranspiler;

},{"estraverse":18,"microdash":28}],74:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    estraverse = require('estraverse'),
    ALTERNATE = 'alternate',
    CONSEQUENT = 'consequent',
    TEST = 'test',
    Syntax = estraverse.Syntax;

function IfStatementTranspiler(statementTranspiler, expressionTranspiler) {
    this.expressionTranspiler = expressionTranspiler;
    this.statementTranspiler = statementTranspiler;
}

_.extend(IfStatementTranspiler.prototype, {
    getNodeType: function () {
        return Syntax.IfStatement;
    },

    transpile: function (node, parent, functionContext, blockContext) {
        var alternateStatement,
            consequentStatement,
            transpiler = this,
            expression = transpiler.expressionTranspiler.transpile(node[TEST], node, functionContext, blockContext);

        consequentStatement = blockContext.prepareStatement();

        consequentStatement.assign({
            'type': Syntax.IfStatement,
            'test': {
                'type': Syntax.LogicalExpression,
                'operator': '||',
                'left': {
                    'type': Syntax.BinaryExpression,
                    'operator': '>',
                    'left': {
                        'type': Syntax.Identifier,
                        'name': 'statementIndex'
                    },
                    'right': {
                        'type': Syntax.Literal,
                        'value': consequentStatement.getIndex() + 1
                    }
                },
                'right': expression
            },
            'consequent': transpiler.statementTranspiler.transpileBlock(node[CONSEQUENT], node, functionContext)
        });

        if (node[ALTERNATE]) {
            alternateStatement = blockContext.prepareStatement();

            alternateStatement.assign({
                'type': Syntax.IfStatement,
                'test': {
                    'type': Syntax.LogicalExpression,
                    'operator': '||',
                    'left': {
                        'type': Syntax.BinaryExpression,
                        'operator': '>',
                        'left': {
                            'type': Syntax.Identifier,
                            'name': 'statementIndex'
                        },
                        'right': {
                            'type': Syntax.Literal,
                            'value': alternateStatement.getIndex() + 1
                        }
                    },
                    'right': {
                        'type': Syntax.UnaryExpression,
                        'operator': '!',
                        'prefix': true,
                        'argument': expression
                    }
                },
                'consequent': transpiler.statementTranspiler.transpileBlock(node[ALTERNATE], node, functionContext)
            });
        }
    }
});

module.exports = IfStatementTranspiler;

},{"estraverse":18,"microdash":28}],75:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    estraverse = require('estraverse'),
    BODY = 'body',
    LABEL = 'label',
    NAME = 'name',
    Syntax = estraverse.Syntax;

function LabeledStatementTranspiler(statementTranspiler, expressionTranspiler) {
    this.expressionTranspiler = expressionTranspiler;
    this.statementTranspiler = statementTranspiler;
}

_.extend(LabeledStatementTranspiler.prototype, {
    getNodeType: function () {
        return Syntax.LabeledStatement;
    },

    transpile: function (node, parent, functionContext, blockContext) {
        var label = node[LABEL],
            transpiler = this;

        blockContext.transformNextStatement(function (node) {
            return {
                'type': Syntax.LabeledStatement,
                'label': {
                    'type': Syntax.Identifier,
                    'name': 'label_' + label[NAME]
                },
                'body': node
            };
        });

        transpiler.statementTranspiler.transpile(node[BODY], node, functionContext, blockContext);
    }
});

module.exports = LabeledStatementTranspiler;

},{"estraverse":18,"microdash":28}],76:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    estraverse = require('estraverse'),
    BlockContext = require('../BlockContext'),
    FunctionContext = require('../FunctionContext'),
    BODY = 'body',
    Syntax = estraverse.Syntax;

function ProgramTranspiler(statementTranspiler, expressionTranspiler) {
    this.expressionTranspiler = expressionTranspiler;
    this.statementTranspiler = statementTranspiler;
}

_.extend(ProgramTranspiler.prototype, {
    getNodeType: function () {
        return Syntax.Program;
    },

    transpile: function (node) {
        var transpiler = this,
            functionContext = new FunctionContext(),
            blockContext = new BlockContext(functionContext);

        transpiler.statementTranspiler.transpileArray(node[BODY], node, functionContext, blockContext);

        return {
            'type': Syntax.Program,
            'body': [
                {
                    'type': Syntax.ExpressionStatement,
                    'expression': {
                        'type': Syntax.FunctionExpression,
                        'id': null,
                        'params': [],
                        'body': {
                            'type': Syntax.BlockStatement,
                            'body': functionContext.getStatements(blockContext.getSwitchStatement())
                        }
                    }
                }
            ]
        };
    }
});

module.exports = ProgramTranspiler;

},{"../BlockContext":45,"../FunctionContext":59,"estraverse":18,"microdash":28}],77:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    estraverse = require('estraverse'),
    ARGUMENT = 'argument',
    Syntax = estraverse.Syntax;

function ReturnStatementTranspiler(statementTranspiler, expressionTranspiler) {
    this.expressionTranspiler = expressionTranspiler;
    this.statementTranspiler = statementTranspiler;
}

_.extend(ReturnStatementTranspiler.prototype, {
    getNodeType: function () {
        return Syntax.ReturnStatement;
    },

    transpile: function (node, parent, functionContext, blockContext) {
        var expression = node[ARGUMENT] ?
            this.expressionTranspiler.transpile(node[ARGUMENT], node, functionContext, blockContext) :
            null;

        blockContext.prepareStatement().assign({
            'type': Syntax.ReturnStatement,
            'argument': expression
        });
    }
});

module.exports = ReturnStatementTranspiler;

},{"estraverse":18,"microdash":28}],78:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    estraverse = require('estraverse'),
    hasOwn = {}.hasOwnProperty,
    BlockContext = require('../BlockContext'),
    BODY = 'body',
    TYPE = 'type',
    Syntax = estraverse.Syntax;

function StatementTranspiler(expressionTranspiler) {
    this.expressionTranspiler = expressionTranspiler;
    this.transpilers = {};
}

_.extend(StatementTranspiler.prototype, {
    addTranspiler: function (transpiler) {
        this.transpilers[transpiler.getNodeType()] = transpiler;
    },

    transpile: function (node, parent, functionContext, blockContext) {
        var transpiler = this;

        if (!hasOwn.call(transpiler.transpilers, node[TYPE])) {
            throw new Error('Unsupported type "' + node[TYPE] + '"');
        }

        return transpiler.transpilers[node[TYPE]].transpile(node, parent, functionContext, blockContext);
    },

    transpileBlock: function (node, parent, functionContext) {
        var transpiler = this,
            ownBlockContext = new BlockContext(functionContext);

        if (node[TYPE] === Syntax.BlockStatement) {
            transpiler.transpileArray(node[BODY], parent, functionContext, ownBlockContext);
        } else {
            transpiler.transpile(node, parent, functionContext, ownBlockContext);
        }

        return {
            'type': Syntax.BlockStatement,
            'body': [
                ownBlockContext.getSwitchStatement()
            ]
        };
    },

    transpileArray: function (array, parent, functionContext, blockContext) {
        var transpiler = this;

        _.each(array, function (statementNode) {
            transpiler.transpile(statementNode, parent, functionContext, blockContext);
        });
    }
});

module.exports = StatementTranspiler;

},{"../BlockContext":45,"estraverse":18,"microdash":28}],79:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    estraverse = require('estraverse'),
    ARGUMENT = 'argument',
    Syntax = estraverse.Syntax;

function ThrowStatementTranspiler(statementTranspiler, expressionTranspiler) {
    this.expressionTranspiler = expressionTranspiler;
    this.statementTranspiler = statementTranspiler;
}

_.extend(ThrowStatementTranspiler.prototype, {
    getNodeType: function () {
        return Syntax.ThrowStatement;
    },

    transpile: function (node, parent, functionContext, blockContext) {
        var expression = this.expressionTranspiler.transpile(node[ARGUMENT], node, functionContext, blockContext);

        blockContext.prepareStatement().assign({
            'type': Syntax.ThrowStatement,
            'argument': expression
        }, null);
    }
});

module.exports = ThrowStatementTranspiler;

},{"estraverse":18,"microdash":28}],80:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    acorn = require('acorn'),
    estraverse = require('estraverse'),
    BlockContext = require('../BlockContext'),
    BLOCK = 'block',
    BODY = 'body',
    HANDLER = 'handler',
    FINALIZER = 'finalizer',
    NAME = 'name',
    PARAM = 'param',
    Syntax = estraverse.Syntax;

function TryStatementTranspiler(statementTranspiler, expressionTranspiler) {
    this.expressionTranspiler = expressionTranspiler;
    this.statementTranspiler = statementTranspiler;
}

_.extend(TryStatementTranspiler.prototype, {
    getNodeType: function () {
        return Syntax.TryStatement;
    },

    transpile: function (node, parent, functionContext, blockContext) {
        var catchParam,
            catchStartIndex = null,
            catchStatements = [],
            handler = node[HANDLER],
            hasCatch = handler && handler[BODY][BODY].length > 0,
            finalizer = node[FINALIZER],
            ownBlockContext = new BlockContext(functionContext),
            statement,
            transpiler = this,
            tryEndIndex,
            tryNode,
            tryStartIndex;

        statement = blockContext.prepareStatement();

        tryStartIndex = functionContext.getCurrentStatementIndex();
        transpiler.statementTranspiler.transpileArray(node[BLOCK][BODY], node, functionContext, ownBlockContext);
        tryEndIndex = functionContext.getCurrentStatementIndex();

        if (hasCatch) {
            catchStartIndex = functionContext.getCurrentStatementIndex();

            (function () {
                var catchClauseBlockContext = new BlockContext(functionContext),
                    catchParameter = functionContext.getTempName(),
                    resumeThrowStatement = ownBlockContext.addResumeThrow();

                transpiler.statementTranspiler.transpileArray(handler[BODY][BODY], handler, functionContext, catchClauseBlockContext);

                catchStatements.push(
                    {
                        'type': Syntax.IfStatement,
                        'test': acorn.parse(handler[PARAM][NAME] + ' instanceof Resumable.ResumeException').body[0].expression,
                        'consequent': {
                            'type': Syntax.BlockStatement,
                            'body': [
                                {
                                    'type': Syntax.ExpressionStatement,
                                    'expression': {
                                        'type': Syntax.AssignmentExpression,
                                        'operator': '=',
                                        'left': handler[PARAM],
                                        'right': {
                                            'type': Syntax.MemberExpression,
                                            'object': handler[PARAM],
                                            'property': {
                                                'type': Syntax.Identifer,
                                                'name': 'error'
                                            },
                                            'computed': false
                                        }
                                    }
                                }
                            ]
                        },
                        'alternate': {
                            'type': Syntax.BlockStatement,
                            'body': [
                                {
                                    'type': Syntax.ExpressionStatement,
                                    'expression': {
                                        'type': Syntax.AssignmentExpression,
                                        'operator': '=',
                                        'left': {
                                            'type': Syntax.Identifier,
                                            'name': 'statementIndex'
                                        },
                                        'right': {
                                            'type': Syntax.Literal,
                                            'value': catchStartIndex
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    catchClauseBlockContext.getSwitchStatement()
                );

                functionContext.addCatch({
                    tryStartIndex: tryStartIndex,
                    tryEndIndex: tryEndIndex - 1,
                    catchParameter: catchParameter,
                    catchStatementIndex: catchStartIndex
                });

                resumeThrowStatement.assign({
                    'type': Syntax.Identifier,
                    'name': catchParameter
                });
            }());
        }

        tryNode = {
            'type': Syntax.TryStatement,
            'block': {
                'type': Syntax.BlockStatement,
                'body': [
                    ownBlockContext.getSwitchStatement()
                ]
            }
        };
        catchParam = handler ? handler[PARAM] : {
            'type': Syntax.Identifier,
            'name': 'resumableError'
        };
        tryNode[HANDLER] = {
            'type': Syntax.CatchClause,
            'param': catchParam,
            'body': {
                'type': Syntax.BlockStatement,
                'body': catchStatements
            }
        };

        if (finalizer) {
            functionContext.addFinally();

            catchStatements.splice(1, 0, {
                'type': Syntax.ExpressionStatement,
                'expression': {
                    'type': Syntax.AssignmentExpression,
                    'left': {
                        'type': Syntax.Identifier,
                        'name': 'resumableUncaughtError'
                    },
                    'operator': '=',
                    'right': catchParam
                }
            });

            if (handler) {
                catchStatements.push({
                    'type': Syntax.ExpressionStatement,
                    'expression': {
                        'type': Syntax.AssignmentExpression,
                        'left': {
                            'type': Syntax.Identifier,
                            'name': 'resumableUncaughtError'
                        },
                        'operator': '=',
                        'right': {
                            'type': Syntax.Identifier,
                            'name': 'null'
                        }
                    }
                });
            }

            (function () {
                var finallyClauseBlockContext = new BlockContext(functionContext),
                    finallyClauseStatementIndex = functionContext.getCurrentStatementIndex(),
                    finallyStatements,
                    finallySwitch;

                transpiler.statementTranspiler.transpileArray(
                    finalizer[BODY],
                    finalizer,
                    functionContext,
                    finallyClauseBlockContext
                );

                finallySwitch = finallyClauseBlockContext.getSwitchStatement();
                finallyStatements = [
                    {
                        'type': Syntax.IfStatement,
                        'test': {
                            'type': Syntax.Identifier,
                            'name': 'resumablePause'
                        },
                        'consequent': {
                            'type': Syntax.BlockStatement,
                            'body': [{
                                'type': Syntax.ThrowStatement,
                                'argument': {
                                    'type': Syntax.Identifier,
                                    'name': 'resumablePause'
                                }
                            }]
                        },
                        'alternate': null
                    },
                    {
                        // Only assign the statement index var if we are inside the try/catch/finally block
                        'type': Syntax.IfStatement,
                        'test': acorn.parse(
                            'statementIndex >= ' + tryStartIndex + ' && statementIndex < ' + finallyClauseStatementIndex
                        ).body[0].expression,
                        'consequent': {
                            'type': Syntax.BlockStatement,
                            'body': [{
                                'type': Syntax.ExpressionStatement,
                                'expression': {
                                    'type': Syntax.AssignmentExpression,
                                    'left': {
                                        'type': Syntax.Identifier,
                                        'name': 'statementIndex'
                                    },
                                    'operator': '=',
                                    'right': {
                                        'type': Syntax.Literal,
                                        'value': finallyClauseStatementIndex
                                    }
                                }
                            }]
                        },
                        'alternate': null
                    },
                    finallySwitch
                ];

                finallyStatements.push({
                    'type': Syntax.IfStatement,
                    'test': {
                        'type': Syntax.Identifier,
                        'name': 'resumableUncaughtError'
                    },
                    'consequent': {
                        'type': Syntax.BlockStatement,
                        'body': [{
                            'type': Syntax.ThrowStatement,
                            'argument': {
                                'type': Syntax.Identifier,
                                'name': 'resumableUncaughtError'
                            }
                        }]
                    },
                    'alternate': null
                });
                tryNode[FINALIZER] = {
                    'type': Syntax.BlockStatement,
                    'body': finallyStatements
                };
            }());
        }

        catchStatements.unshift({
            'type': Syntax.IfStatement,
            'test': {
                'type': Syntax.BinaryExpression,
                'left': catchParam,
                'operator': 'instanceof',
                'right': {
                    'type': Syntax.MemberExpression,
                    'object': {
                        'type': Syntax.Identifier,
                        'name': 'Resumable'
                    },
                    'property': {
                        'type': Syntax.Identifier,
                        'name': 'PauseException'
                    },
                    'computed': false
                }
            },
            'consequent': {
                'type': Syntax.BlockStatement,
                'body': (finalizer ? [{
                    'type': Syntax.ExpressionStatement,
                    'expression': {
                        'type': Syntax.AssignmentExpression,
                        'left': {
                            'type': Syntax.Identifier,
                            'name': 'resumablePause'
                        },
                        'operator': '=',
                        'right': catchParam
                    }
                }] : []).concat([
                    {
                        'type': Syntax.ThrowStatement,
                        'argument': catchParam
                    }
                ])
            },
            'alternate': null
        });

        statement.assign(tryNode);
    }
});

module.exports = TryStatementTranspiler;

},{"../BlockContext":45,"acorn":44,"estraverse":18,"microdash":28}],81:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    estraverse = require('estraverse'),
    DECLARATIONS = 'declarations',
    ID = 'id',
    INIT = 'init',
    NAME = 'name',
    Syntax = estraverse.Syntax;

function VariableDeclarationTranspiler(statementTranspiler, expressionTranspiler) {
    this.expressionTranspiler = expressionTranspiler;
    this.statementTranspiler = statementTranspiler;
}

_.extend(VariableDeclarationTranspiler.prototype, {
    getNodeType: function () {
        return Syntax.VariableDeclaration;
    },

    transpile: function (node, parent, functionContext, blockContext) {
        var transpiler = this;

        _.each(node[DECLARATIONS], function (declaration) {
            var expression;

            functionContext.addVariable(declaration[ID][NAME]);

            if (declaration[INIT] !== null) {
                expression = transpiler.expressionTranspiler.transpile(
                    declaration[INIT],
                    node,
                    functionContext,
                    blockContext
                );

                blockContext.prepareStatement().assign({
                    'type': Syntax.ExpressionStatement,
                    'expression': {
                        'type': Syntax.AssignmentExpression,
                        'operator': '=',
                        'left': declaration[ID],
                        'right': expression
                    }
                });
            }
        });
    }
});

module.exports = VariableDeclarationTranspiler;

},{"estraverse":18,"microdash":28}],82:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    acorn = require('acorn'),
    estraverse = require('estraverse'),
    BlockContext = require('../BlockContext'),
    BODY = 'body',
    LABEL = 'label',
    NAME = 'name',
    TEST = 'test',
    TYPE = 'type',
    Syntax = estraverse.Syntax;

function WhileStatementTranspiler(statementTranspiler, expressionTranspiler) {
    this.expressionTranspiler = expressionTranspiler;
    this.statementTranspiler = statementTranspiler;
}

_.extend(WhileStatementTranspiler.prototype, {
    getNodeType: function () {
        return Syntax.WhileStatement;
    },

    transpile: function (node, parent, functionContext, blockContext) {
        var forNode,
            ownBlockContext = new BlockContext(functionContext),
            transpiler = this,
            expression,
            statement,
            label = parent[TYPE] === Syntax.LabeledStatement ?
                parent[LABEL][NAME] :
                null;

        functionContext.pushLabelableContext(label);

        statement = blockContext.prepareStatement();

        expression = transpiler.expressionTranspiler.transpile(node[TEST], node, functionContext, ownBlockContext);

        ownBlockContext.prepareStatement().assign({
            'type': Syntax.IfStatement,
            'test': {
                'type': Syntax.UnaryExpression,
                'operator': '!',
                'prefix': true,
                'argument': expression
            },
            'consequent': {
                'type': Syntax.BlockStatement,
                'body': [
                    {
                        'type': Syntax.BreakStatement,
                        'label': {
                            'type': Syntax.Identifier,
                            'name': functionContext.getLabel()
                        }
                    }
                ]
            }
        });

        transpiler.statementTranspiler.transpileArray(node[BODY][BODY], node, functionContext, ownBlockContext);

        forNode = {
            'type': Syntax.ForStatement,
            'init': null,
            'test': null,
            'update': null,
            'body': {
                'type': Syntax.BlockStatement,
                'body': [
                    ownBlockContext.getSwitchStatement(),
                    acorn.parse('statementIndex = ' + (statement.getIndex() + 1) + ';').body[0]
                ]
            }
        };

        statement.assign(functionContext.getLabeledStatement(forNode));

        functionContext.popLabelableContext();
    }
});

module.exports = WhileStatementTranspiler;

},{"../BlockContext":45,"acorn":44,"estraverse":18,"microdash":28}],83:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    estraverse = require('estraverse'),
    BlockContext = require('../BlockContext'),
    BODY = 'body',
    OBJECT = 'object',
    Syntax = estraverse.Syntax;

function WithStatementTranspiler(statementTranspiler, expressionTranspiler) {
    this.expressionTranspiler = expressionTranspiler;
    this.statementTranspiler = statementTranspiler;
}

_.extend(WithStatementTranspiler.prototype, {
    getNodeType: function () {
        return Syntax.WithStatement;
    },

    transpile: function (node, parent, functionContext, blockContext) {
        var transpiler = this,
            object = this.expressionTranspiler.transpile(node[OBJECT], node, functionContext, blockContext),
            ownBlockContext = new BlockContext(functionContext),
            statement = blockContext.prepareStatement();

        transpiler.statementTranspiler.transpileArray(node[BODY][BODY], node, functionContext, ownBlockContext);

        statement.assign({
            'type': Syntax.WithStatement,
            'object': object,
            'body': {
                'type': Syntax.BlockStatement,
                'body': [
                    ownBlockContext.getSwitchStatement()
                ]
            }
        });
    }
});

module.exports = WithStatementTranspiler;

},{"../BlockContext":45,"estraverse":18,"microdash":28}],84:[function(require,module,exports){
/*
 * Pausable - Pause and resume JavaScript code
 * Copyright (c) Dan Phillimore (asmblah)
 * http://asmblah.github.com/pausable/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pausable/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    estraverse = estraverse,
    ArrayExpressionTranspiler = require('./ExpressionTranspiler/ArrayExpressionTranspiler'),
    AssignmentExpressionTranspiler = require('./ExpressionTranspiler/AssignmentExpressionTranspiler'),
    BinaryExpressionTranspiler = require('./ExpressionTranspiler/BinaryExpressionTranspiler'),
    BlockStatementTranspiler = require('./StatementTranspiler/BlockStatementTranspiler'),
    BreakStatementTranspiler = require('./StatementTranspiler/BreakStatementTranspiler'),
    CallExpressionTranspiler = require('./ExpressionTranspiler/CallExpressionTranspiler'),
    ContinueStatementTranspiler = require('./StatementTranspiler/ContinueStatementTranspiler'),
    DebuggerStatementTranspiler = require('./StatementTranspiler/DebuggerStatementTranspiler'),
    DoWhileStatementTranspiler = require('./StatementTranspiler/DoWhileStatementTranspiler'),
    EmptyStatementTranspiler = require('./StatementTranspiler/EmptyStatementTranspiler'),
    ExpressionStatementTranspiler = require('./StatementTranspiler/ExpressionStatementTranspiler'),
    ExpressionTranspiler = require('./ExpressionTranspiler/ExpressionTranspiler'),
    ForStatementTranspiler = require('./StatementTranspiler/ForStatementTranspiler'),
    FunctionDeclarationTranspiler = require('./StatementTranspiler/FunctionDeclarationTranspiler'),
    FunctionExpressionTranspiler = require('./ExpressionTranspiler/FunctionExpressionTranspiler'),
    FunctionTranspiler = require('./FunctionTranspiler'),
    IdentifierTranspiler = require('./ExpressionTranspiler/IdentifierTranspiler'),
    IfStatementTranspiler = require('./StatementTranspiler/IfStatementTranspiler'),
    LabeledStatementTranspiler = require('./StatementTranspiler/LabeledStatementTranspiler'),
    LogicalExpressionTranspiler = require('./ExpressionTranspiler/LogicalExpressionTranspiler'),
    MemberExpressionTranspiler = require('./ExpressionTranspiler/MemberExpressionTranspiler'),
    ObjectExpressionTranspiler = require('./ExpressionTranspiler/ObjectExpressionTranspiler'),
    ProgramTranspiler = require('./StatementTranspiler/ProgramTranspiler'),
    PropertyTranspiler = require('./ExpressionTranspiler/PropertyTranspiler'),
    ReturnStatementTranspiler = require('./StatementTranspiler/ReturnStatementTranspiler'),
    SequenceExpressionTranspiler = require('./ExpressionTranspiler/SequenceExpressionTranspiler'),
    StatementTranspiler = require('./StatementTranspiler/StatementTranspiler'),
    ThrowStatementTranspiler = require('./StatementTranspiler/ThrowStatementTranspiler'),
    TryStatementTranspiler = require('./StatementTranspiler/TryStatementTranspiler'),
    UpdateExpressionTranspiler = require('./ExpressionTranspiler/UpdateExpressionTranspiler'),
    VariableDeclarationTranspiler = require('./StatementTranspiler/VariableDeclarationTranspiler'),
    WhileStatementTranspiler = require('./StatementTranspiler/WhileStatementTranspiler'),
    WithStatementTranspiler = require('./StatementTranspiler/WithStatementTranspiler');

function Transpiler() {
    var expressionTranspiler = new ExpressionTranspiler(),
        statementTranspiler = new StatementTranspiler(),
        functionTranspiler = new FunctionTranspiler(statementTranspiler);

    _.each([
        BlockStatementTranspiler,
        BreakStatementTranspiler,
        ContinueStatementTranspiler,
        DebuggerStatementTranspiler,
        DoWhileStatementTranspiler,
        EmptyStatementTranspiler,
        ExpressionStatementTranspiler,
        ForStatementTranspiler,
        IfStatementTranspiler,
        LabeledStatementTranspiler,
        ProgramTranspiler,
        ReturnStatementTranspiler,
        ThrowStatementTranspiler,
        TryStatementTranspiler,
        VariableDeclarationTranspiler,
        WhileStatementTranspiler,
        WithStatementTranspiler
    ], function (Class) {
        statementTranspiler.addTranspiler(new Class(statementTranspiler, expressionTranspiler));
    });

    statementTranspiler.addTranspiler(
        new FunctionDeclarationTranspiler(
            statementTranspiler,
            expressionTranspiler,
            functionTranspiler
        )
    );

    _.each([
        ArrayExpressionTranspiler,
        AssignmentExpressionTranspiler,
        BinaryExpressionTranspiler,
        CallExpressionTranspiler,
        IdentifierTranspiler,
        LogicalExpressionTranspiler,
        MemberExpressionTranspiler,
        ObjectExpressionTranspiler,
        PropertyTranspiler,
        SequenceExpressionTranspiler,
        UpdateExpressionTranspiler
    ], function (Class) {
        expressionTranspiler.addTranspiler(new Class(statementTranspiler, expressionTranspiler));
    });

    expressionTranspiler.addTranspiler(
        new FunctionExpressionTranspiler(
            statementTranspiler,
            expressionTranspiler,
            functionTranspiler
        )
    );

    this.expressionTranspiler = expressionTranspiler;
    this.statementTranspiler = statementTranspiler;
}

_.extend(Transpiler.prototype, {
    transpile: function (ast) {
        return this.statementTranspiler.transpile(ast, null);
    }
});

module.exports = Transpiler;

},{"./ExpressionTranspiler/ArrayExpressionTranspiler":46,"./ExpressionTranspiler/AssignmentExpressionTranspiler":47,"./ExpressionTranspiler/BinaryExpressionTranspiler":48,"./ExpressionTranspiler/CallExpressionTranspiler":49,"./ExpressionTranspiler/ExpressionTranspiler":50,"./ExpressionTranspiler/FunctionExpressionTranspiler":51,"./ExpressionTranspiler/IdentifierTranspiler":52,"./ExpressionTranspiler/LogicalExpressionTranspiler":53,"./ExpressionTranspiler/MemberExpressionTranspiler":54,"./ExpressionTranspiler/ObjectExpressionTranspiler":55,"./ExpressionTranspiler/PropertyTranspiler":56,"./ExpressionTranspiler/SequenceExpressionTranspiler":57,"./ExpressionTranspiler/UpdateExpressionTranspiler":58,"./FunctionTranspiler":60,"./StatementTranspiler/BlockStatementTranspiler":65,"./StatementTranspiler/BreakStatementTranspiler":66,"./StatementTranspiler/ContinueStatementTranspiler":67,"./StatementTranspiler/DebuggerStatementTranspiler":68,"./StatementTranspiler/DoWhileStatementTranspiler":69,"./StatementTranspiler/EmptyStatementTranspiler":70,"./StatementTranspiler/ExpressionStatementTranspiler":71,"./StatementTranspiler/ForStatementTranspiler":72,"./StatementTranspiler/FunctionDeclarationTranspiler":73,"./StatementTranspiler/IfStatementTranspiler":74,"./StatementTranspiler/LabeledStatementTranspiler":75,"./StatementTranspiler/ProgramTranspiler":76,"./StatementTranspiler/ReturnStatementTranspiler":77,"./StatementTranspiler/StatementTranspiler":78,"./StatementTranspiler/ThrowStatementTranspiler":79,"./StatementTranspiler/TryStatementTranspiler":80,"./StatementTranspiler/VariableDeclarationTranspiler":81,"./StatementTranspiler/WhileStatementTranspiler":82,"./StatementTranspiler/WithStatementTranspiler":83,"microdash":28}],85:[function(require,module,exports){
/*
 * Pauser - Wrapper for optional Pausable usage
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/asmblah/pauser/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pauser/raw/master/MIT-LICENSE.txt
 */

'use strict';

var Wrapper = require('./src/Wrapper');

module.exports = function (args, wrapper, options) {
    return new Wrapper(args, wrapper, options);
};

},{"./src/Wrapper":86}],86:[function(require,module,exports){
/*
 * Pauser - Wrapper for optional Pausable usage
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/asmblah/pauser/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pauser/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash');

function Wrapper(args, fn, options) {
    this.args = args;
    this.evaluatedAsync = false;
    this.evaluatedSync = false;
    this.asyncReturnValue = null;
    this.fn = fn;
    this.options = options;
    this.syncReturnValue = null;
}

_.extend(Wrapper.prototype, {
    /**
     * Executes wrapper asynchronously via the Pausable library.
     *
     * @param {Pausable} pausable
     * @returns {*}
     */
    async: function (pausable) {
        var args,
            wrapper = this;

        if (wrapper.evaluatedAsync) {
            return wrapper.asyncReturnValue;
        }

        // Recursively transpile any arguments to the function that are themselves Wrappers
        args = _.map(wrapper.args, function (arg) {
            if (arg instanceof Wrapper) {
                return arg.async(pausable);
            }

            return arg;
        });

        wrapper.asyncReturnValue = pausable.executeSync(args, wrapper.fn, wrapper.options);
        wrapper.evaluatedAsync = true;

        return wrapper.asyncReturnValue;
    },

    /**
     * Executes wrapper synchronously when the Pausable library is not available.
     *
     * @returns {*}
     */
    sync: function () {
        var args,
            wrapper = this;

        if (wrapper.evaluatedSync) {
            return wrapper.syncReturnValue;
        }

        // Recursively evaluate any arguments to the function that are themselves Wrappers
        args = _.map(wrapper.args, function (arg) {
            if (arg instanceof Wrapper) {
                return arg.sync();
            }

            return arg;
        });

        wrapper.syncReturnValue = wrapper.fn.apply(null, args);
        wrapper.evaluatedSync = true;

        return wrapper.syncReturnValue;
    }
});

module.exports = Wrapper;

},{"microdash":28}],87:[function(require,module,exports){
/*
 * PHPCommon - Common tools for PHP environments
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcommon/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcommon/raw/master/MIT-LICENSE.txt
 */

'use strict';

var Exception = require('./src/Error/Exception'),
    PHPError = require('./src/Error/PHPError'),
    PHPFatalError = require('./src/Error/PHPFatalError'),
    PHPParseError = require('./src/Error/PHPParseError');

module.exports = {
    Exception: Exception,
    PHPError: PHPError,
    PHPFatalError: PHPFatalError,
    PHPParseError: PHPParseError
};

},{"./src/Error/Exception":88,"./src/Error/PHPError":89,"./src/Error/PHPFatalError":90,"./src/Error/PHPParseError":91}],88:[function(require,module,exports){
/*
 * PHPCommon - Common tools for PHP environments
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcommon/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcommon/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    util = require('util');

function Exception(message) {
    this.message = message;
}

util.inherits(Exception, Error);

_.extend(Exception.prototype, {
    'type': 'Exception'
});

module.exports = Exception;

},{"microdash":28,"util":172}],89:[function(require,module,exports){
/*
 * PHPCommon - Common tools for PHP environments
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcommon/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcommon/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    util = require('util'),
    Exception = require('./Exception');

function PHPError(level, message) {
    Exception.call(this, 'PHP ' + level + ': ' + message);
}

util.inherits(PHPError, Exception);

_.extend(PHPError, {
    E_ERROR: 'Error',
    E_FATAL: 'Fatal error',
    E_NOTICE: 'Notice',
    E_PARSE: 'Parse error',
    E_STRICT: 'Strict standards',
    E_WARNING: 'Warning'
});

module.exports = PHPError;

},{"./Exception":88,"microdash":28,"util":172}],90:[function(require,module,exports){
/*
 * PHPCommon - Common tools for PHP environments
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcommon/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcommon/raw/master/MIT-LICENSE.txt
 */

'use strict';

var MESSAGE_PREFIXES = {
        1: 'Unsupported operand types',
        2: 'Call to undefined function ${name}()',
        3: 'Class \'${name}\' not found',
        4: 'Call to undefined method ${className}::${methodName}()',
        5: '\'goto\' into loop or switch statement is disallowed',
        6: '${name}() must take exactly 1 argument',
        7: 'Class name must be a valid object or a string',
        8: 'Access to undeclared static property: ${className}::$${propertyName}',
        9: 'Call to undefined method ${className}::${methodName}()',
        10: 'Cannot access self:: when no class scope is active',
        11: 'Undefined constant \'${name}\'',
        12: 'Uncaught exception \'${name}\'',
        13: 'Cannot access ${visibility} property ${className}::$${propertyName}',
        14: 'Function name must be a string',
        15: 'Undefined class constant \'${name}\'',
        16: 'Interfaces may not include member variables',
        17: 'Interface function ${className}::${methodName}() cannot contain body',
        18: 'Cannot use ${source} as ${alias} because the name is already in use',
        19: 'Call to a member function ${name}() on a non-object',
        20: 'instanceof expects an object instance, constant given',
        21: 'Cannot use object of type ${actual} as ${expected}',
        22: 'Using $this when not in object context',
        23: '\'${operator}\' operator accepts only positive numbers',
        24: 'Cannot break/continue ${levels} level${suffix}',
        25: 'Only variables can be passed by reference'
    },
    _ = require('microdash'),
    templateString = require('template-string'),
    util = require('util'),
    PHPError = require('./PHPError');

function PHPFatalError(code, variables) {
    PHPError.call(this, PHPError.E_FATAL, templateString(MESSAGE_PREFIXES[code], variables));
}

util.inherits(PHPFatalError, PHPError);

_.extend(PHPFatalError, {
    UNSUPPORTED_OPERAND_TYPES: 1,
    CALL_TO_UNDEFINED_FUNCTION: 2,
    CLASS_NOT_FOUND: 3,
    UNDEFINED_METHOD: 4,
    GOTO_DISALLOWED: 5,
    EXPECT_EXACTLY_1_ARG: 6,
    CLASS_NAME_NOT_VALID: 7,
    UNDECLARED_STATIC_PROPERTY: 8,
    CALL_TO_UNDEFINED_METHOD: 9,
    SELF_WHEN_NO_ACTIVE_CLASS: 10,
    UNDEFINED_CONSTANT: 11,
    UNCAUGHT_EXCEPTION: 12,
    CANNOT_ACCESS_PROPERTY: 13,
    FUNCTION_NAME_MUST_BE_STRING: 14,
    UNDEFINED_CLASS_CONSTANT: 15,
    INTERFACE_PROPERTY_NOT_ALLOWED: 16,
    INTERFACE_METHOD_BODY_NOT_ALLOWED: 17,
    NAME_ALREADY_IN_USE: 18,
    NON_OBJECT_METHOD_CALL: 19,
    INSTANCEOF_EXPECTS_OBJECT: 20,
    CANNOT_USE_WRONG_TYPE_AS: 21,
    USED_THIS_OUTSIDE_OBJECT_CONTEXT: 22,
    OPERATOR_REQUIRES_POSITIVE_NUMBER: 23,
    CANNOT_BREAK_OR_CONTINUE: 24,
    ONLY_VARIABLES_BY_REFERENCE: 25
});

module.exports = PHPFatalError;

},{"./PHPError":89,"microdash":28,"template-string":170,"util":172}],91:[function(require,module,exports){
/*
 * PHPCommon - Common tools for PHP environments
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcommon/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcommon/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    templateString = require('template-string'),
    util = require('util'),
    PHPError = require('./PHPError'),
    MESSAGE_PREFIXES = {
        1: 'syntax error, unexpected ${what} in ${file} on line ${line}'
    };

function PHPParseError(code, variables) {
    PHPError.call(this, PHPError.E_PARSE, templateString(MESSAGE_PREFIXES[code], variables));
}

util.inherits(PHPParseError, PHPError);

_.extend(PHPParseError, {
    SYNTAX_UNEXPECTED: 1
});

module.exports = PHPParseError;

},{"./PHPError":89,"microdash":28,"template-string":170,"util":172}],92:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

var pausable = require('pausable'),
    phpCommon = require('phpcommon'),
    Engine = require('./src/Engine'),
    Environment = require('./src/Environment'),
    OptionSet = require('./src/OptionSet'),
    PHPState = require('./src/PHPState').async(pausable),
    Runtime = require('./src/Runtime').async(pausable),
    runtime = new Runtime(Environment, Engine, OptionSet, PHPState, phpCommon, pausable);

module.exports = runtime;

},{"./src/Engine":100,"./src/Environment":101,"./src/OptionSet":110,"./src/PHPState":112,"./src/Runtime":122,"pausable":43,"phpcommon":87}],93:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash');

function Call(scope) {
    this.scope = scope;
}

_.extend(Call.prototype, {
    getScope: function () {
        return this.scope;
    }
});

module.exports = Call;

},{"microdash":28}],94:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash');

function CallFactory(Call) {
    this.Call = Call;
}

_.extend(CallFactory.prototype, {
    create: function (scope) {
        var factory = this;

        return new factory.Call(scope);
    }
});

module.exports = CallFactory;

},{"microdash":28}],95:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    phpCommon = require('phpcommon'),
    PHPError = phpCommon.PHPError;

function CallStack(stderr) {
    this.calls = [];
    this.stderr = stderr;
}

_.extend(CallStack.prototype, {
    getCurrent: function () {
        var chain = this;

        return chain.calls[chain.calls.length - 1];
    },

    getThisObject: function () {
        return this.getCurrent().getScope().getThisObject();
    },

    pop: function () {
        this.calls.pop();
    },

    push: function (call) {
        this.calls.push(call);
    },

    raiseError: function (level, message) {
        var call,
            chain = this,
            calls = chain.calls,
            error,
            index;

        // Some constructs like isset(...) should only suppress errors
        // for their own scope
        if (chain.getCurrent().getScope().suppressesOwnErrors()) {
            return;
        }

        for (index = calls.length - 1; index >= 0; --index) {
            call = calls[index];

            if (call.getScope().suppressesErrors()) {
                return;
            }
        }

        error = new PHPError(level, message);

        chain.stderr.write(error.message + '\n');
    }
});

module.exports = CallStack;

},{"microdash":28,"phpcommon":87}],96:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

module.exports = require('pauser')([
    require('microdash'),
    require('phpcommon'),
    require('./Reference/StaticProperty')
], function (
    _,
    phpCommon,
    StaticPropertyReference
) {
    var IS_STATIC = 'isStatic',
        MAGIC_CALL = '__call',
        MAGIC_CALL_STATIC = '__callStatic',
        VALUE = 'value',
        VISIBILITY = 'visibility',
        hasOwn = {}.hasOwnProperty,
        PHPError = phpCommon.PHPError,
        PHPFatalError = phpCommon.PHPFatalError,
        unwrapArgs = function (args, classObject) {
            if (classObject.autoCoercionEnabled) {
                return _.map(args, function (arg) {
                    return arg.getNative();
                });
            }

            return args;
        },
        getMethod = function (object, methodName) {
            var result = null;

            _.forOwn(object, function (value, propertyName) {
                if (
                    propertyName.toLowerCase() === methodName.toLowerCase() &&
                    _.isFunction(value)
                ) {
                    result = value;
                    return false;
                }
            });

            return result;
        };

    function Class(
        valueFactory,
        callStack,
        name,
        constructorName,
        InternalClass,
        staticPropertiesData,
        constants,
        superClass,
        interfaceNames,
        namespaceScope
    ) {
        var classObject = this,
            staticProperties = {};

        this.autoCoercionEnabled = false;
        this.callStack = callStack;
        this.constants = constants;
        this.constructorName = constructorName;
        this.interfaceNames = interfaceNames || [];
        this.InternalClass = InternalClass;
        this.name = name;
        this.namespaceScope = namespaceScope;
        this.staticProperties = staticProperties;
        this.superClass = superClass;
        this.unwrapper = null;
        this.valueFactory = valueFactory;

        _.each(staticPropertiesData, function (data, name) {
            staticProperties[name] = new StaticPropertyReference(classObject, name, data[VISIBILITY], data[VALUE]);
        });
    }

    _.extend(Class.prototype, {
        /**
         * Calls an instance or static method. If `objectValue` is passed, the call
         * will be in an object context, otherwise it will be in a static context.
         *
         * Omit both `objectValue` and `currentNativeObject` for a static call.
         *
         * @param {string} methodName The name of the method to call
         * @param {Value[]} args The wrapped value objects to pass as arguments to the method
         * @param {ObjectValue} objectValue The wrapped ObjectValue for this instance
         * @param {object} currentNativeObject The current native JS object on the prototype chain to search for the method
         * @returns {Value}
         * @throws {PHPFatalError} Throws when the method is not defined
         */
        callMethod: function (methodName, args, objectValue, currentNativeObject) {
            var classObject = this,
                nativeObject = objectValue ? objectValue.getObject() : null,
                result,
                thisObject = classObject.callStack.getThisObject();

            function callMethod(currentObject, methodName, args) {
                var method = getMethod(currentObject, methodName);

                if (method !== null) {
                    if (!objectValue && !method[IS_STATIC]) {
                        objectValue = thisObject;

                        if (!objectValue) {
                            classObject.callStack.raiseError(
                                PHPError.E_STRICT,
                                'Non-static method ' + method.data.classObject.name +
                                '::' + methodName + '() should not be called statically'
                            );
                        } else if (!objectValue.classIs(classObject.getName())) {
                            classObject.callStack.raiseError(
                                PHPError.E_STRICT,
                                'Non-static method ' + method.data.classObject.name +
                                '::' + methodName + '() should not be called statically, ' +
                                'assuming $this from incompatible context'
                            );
                        }
                    }

                    return classObject.valueFactory.coerce(
                        method.apply(
                            classObject.autoCoercionEnabled ? objectValue.getObject() : objectValue,
                            unwrapArgs(args, classObject)
                        )
                    );
                }

                if (
                    currentObject === classObject.InternalClass.prototype &&
                    classObject.superClass
                ) {
                    return classObject.superClass.callMethod(
                        methodName,
                        args,
                        objectValue,
                        Object.getPrototypeOf(currentObject)
                    );
                }

                currentObject = Object.getPrototypeOf(currentObject);

                if (!currentObject) {
                    return null;
                }

                return callMethod(currentObject, methodName, args);
            }

            if (!currentNativeObject) {
                // Walk up the prototype chain from the native object
                currentNativeObject = nativeObject;
            }

            if (nativeObject instanceof classObject.InternalClass) {
                // Ignore own properties of the native object when searching for methods
                if (currentNativeObject === nativeObject) {
                    currentNativeObject = Object.getPrototypeOf(currentNativeObject);
                }
            } else {
                // For some special classes (eg. JSObject, Closure) the native object may not actually
                // be an instance of the InternalClass, so fake inheritance of the native class
                currentNativeObject = classObject.InternalClass.prototype;
            }

            result = callMethod(currentNativeObject, methodName, args);

            if (result !== null) {
                return result;
            }

            // Method was not found on object or its prototype chain: try the magic method(s)

            if (!objectValue && thisObject) {
                // Magic __call(...) should override __callStatic(...)
                // when both present for static call in object context
                result = callMethod(thisObject.getObject(), MAGIC_CALL, [
                    classObject.valueFactory.createString(methodName),
                    classObject.valueFactory.createArray(args)
                ]);

                if (result !== null) {
                    return result;
                }
            }

            result = callMethod(
                currentNativeObject,
                objectValue ? MAGIC_CALL : MAGIC_CALL_STATIC,
                [
                    classObject.valueFactory.createString(methodName),
                    classObject.valueFactory.createArray(args)
                ]
            );

            if (result !== null) {
                return result;
            }

            // Method was not found and no magic __call method is defined
            throw new PHPFatalError(
                PHPFatalError.UNDEFINED_METHOD,
                {
                    className: classObject.name,
                    methodName: methodName
                }
            );
        },

        /**
         * Calls the constructor for the provided object
         *
         * @param {ObjectValue} objectValue
         * @param {Value[]} args
         */
        construct: function (objectValue, args) {
            var classObject = this;

            if (!classObject.constructorName) {
                // Class does not define a constructor: call the superclass' constructor
                // if it has one, otherwise do nothing
                if (classObject.superClass) {
                    classObject.superClass.construct(objectValue, args);
                }

                return;
            }

            objectValue.callMethod(classObject.constructorName, args);
        },

        /**
         * Defines a function suitable for unwrapping instances of this class
         * to be exported to JS-land
         *
         * @param {function} unwrapper
         * @returns {*}
         */
        defineUnwrapper: function (unwrapper) {
            this.unwrapper = unwrapper;
        },

        /**
         * Prevents constructor and method arguments from being unwrapped
         * to native JS values when called
         */
        disableAutoCoercion: function () {
            this.autoCoercionEnabled = false;
        },

        /**
         * Ensures constructor and method arguments are always unwrapped
         * to native JS values when called
         */
        enableAutoCoercion: function () {
            this.autoCoercionEnabled = true;
        },

        extends: function (superClass) {
            var classObject = this;

            return classObject.superClass && (classObject.superClass.name === superClass.name || classObject.superClass.extends(superClass));
        },

        getConstantByName: function (name) {
            var classObject = this,
                i,
                interfaceObject;

            if (name.toLowerCase() === 'class') {
                return classObject.valueFactory.createString(classObject.getName());
            }

            if (hasOwn.call(classObject.constants, name)) {
                return classObject.constants[name]();
            }

            if (classObject.superClass) {
                return classObject.superClass.getConstantByName(name);
            }

            for (i = 0; i < classObject.interfaceNames.length; i++) {
                interfaceObject = classObject.namespaceScope.getClass(classObject.interfaceNames[i]);

                try {
                    return interfaceObject.getConstantByName(name);
                } catch (e) {
                    // Not found, try the next interface
                }
            }

            throw new PHPFatalError(PHPFatalError.UNDEFINED_CLASS_CONSTANT, {
                name: name
            });
        },

        getInternalClass: function () {
            return this.InternalClass;
        },

        getName: function () {
            return this.name;
        },

        getUnprefixedName: function () {
            return this.name.replace(/^.*\\/, '');
        },

        getStaticPropertyByName: function (name) {
            var classObject = this,
                currentClass,
                staticProperty;

            if (!hasOwn.call(classObject.staticProperties, name)) {
                throw new PHPFatalError(PHPFatalError.UNDECLARED_STATIC_PROPERTY, {
                    className: classObject.name,
                    propertyName: name
                });
            }

            staticProperty = classObject.staticProperties[name];

            // Property is private; may only be read from methods of this class and not derivatives
            if (staticProperty.getVisibility() === 'private') {
                currentClass = classObject.callStack.getCurrent().getScope().getCurrentClass();

                if (!currentClass || currentClass.name !== classObject.name) {
                    throw new PHPFatalError(PHPFatalError.CANNOT_ACCESS_PROPERTY, {
                        className: classObject.name,
                        propertyName: name,
                        visibility: 'private'
                    });
                }
                // Property is protected; may be read from methods of this class and methods of derivatives
            } else if (staticProperty.getVisibility() === 'protected') {
                currentClass = classObject.callStack.getCurrent().getScope().getCurrentClass();

                if (!currentClass || (classObject.name !== currentClass.name && !currentClass.extends(classObject))) {
                    throw new PHPFatalError(PHPFatalError.CANNOT_ACCESS_PROPERTY, {
                        className: classObject.name,
                        propertyName: name,
                        visibility: 'protected'
                    });
                }
            }

            return staticProperty;
        },

        hasStaticPropertyByName: function (name) {
            return hasOwn.call(this.staticProperties, name);
        },

        /**
         * Creates a new instance of this class
         *
         * @param {Value[]} args
         * @returns {ObjectValue}
         */
        instantiate: function (args) {
            var classObject = this,
                nativeObject = Object.create(classObject.InternalClass.prototype),
                objectValue = classObject.valueFactory.createObject(nativeObject, classObject);

            classObject.InternalClass.apply(
                // Always use the native object as `this` regardless of coercion status,
                // so that new native properties may be added to the object
                nativeObject,
                classObject.autoCoercionEnabled ?
                    _.map(args, function (arg) {
                        return arg.getNative();
                    }) :
                    args
            );

            classObject.construct(objectValue, args);

            return objectValue;
        },

        is: function (className) {
            var classObject = this,
                interfaceMatches = false;

            // Case-insensitively compare the fully-qualified class paths
            if (classObject.name.toLowerCase() === className.toLowerCase()) {
                return true;
            }

            // Iterate over all the interfaces implemented by this class: if any of them
            // are the requested class or extend from it, return true
            _.each(classObject.interfaceNames, function (interfaceName) {
                var interfaceObject = classObject.namespaceScope.getClass(interfaceName);

                if (interfaceObject.is(className)) {
                    interfaceMatches = true;
                    return false;
                }
            });

            if (interfaceMatches) {
                return true;
            }

            if (classObject.superClass) {
                return classObject.superClass.is(className);
            }

            return false;
        },

        /**
         * Returns true if auto-coercion is enabled, and false otherwise.
         * Constructor and method arguments will be unwrapped to native JS values when enabled
         *
         * @returns {boolean}
         */
        isAutoCoercionEnabled: function () {
            return this.autoCoercionEnabled;
        },

        /**
         * Unwraps instances of this class with the defined unwrapper if one has been set,
         * otherwise wraps them in PHPObject
         *
         * @param {ObjectValue} instance
         * @param {object} nativeObject
         * @returns {*|PHPObject}
         */
        unwrapInstanceForJS: function (instance, nativeObject) {
            var classObject = this;

            if (classObject.unwrapper) {
                return classObject.unwrapper.call(
                    classObject.autoCoercionEnabled ? nativeObject : instance
                );
            }

            // Return a wrapper object that presents a promise-based API
            // for calling methods of PHP objects in sync or async mode
            return classObject.valueFactory.createPHPObject(instance);
        }
    });

    return Class;
}, {strict: true});

},{"./Reference/StaticProperty":119,"microdash":28,"pauser":85,"phpcommon":87}],97:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

module.exports = require('pauser')([
    require('microdash')
], function (
    _
) {
    var MAGIC_AUTOLOAD_FUNCTION = '__autoload';

    function ClassAutoloader(valueFactory) {
        this.globalNamespace = null;
        this.splStack = null;
        this.valueFactory = valueFactory;
    }

    _.extend(ClassAutoloader.prototype, {
        appendAutoloadCallable: function (autoloadCallable) {
            var autoloader = this,
                splStack = autoloader.splStack;

            if (!splStack) {
                splStack = [];
                autoloader.splStack = splStack;
            }

            splStack.push(autoloadCallable);
        },

        autoloadClass: function (name) {
            var autoloader = this,
                globalNamespace = autoloader.globalNamespace,
                magicAutoloadFunction,
                splStack = autoloader.splStack;

            if (splStack) {
                _.each(splStack, function (autoloadCallable) {
                    autoloadCallable.call([autoloader.valueFactory.createString(name)], globalNamespace);

                    if (globalNamespace.hasClass(name)) {
                        // Autoloader has defined the class: no need to call any further autoloaders
                        return false;
                    }
                });
            } else {
                magicAutoloadFunction = globalNamespace.getOwnFunction(MAGIC_AUTOLOAD_FUNCTION);

                if (magicAutoloadFunction) {
                    magicAutoloadFunction(autoloader.valueFactory.createString(name));
                }
            }
        },

        removeAutoloadCallable: function (autoloadCallable) {
            var found = false,
                splStack = this.splStack;

            if (!splStack) {
                // SPL stack has not been enabled: nothing to do
                return false;
            }

            _.each(splStack, function (existingAutoloadCallable, index) {
                // Callables may be different value types or different objects,
                // so compare using the *Value API
                if (existingAutoloadCallable.isEqualTo(autoloadCallable).getNative()) {
                    found = true;
                    splStack.splice(index, 1);
                    return false;
                }
            });

            return found;
        },

        setGlobalNamespace: function (globalNamespace) {
            this.globalNamespace = globalNamespace;
        }
    });

    return ClassAutoloader;
}, {strict: true});

},{"microdash":28,"pauser":85}],98:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

module.exports = require('pauser')([
    require('microdash')
], function (
    _
) {
    /**
     * @param {ClosureFactory} closureFactory
     * @param {ValueFactory} valueFactory
     * @param {Namespace} namespace
     * @param {Function} unwrappedFunction
     * @param {Function} wrappedFunction
     * @param {Scope} enclosingScope
     * @param {ObjectValue|null} thisObject
     * @constructor
     */
    function Closure(
        closureFactory,
        valueFactory,
        namespace,
        enclosingScope,
        unwrappedFunction,
        wrappedFunction,
        thisObject
    ) {
        /**
         * @type {ClosureFactory}
         */
        this.closureFactory = closureFactory;
        /**
         * @type {Scope}
         */
        this.enclosingScope = enclosingScope;
        /**
         * @type {Namespace}
         */
        this.namespace = namespace;
        /**
         * @type {ObjectValue|null}
         */
        this.thisObject = thisObject;
        /**
         * @type {Function}
         */
        this.unwrappedFunction = unwrappedFunction;
        /**
         * @type {ValueFactory}
         */
        this.valueFactory = valueFactory;
        /**
         * @type {Function}
         */
        this.wrappedFunction = wrappedFunction;
    }

    _.extend(Closure.prototype, {
        /**
         * Creates a new closure identical to this one,
         * but bound to the specified `$this` object and class scope
         *
         * @param {ObjectValue|NullValue} thisObject
         * @param {Class|undefined} scopeClass
         * @returns {closure.enclosingScope}
         */
        bind: function (thisObject, scopeClass) {
            var closure = this;

            return closure.closureFactory.create(
                closure.enclosingScope,
                closure.unwrappedFunction,
                closure.namespace,
                scopeClass || null,
                thisObject
            );
        },

        /**
         * Invokes this closure with the provided arguments, returning its result
         *
         * @param {Value[]} args
         * @param {ObjectValue|undefined} thisObject
         * @returns {Value}
         */
        invoke: function (args, thisObject) {
            // Store the current PHP thisObj to set for the closure
            var closure = this;

            return closure.valueFactory.coerce(
                closure.wrappedFunction.apply(thisObject || closure.thisObject, args)
            );
        }
    });

    return Closure;
}, {strict: true});

},{"microdash":28,"pauser":85}],99:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

module.exports = require('pauser')([
    require('microdash')
], function (
    _
) {
    /**
     * @param {FunctionFactory} functionFactory
     * @param {ValueFactory} valueFactory
     * @param {class} Closure
     * @constructor
     */
    function ClosureFactory(
        functionFactory,
        valueFactory,
        Closure
    ) {
        /**
         * @type {class}
         */
        this.Closure = Closure;
        /**
         * @type {FunctionFactory}
         */
        this.functionFactory = functionFactory;
        /**
         * @type {ValueFactory}
         */
        this.valueFactory = valueFactory;
    }

    _.extend(ClosureFactory.prototype, {
        /**
         * Creates a new Closure
         *
         * @param {Scope} enclosingScope
         * @param {Function} unwrappedFunction
         * @param {Namespace} namespace
         * @param {Class|undefined} scopeClass
         * @param {ObjectValue|NullValue|null} thisObject Null for a static closure, the object to use otherwise
         * @returns {Closure}
         */
        create: function (enclosingScope, unwrappedFunction, namespace, scopeClass, thisObject) {
            var factory = this,
                wrappedFunction;

            // If a bound object is specified but no class scope, use the class of the object
            if (!scopeClass) {
                scopeClass = thisObject && thisObject.getType() !== 'null' ?
                    thisObject.getClass() :
                    null;
            }

            wrappedFunction = factory.functionFactory.create(
                namespace,
                scopeClass,
                unwrappedFunction
            );

            return new factory.Closure(
                factory,
                factory.valueFactory,
                namespace,
                enclosingScope,
                unwrappedFunction,
                wrappedFunction,
                thisObject
            );
        }
    });

    return ClosureFactory;
}, {strict: true});

},{"microdash":28,"pauser":85}],100:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    INCLUDE_OPTION = 'include',
    PATH = 'path',
    hasOwn = {}.hasOwnProperty,
    pauser = require('pauser'),
    Call = require('./Call'),
    ExitValueWrapper = require('./Value/Exit'),
    KeyValuePair = require('./KeyValuePair'),
    List = require('./List'),
    NamespaceScopeWrapper = require('./NamespaceScope'),
    ObjectValueWrapper = require('./Value/Object'),
    Promise = require('lie');

function Engine(
    environment,
    topLevelScope,
    phpCommon,
    options,
    wrapper,
    pausable
) {
    this.environment = environment;
    this.options = _.extend(
        {
            'path': null
        },
        options || {}
    );
    this.pausable = pausable;
    this.phpCommon = phpCommon;
    this.topLevelScope = topLevelScope || null;
    this.wrapper = wrapper;
}

_.extend(Engine.prototype, {
    createPause: function () {
        var engine = this;

        if (!engine.pausable) {
            throw new Error('Pausable is not available');
        }

        return engine.pausable.createPause();
    },

    defineSuperGlobal: function (name, nativeValue) {
        var engine = this,
            valueFactory = engine.environment.getState().getValueFactory(),
            value = valueFactory.coerce(nativeValue);

        engine.environment.defineSuperGlobal(name, value);
    },

    defineSuperGlobalAccessor: function (name, valueGetter, valueSetter) {
        this.environment.defineSuperGlobalAccessor(name, valueGetter, valueSetter);
    },

    execute: function () {
        var callStack,
            engine = this,
            environment = engine.environment,
            globalNamespace,
            globalScope,
            includedPaths = {},
            options = engine.options,
            path = options[PATH],
            isMainProgram = path === null,
            pausable = engine.pausable,
            phpCommon = engine.phpCommon,
            Exception = phpCommon.Exception,
            PHPError = phpCommon.PHPError,
            PHPException,
            PHPFatalError = phpCommon.PHPFatalError,
            referenceFactory,
            state,
            stderr = engine.getStderr(),
            stdin = engine.getStdin(),
            stdout = engine.getStdout(),
            tools,
            valueFactory,
            wrapper = engine.wrapper,
            unwrap = function (wrapper) {
                return pausable ? wrapper.async(pausable) : wrapper.sync();
            },
            ExitValue = unwrap(ExitValueWrapper),
            NamespaceScope = unwrap(NamespaceScopeWrapper),
            ObjectValue = unwrap(ObjectValueWrapper),
            topLevelScope;

        function include(includedPath, includeScope) {
            var done = false,
                pause = null,
                result,
                subOptions = _.extend({}, options, {
                    'path': includedPath
                });

            function completeWith(moduleResult) {
                done = true;

                if (pause) {
                    if (moduleResult instanceof ExitValue) {
                        pause.throw(moduleResult);
                        return;
                    }

                    pause.resume(moduleResult);
                } else {
                    if (moduleResult instanceof ExitValue) {
                        throw moduleResult;
                    }

                    result = moduleResult;
                }
            }

            if (!subOptions[INCLUDE_OPTION]) {
                throw new Exception(
                    'include(' + includedPath + ') :: No "include" transport is available for loading the module.'
                );
            }

            function resolve(valueOrModule) {
                var executeResult;

                // Handle wrapper function being returned from loader for module
                if (_.isFunction(valueOrModule)) {
                    executeResult = valueOrModule(subOptions, environment, includeScope).execute();

                    if (!pausable) {
                        completeWith(executeResult);
                        return;
                    }

                    executeResult.then(
                        completeWith,
                        function (error) {
                            pause.throw(error);
                        }
                    );

                    return;
                }

                // Handle PHP code string being returned from loader for module
                if (_.isString(module)) {
                    throw new Exception('include(' + includedPath + ') :: Returning a PHP string is not supported');
                }

                // Handle a value object being returned as the module's return value
                if (valueFactory.isValue(valueOrModule)) {
                    completeWith(valueOrModule);
                    return;
                }

                throw new Exception('include(' + includedPath + ') :: Module is in a weird format');
            }

            function reject() {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'include(' + includedPath + '): failed to open stream: No such file or directory'
                );
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'include(): Failed opening \'' + includedPath + '\' for inclusion'
                );

                completeWith(valueFactory.createBoolean(false));
            }

            subOptions[INCLUDE_OPTION](includedPath, {
                reject: reject,
                resolve: resolve
            }, path, valueFactory);

            if (done) {
                return result;
            }

            if (!pausable) {
                // Pausable is not available, so we cannot yield while the module is loaded
                throw new Exception('include(' + includedPath + ') :: Async support not enabled');
            }

            pause = pausable.createPause();
            pause.now();
        }

        function includeOnce(includedPath, scope) {
            if (hasOwn.call(includedPaths, includedPath)) {
                return valueFactory.createInteger(1);
            }

            includedPaths[includedPath] = true;

            return include(includedPath, scope);
        }

        function getNormalizedPath() {
            return path === null ? '(program)' : path;
        }

        state = environment.getState();
        referenceFactory = state.getReferenceFactory();
        valueFactory = state.getValueFactory();
        globalNamespace = state.getGlobalNamespace();
        callStack = state.getCallStack();
        globalScope = state.getGlobalScope();
        PHPException = state.getPHPExceptionClass();
        // Use the provided top-level scope if specified, otherwise use the global scope
        // (used eg. when an `include(...)` is used inside a function)
        topLevelScope = engine.topLevelScope || globalScope;

        tools = {
            createClosure: function (func, scope) {
                return valueFactory.createObject(
                    scope.createClosure(func),
                    globalNamespace.getClass('Closure')
                );
            },
            createInstance: unwrap(pauser([_], function (_) {
                return function (namespaceScope, classNameValue, args) {
                    var className = classNameValue.getNative(),
                        classObject,
                        nativeObject,
                        objectValue;

                    // Detect whether a JS function is being instantiated as a class from PHP
                    if (_.isFunction(className)) {
                        // Create an instance of the class, not calling constructor
                        nativeObject = Object.create(className.prototype);
                        objectValue = valueFactory.createFromNative(nativeObject);

                        // Call the constructor on the newly created instance, unwrapping arguments
                        className.apply(nativeObject, _.map(args, function (argValue) {
                            return argValue.getNative();
                        }));

                        return objectValue;
                    }

                    classObject = namespaceScope.getClass(className);

                    return classObject.instantiate(args);
                };
            })),
            createKeyValuePair: function (key, value) {
                return new KeyValuePair(key, value);
            },
            createList: function (elements) {
                return new List(valueFactory, elements);
            },
            createNamespaceScope: function (namespace) {
                return new NamespaceScope(globalNamespace, valueFactory, namespace);
            },
            exit: function (statusValue) {
                throw valueFactory.createExit(statusValue);
            },
            getPath: function () {
                return valueFactory.createString(getNormalizedPath());
            },
            getPathDirectory: function () {
                return valueFactory.createString(getNormalizedPath().replace(/\/[^\/]+$/, ''));
            },
            implyArray: function (variable) {
                // Undefined variables and variables containing null may be implicitly converted to arrays
                if (!variable.isDefined() || variable.getValue().getType() === 'null') {
                    variable.setValue(valueFactory.createArray([]));
                }

                return variable.getValue();
            },
            implyObject: function (variable) {
                return variable;
            },
            includeOnce: includeOnce,
            include: include,
            referenceFactory: referenceFactory,
            requireOnce: include,
            require: include,
            throwCannotBreakOrContinue: function (levels) {
                throw new PHPFatalError(PHPFatalError.CANNOT_BREAK_OR_CONTINUE, {
                    'levels': levels,
                    'suffix': levels === 1 ? '' : 's'
                });
            },
            topLevelScope: topLevelScope,
            valueFactory: valueFactory
        };

        // Push the 'main' global scope call onto the stack
        callStack.push(new Call(globalScope));

        function handleError(error, reject) {
            if (error instanceof ExitValue) {
                return error;
            }

            if (error instanceof ObjectValue) {
                // Uncaught PHP Exceptions become E_FATAL errors
                (function (value) {
                    var error = value.getForThrow();

                    if (!(error instanceof PHPException)) {
                        throw new Exception('Weird value class thrown: ' + value.getClassName());
                    }

                    error = new PHPFatalError(
                        PHPFatalError.UNCAUGHT_EXCEPTION,
                        {
                            name: value.getClassName()
                        }
                    );

                    if (isMainProgram) {
                        stderr.write(error.message);
                    }

                    reject(error);
                }(error));

                return;
            }

            if (error instanceof PHPError) {
                if (isMainProgram) {
                    stderr.write(error.message);
                }

                reject(error);
                return;
            }

            reject(error);
        }

        // Use asynchronous mode if Pausable is available
        if (pausable) {
            return new Promise(function (resolve, reject) {
                var code = 'return (' +
                    wrapper.toString() +
                    '(stdin, stdout, stderr, tools, globalNamespace));';

                pausable.execute(code, {
                    strict: true,
                    expose: {
                        stdin: stdin,
                        stdout: stdout,
                        stderr: stderr,
                        tools: tools,
                        globalNamespace: globalNamespace
                    }
                }).then(resolve, function (error) {
                    var result = handleError(error, reject);

                    if (result) {
                        resolve(result);
                    }
                });
            });
        }

        // Otherwise load the module synchronously
        try {
            return wrapper(stdin, stdout, stderr, tools, globalNamespace);
        } catch (error) {
            return handleError(error, function (error) {
                throw error;
            });
        }
    },

    expose: function (object, name) {
        this.environment.expose(object, name);
    },

    getConstant: function (name) {
        return this.environment.getConstant(name);
    },

    getStderr: function () {
        return this.environment.getStderr();
    },

    getStdin: function () {
        return this.environment.getStdin();
    },

    getStdout: function () {
        return this.environment.getStdout();
    }
});

module.exports = Engine;

},{"./Call":93,"./KeyValuePair":105,"./List":106,"./NamespaceScope":109,"./Value/Exit":131,"./Value/Object":135,"lie":27,"microdash":28,"pauser":85}],101:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash');

function Environment(state) {
    this.state = state;
}

_.extend(Environment.prototype, {
    defineSuperGlobal: function (name, value) {
        this.state.defineSuperGlobal(name, value);
    },

    defineSuperGlobalAccessor: function (name, valueGetter, valueSetter) {
        this.state.defineSuperGlobalAccessor(name, valueGetter, valueSetter);
    },

    expose: function (object, name) {
        this.state.getGlobalScope().expose(object, name);
    },

    getConstant: function (name) {
        return this.state.getConstant(name);
    },

    getOptions: function () {
        return this.state.getOptions();
    },

    getState: function () {
        return this.state;
    },

    getStderr: function () {
        return this.state.getStderr();
    },

    getStdin: function () {
        return this.state.getStdin();
    },

    getStdout: function () {
        return this.state.getStdout();
    }
});

module.exports = Environment;

},{"microdash":28}],102:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    slice = [].slice;

/**
 * @param {ScopeFactory} scopeFactory
 * @param {CallFactory} callFactory
 * @param {ValueFactory} valueFactory
 * @param {CallStack} callStack
 * @constructor
 */
function FunctionFactory(scopeFactory, callFactory, valueFactory, callStack) {
    /**
     * @type {CallFactory}
     */
    this.callFactory = callFactory;
    /**
     * @type {CallStack}
     */
    this.callStack = callStack;
    /**
     * @type {ScopeFactory}
     */
    this.scopeFactory = scopeFactory;
    /**
     * @type {ValueFactory}
     */
    this.valueFactory = valueFactory;
}

_.extend(FunctionFactory.prototype, {
    /**
     * Wraps the specified function in another that handles the PHP call stack and scoping
     *
     * @param {Namespace} namespace
     * @param {Class|null} currentClass
     * @param {Function} func
     * @param {string|null} name
     * @param {ObjectValue|null} currentObject
     * @returns {Function}
     */
    create: function (namespace, currentClass, func, name, currentObject) {
        var factory = this,
            wrapperFunc = function () {
                var thisObject = currentObject || this,
                    scope,
                    call,
                    result;

                if (!factory.valueFactory.isValue(thisObject)) {
                    thisObject = null;
                }

                scope = factory.scopeFactory.create(namespace, currentClass, wrapperFunc, thisObject);
                call = factory.callFactory.create(scope);

                // Push the call onto the stack
                factory.callStack.push(call);

                try {
                    result = func.apply(scope, slice.call(arguments));
                } finally {
                    // Pop the call off the stack when done
                    factory.callStack.pop();
                }

                return result;
            };

        wrapperFunc.funcName = name || namespace.getPrefix() + '{closure}';

        return wrapperFunc;
    }
});

module.exports = FunctionFactory;

},{"microdash":28}],103:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash');

function INIState() {
    this.settings = {
        'include_path': '.'
    };
}

_.extend(INIState.prototype, {
    get: function (name) {
        return this.settings[name];
    },

    set: function (name, value) {
        this.settings[name] = value;
    }
});

module.exports = INIState;

},{"microdash":28}],104:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash');

function KeyReferencePair(key, reference) {
    this.key = key;
    this.reference = reference;
}

_.extend(KeyReferencePair.prototype, {
    getKey: function () {
        return this.key;
    },

    getReference: function () {
        return this.reference;
    }
});

module.exports = KeyReferencePair;

},{"microdash":28}],105:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash');

function KeyValuePair(key, value) {
    this.key = key;
    this.value = value;
}

_.extend(KeyValuePair.prototype, {
    getKey: function () {
        return this.key;
    },

    getValue: function () {
        return this.value;
    }
});

module.exports = KeyValuePair;

},{"microdash":28}],106:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash');

function List(valueFactory, elements) {
    this.elements = elements;
    this.valueFactory = valueFactory;
}

_.extend(List.prototype, {
    setValue: function (value) {
        var list = this;

        if (value.getType() === 'array') {
            _.each(list.elements, function (reference, index) {
                reference.setValue(value.getElementByIndex(index).getValue());
            });
        } else {
            // Non-array value assigned to list, all references should just be nulled
            _.each(list.elements, function (reference) {
                reference.setValue(list.valueFactory.createNull());
            });
        }

        return value;
    }
});

module.exports = List;

},{"microdash":28}],107:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

module.exports = require('pauser')([
    require('microdash'),
    require('phpcommon'),
    require('./Class')
], function (
    _,
    phpCommon,
    Class
) {
    var IS_STATIC = 'isStatic',
        MAGIC_CONSTRUCT = '__construct',
        hasOwn = {}.hasOwnProperty,
        PHPError = phpCommon.PHPError,
        PHPFatalError = phpCommon.PHPFatalError;

    function Namespace(callStack, valueFactory, namespaceFactory, functionFactory, classAutoloader, parent, name) {
        this.callStack = callStack;
        this.children = {};
        this.classAutoloader = classAutoloader;
        this.classes = {};
        this.constants = {};
        this.functionFactory = functionFactory;
        this.functions = {};
        this.name = name;
        this.namespaceFactory = namespaceFactory;
        this.parent = parent;
        this.valueFactory = valueFactory;
    }

    _.extend(Namespace.prototype, {
        defineClass: function (name, definition, namespaceScope) {
            var classObject,
                constants,
                constructorName = null,
                methodData = {},
                methods = {},
                namespace = this,
                proxyConstructor,
                staticProperties,
                InternalClass;

            if (_.isFunction(definition)) {
                // Create a new, empty native constructor so that we can avoid calling
                // the original if the derived class does not call parent::__construct(...)
                InternalClass = function () {};
                InternalClass.prototype = Object.create(definition.prototype);
                proxyConstructor = function () {
                    // Call the original native constructor
                    definition.apply(this, arguments);

                    // Call magic __construct method if defined for the original native class
                    if (definition.prototype[MAGIC_CONSTRUCT]) {
                        definition.prototype[MAGIC_CONSTRUCT].apply(this, arguments);
                    }
                };
                proxyConstructor.data = methodData;
                InternalClass.prototype[MAGIC_CONSTRUCT] = proxyConstructor;
                constructorName = MAGIC_CONSTRUCT;
            } else {
                InternalClass = function () {
                    var instance = this;

                    if (definition.superClass) {
                        definition.superClass.getInternalClass().call(this);
                    }

                    _.each(definition.properties, function (value, name) {
                        instance[name] = value;
                    });
                };

                // Prevent native 'constructor' property from erroneously being detected as PHP class method
                delete InternalClass.prototype.constructor;

                if (definition.superClass) {
                    InternalClass.prototype = Object.create(definition.superClass.getInternalClass().prototype);
                }

                _.each(definition.methods, function (data, methodName) {
                    // PHP5-style __construct magic method takes precedence
                    if (methodName === '__construct') {
                        if (constructorName) {
                            namespace.callStack.raiseError(PHPError.E_STRICT, 'Redefining already defined constructor for class ' + name);
                        }

                        constructorName = methodName;
                    }

                    if (!constructorName && methodName === name) {
                        constructorName = methodName;
                    }

                    methods[methodName] = data;
                });

                staticProperties = definition.staticProperties;
                constants = definition.constants;
            }

            classObject = new Class(
                namespace.valueFactory,
                namespace.callStack,
                namespace.getPrefix() + name,
                constructorName,
                InternalClass,
                staticProperties,
                constants,
                definition.superClass,
                definition.interfaces,
                namespaceScope
            );

            _.forOwn(methods, function (data, methodName) {
                var method = namespace.functionFactory.create(
                        namespace,
                        classObject,
                        data.method,
                        methodName
                    );

                method[IS_STATIC] = data[IS_STATIC];
                method.data = methodData;

                InternalClass.prototype[methodName] = method;
            });

            methodData.classObject = classObject;

            namespace.classes[name.toLowerCase()] = classObject;

            return classObject;
        },

        /**
         * Defines a constant for the current namespace, optionally making it case-insensitive
         *
         * @param {string} name
         * @param {Value} value
         * @param {object|undefined} options
         */
        defineConstant: function (name, value, options) {
            var caseInsensitive;

            options = options || {};

            caseInsensitive = !!options.caseInsensitive;

            if (caseInsensitive) {
                name = name.toLowerCase();
            }

            this.constants[name] = {
                caseInsensitive: caseInsensitive,
                value: value
            };
        },

        defineFunction: function (name, func) {
            var namespace = this;

            if (namespace.name === '') {
                if (/__autoload/i.test(name) && func.length !== 1) {
                    throw new PHPFatalError(PHPFatalError.EXPECT_EXACTLY_1_ARG, {name: name.toLowerCase()});
                }
            }

            namespace.functions[name.toLowerCase()] = namespace.functionFactory.create(
                namespace,
                // Class will always be null for 'normal' functions
                // as defining a function inside a class will define it
                // inside the current namespace instead.
                null,
                func,
                name
            );
        },

        getClass: function (name) {
            var lowerName = name.toLowerCase(),
                namespace = this,
                parsed = namespace.parseClassName(name);

            if (parsed) {
                return parsed.namespace.getClass(parsed.name);
            }

            if (!hasOwn.call(namespace.classes, lowerName)) {
                // Try to autoload the class
                namespace.classAutoloader.autoloadClass(namespace.getPrefix() + name);

                // Raise an error if it is still not defined
                if (!hasOwn.call(namespace.classes, lowerName)) {
                    throw new PHPFatalError(PHPFatalError.CLASS_NOT_FOUND, {name: namespace.getPrefix() + name});
                }
            }

            return namespace.classes[lowerName];
        },

        /**
         * Fetches the value of a constant if it is defined. If it is not defined,
         * then it will either raise a notice and return the name of the constant as a string,
         * or throw an exception, depending on whether it is a namespaced constant
         *
         * @param {string} name
         * @param {boolean} usesNamespace
         * @returns {Value}
         */
        getConstant: function (name, usesNamespace) {
            var namespace = this,
                constant = namespace.getConstantDefinition(name);

            if (constant) {
                return constant.value;
            }

            if (usesNamespace) {
                throw new PHPFatalError(PHPFatalError.UNDEFINED_CONSTANT, {name: namespace.getPrefix() + name});
            } else {
                namespace.callStack.raiseError(PHPError.E_NOTICE, 'Use of undefined constant ' + name + ' - assumed \'' + name + '\'');

                return this.valueFactory.createString(name);
            }
        },

        getDescendant: function (name) {
            var namespace = this,
                subNamespace = namespace;

            _.each(name.split('\\'), function (part) {
                if (!hasOwn.call(subNamespace.children, part.toLowerCase())) {
                    subNamespace.children[part.toLowerCase()] = namespace.namespaceFactory.create(
                        subNamespace,
                        part
                    );
                }

                subNamespace = subNamespace.children[part.toLowerCase()];
            });

            return subNamespace;
        },

        getFunction: function (name) {
            var globalNamespace,
                match,
                namespace = this,
                path,
                subNamespace;

            if (_.isFunction(name)) {
                return name;
            }

            match = name.match(/^(.*?)\\([^\\]+)$/);

            if (match) {
                path = match[1];
                name = match[2];

                subNamespace = namespace.getDescendant(path);

                return subNamespace.getFunction(name);
            }

            if (hasOwn.call(namespace.functions, name.toLowerCase())) {
                return namespace.functions[name.toLowerCase()];
            }

            globalNamespace = namespace.getGlobal();

            if (hasOwn.call(globalNamespace.functions, name.toLowerCase())) {
                return globalNamespace.functions[name.toLowerCase()];
            }

            throw new PHPFatalError(PHPFatalError.CALL_TO_UNDEFINED_FUNCTION, {name: namespace.getPrefix() + name});
        },

        getGlobal: function () {
            var namespace = this;

            return namespace.name === '' ? namespace : namespace.getParent().getGlobal();
        },

        getGlobalNamespace: function () {
            return this.getGlobal();
        },

        getName: function () {
            var namespace = this;

            if (namespace.name === '') {
                return '';
            }

            return (namespace.parent ? namespace.parent.getPrefix() : '') + namespace.name;
        },

        getOwnFunction: function (name) {
            var namespace = this;

            if (hasOwn.call(namespace.functions, name.toLowerCase())) {
                return namespace.functions[name.toLowerCase()];
            }

            return null;
        },

        getParent: function () {
            return this.parent;
        },

        getPrefix: function () {
            var name = this.getName();

            if (name !== '') {
                name += '\\';
            }

            return name;
        },

        /**
         * Fetches the definition object for a constant, or null if it is not defined
         *
         * @param {string} name
         * @returns {object}
         */
        getConstantDefinition: function (name) {
            var globalNamespace,
                lowercaseName,
                namespace = this;

            if (hasOwn.call(namespace.constants, name)) {
                return namespace.constants[name];
            }

            lowercaseName = name.toLowerCase();

            if (
                hasOwn.call(namespace.constants, lowercaseName) &&
                namespace.constants[lowercaseName].caseInsensitive
            ) {
                return namespace.constants[lowercaseName];
            }

            globalNamespace = namespace.getGlobal();

            if (hasOwn.call(globalNamespace.constants, name)) {
                return globalNamespace.constants[name];
            }

            if (
                hasOwn.call(globalNamespace.constants, lowercaseName) &&
                globalNamespace.constants[lowercaseName].caseInsensitive
            ) {
                return globalNamespace.constants[lowercaseName];
            }

            return null;
        },

        hasClass: function (name) {
            var lowerName = name.toLowerCase(),
                namespace = this,
                parsed = namespace.parseClassName(name);

            if (parsed) {
                return parsed.namespace.hasClass(parsed.name);
            }

            return hasOwn.call(namespace.classes, lowerName);
        },

        /**
         * Returns true if this namespace defines the specified constant, and false otherwise.
         * If the constant is case-insensitive, then it will be returned for any case
         *
         * @param {string} name
         * @returns {boolean}
         */
        hasConstant: function (name) {
            return this.getConstantDefinition(name) !== null;
        },

        parseClassName: function (name) {
            var match = name.match(/^(.*?)\\([^\\]+)$/),
                namespace = this,
                path,
                subNamespace;

            if (match) {
                path = match[1];
                name = match[2];

                subNamespace = namespace.getDescendant(path);

                return {
                    namespace: subNamespace,
                    name: name
                };
            }

            return null;
        },

        resolveClass: function (name) {
            return name;
        }
    });

    return Namespace;
}, {strict: true});

},{"./Class":96,"microdash":28,"pauser":85,"phpcommon":87}],108:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash');

function NamespaceFactory(Namespace, callStack, functionFactory, valueFactory, classAutoloader) {
    this.callStack = callStack;
    this.classAutoloader = classAutoloader;
    this.functionFactory = functionFactory;
    this.Namespace = Namespace;
    this.valueFactory = valueFactory;
}

_.extend(NamespaceFactory.prototype, {
    create: function (parentNamespace, name) {
        var factory = this;

        return new factory.Namespace(
            factory.callStack,
            factory.valueFactory,
            factory,
            factory.functionFactory,
            factory.classAutoloader,
            parentNamespace || null,
            name || ''
        );
    }
});

module.exports = NamespaceFactory;

},{"microdash":28}],109:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

module.exports = require('pauser')([
    require('microdash'),
    require('phpcommon')
], function (
    _,
    phpCommon
) {
    var hasOwn = {}.hasOwnProperty,
        PHPFatalError = phpCommon.PHPFatalError;

    function NamespaceScope(globalNamespace, valueFactory, namespace) {
        this.globalNamespace = globalNamespace;
        this.imports = {};
        this.namespace = namespace;
        this.valueFactory = valueFactory;
    }

    _.extend(NamespaceScope.prototype, {
        getClass: function (name) {
            var resolvedClass = this.resolveClass(name);

            return resolvedClass.namespace.getClass(resolvedClass.name);
        },

        getConstant: function (name) {
            var match,
                scope = this,
                namespace = scope.namespace,
                path,
                prefix,
                usesNamespace = false;

            // Check whether the constant path is absolute, so no 'use's apply
            if (name.charAt(0) === '\\') {
                usesNamespace = true;
                match = name.match(/^\\(.*?)\\([^\\]+)$/);

                if (match) {
                    path = match[1];
                    name = match[2];
                    namespace = scope.globalNamespace.getDescendant(path);
                } else {
                    name = name.substr(1);
                }
                // Check whether the namespace prefix is an alias
            } else {
                match = name.match(/^([^\\]+)(.*?)\\([^\\]+)$/);

                if (match) {
                    usesNamespace = true;
                    prefix = match[1];
                    path = match[2];
                    name = match[3];

                    if (hasOwn.call(scope.imports, prefix.toLowerCase())) {
                        namespace = scope.globalNamespace.getDescendant(scope.imports[prefix.toLowerCase()].substr(1) + path);
                    } else {
                        // Not an alias: look up the namespace path relative to this namespace
                        // (ie. 'namespace Test { echo Our\CONSTANT; }' -> 'echo \Test\Our\CONSTANT;')
                        namespace = scope.globalNamespace.getDescendant(namespace.getPrefix() + prefix + path);
                    }
                }
            }

            return namespace.getConstant(name, usesNamespace);
        },

        getFunction: function (name) {
            var match,
                scope = this,
                namespace = scope.namespace,
                path,
                prefix;

            // Check whether the function path is absolute, so no 'use's apply
            if (name.charAt(0) === '\\') {
                match = name.match(/^\\(.*?)\\([^\\]+)$/);

                if (match) {
                    path = match[1];
                    name = match[2];
                    namespace = scope.globalNamespace.getDescendant(path);
                } else {
                    name = name.substr(1);
                    namespace = scope.globalNamespace;
                }
                // Check whether the namespace prefix is an alias
            } else {
                match = name.match(/^([^\\]+)(.*?)\\([^\\]+)$/);

                if (match) {
                    prefix = match[1];
                    path = match[2];
                    name = match[3];

                    if (hasOwn.call(scope.imports, prefix.toLowerCase())) {
                        namespace = scope.globalNamespace.getDescendant(scope.imports[prefix.toLowerCase()].substr(1) + path);
                    } else {
                        // Not an alias: look up the namespace path relative to this namespace
                        // (ie. 'namespace Test { Our\Func(); }' -> '\Test\Our\Func();')
                        namespace = scope.globalNamespace.getDescendant(namespace.getPrefix() + prefix + path);
                    }
                }
            }

            return namespace.getFunction(name);
        },

        getGlobalNamespace: function () {
            return this.globalNamespace;
        },

        getNamespaceName: function () {
            var scope = this;

            return scope.valueFactory.createString(scope.namespace.getName());
        },

        resolveClass: function (name) {
            var match,
                scope = this,
                namespace = scope.namespace,
                path,
                prefix;

            // Check whether the entire class name is aliased
            if (hasOwn.call(scope.imports, name.toLowerCase())) {
                name = scope.imports[name.toLowerCase()];
                namespace = scope.globalNamespace;
            }

            // Check whether the class path is absolute, so no 'use's apply
            if (name.charAt(0) === '\\') {
                match = name.match(/^\\(.*?)\\([^\\]+)$/);

                if (match) {
                    path = match[1];
                    name = match[2];
                    namespace = scope.globalNamespace.getDescendant(path);
                } else {
                    // A class in the global namespace with explicit absolute path, eg. `\MyClass`
                    name = name.substr(1);
                    namespace = scope.globalNamespace;
                }
            // Check whether the namespace prefix is an alias
            } else {
                match = name.match(/^([^\\]+)(.*?)\\([^\\]+)$/);

                if (match) {
                    prefix = match[1];
                    path = match[2];

                    if (hasOwn.call(scope.imports, prefix.toLowerCase())) {
                        namespace = scope.globalNamespace.getDescendant(scope.imports[prefix.toLowerCase()].substr(1) + path);
                        name = match[3];
                    }
                }
            }

            return {namespace: namespace, name: name};
        },

        use: function (source, alias) {
            var scope = this,
                normalizedSource = source;

            if (!alias) {
                alias = source.replace(/^.*?([^\\]+)$/, '$1');
            }

            if (normalizedSource.charAt(0) !== '\\') {
                normalizedSource = '\\' + normalizedSource;
            }

            if (scope.imports[alias.toLowerCase()]) {
                throw new PHPFatalError(
                    PHPFatalError.NAME_ALREADY_IN_USE,
                    {
                        alias: alias,
                        source: source
                    }
                );
            }

            scope.imports[alias.toLowerCase()] = normalizedSource;
        }
    });

    return NamespaceScope;
}, {strict: true});

},{"microdash":28,"pauser":85,"phpcommon":87}],110:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    hasOwn = {}.hasOwnProperty;

/**
 * Represents a set of options for a running PHP application
 *
 * @param {object} options
 * @constructor
 */
function OptionSet(options) {
    /**
     * @type {Object}
     */
    this.options = options;
}

_.extend(OptionSet.prototype, {
    /**
     * Fetches the value of a single option by its name
     *
     * @param {string} name
     * @returns {*}
     */
    getOption: function (name) {
        var optionSet = this;

        return hasOwn.call(optionSet.options, name) ? optionSet.options[name] : null;
    },

    /**
     * Fetches all defined options
     *
     * @returns {Object}
     */
    getOptions: function () {
        return this.options;
    }
});

module.exports = OptionSet;

},{"microdash":28}],111:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    Promise = require('lie');

function PHPObject(pausable, valueFactory, objectValue) {
    this.objectValue = objectValue;
    this.pausable = pausable;
    this.valueFactory = valueFactory;
}

_.extend(PHPObject.prototype, {
    /**
     * Calls the specified method of the wrapped ObjectValue, returning a Promise.
     * Allows JS-land code to call objects exported/returned from PHP-land,
     * where asynchronous (blocking) operation is possible.
     *
     * @param {string} name
     * @returns {Promise}
     */
    callMethod: function (name) {
        var phpObject = this,
            args = [].slice.call(arguments, 1);

        // Arguments will be from JS-land, so coerce any to wrapped PHP value objects
        args = _.map(args, function (arg) {
            return phpObject.valueFactory.coerce(arg);
        });

        if (phpObject.pausable) {
            return new Promise(function (resolve, reject) {
                // Call the method via Pausable to allow for blocking operation
                phpObject.pausable.call(
                    phpObject.objectValue.callMethod,
                    [name, args],
                    phpObject.objectValue
                )
                    .then(resolve, reject);
            });
        }

        // Pausable is unavailable (non-blocking mode)
        return phpObject.objectValue.callMethod(name, args);
    }
});

module.exports = PHPObject;

},{"lie":27,"microdash":28}],112:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

module.exports = require('pauser')([
    require('microdash'),
    require('./builtin/builtins'),
    require('util'),
    require('./Reference/AccessorReference'),
    require('./Call'),
    require('./CallFactory'),
    require('./CallStack'),
    require('./ClassAutoloader'),
    require('./Closure'),
    require('./ClosureFactory'),
    require('./FunctionFactory'),
    require('./INIState'),
    require('./Namespace'),
    require('./NamespaceFactory'),
    require('./Reference/Null'),
    require('./ReferenceFactory'),
    require('./Scope'),
    require('./ScopeFactory'),
    require('./SuperGlobalScope'),
    require('./ValueFactory'),
    require('./Reference/Variable')
], function (
    _,
    builtinTypes,
    util,
    AccessorReference,
    Call,
    CallFactory,
    CallStack,
    ClassAutoloader,
    Closure,
    ClosureFactory,
    FunctionFactory,
    INIState,
    Namespace,
    NamespaceFactory,
    NullReference,
    ReferenceFactory,
    Scope,
    ScopeFactory,
    SuperGlobalScope,
    ValueFactory,
    VariableReference
) {
    var EXCEPTION_CLASS = 'Exception',
        setUpState = function (state, installedBuiltinTypes) {
            var globalNamespace = state.globalNamespace,
                internals = {
                    callStack: state.callStack,
                    classAutoloader: state.classAutoloader,
                    globalNamespace: globalNamespace,
                    iniState: state.iniState,
                    optionSet: state.optionSet,
                    pausable: state.pausable,
                    stdout: state.stdout,
                    valueFactory: state.valueFactory
                };

            function installFunctionGroup(groupFactory) {
                var groupBuiltins = groupFactory(internals);

                _.each(groupBuiltins, function (fn, name) {
                    globalNamespace.defineFunction(name, fn);
                });
            }

            function installClass(classFactory, name) {
                var definedUnwrapper = null,
                    enableAutoCoercion = true,
                    Class = classFactory(_.extend({}, internals, {
                        defineUnwrapper: function (unwrapper) {
                            definedUnwrapper = unwrapper;
                        },
                        disableAutoCoercion: function () {
                            enableAutoCoercion = false;
                        }
                    })),
                    classObject,
                    namespace = globalNamespace,
                    parsed = globalNamespace.parseClassName(name);

                if (name === EXCEPTION_CLASS) {
                    state.PHPException = Class;
                }

                if (parsed) {
                    namespace = parsed.namespace;
                    name = parsed.name;
                }

                classObject = namespace.defineClass(name, Class);

                if (definedUnwrapper) {
                    classObject.defineUnwrapper(definedUnwrapper);
                }

                if (enableAutoCoercion) {
                    classObject.enableAutoCoercion();
                }
            }

            function installConstantGroup(groupFactory) {
                var groupBuiltins = groupFactory(internals);

                _.each(groupBuiltins, function (value, name) {
                    globalNamespace.defineConstant(name, state.valueFactory.coerce(value));
                });
            }

            // Core builtins
            _.each(builtinTypes.functionGroups, installFunctionGroup);
            _.forOwn(builtinTypes.classes, installClass);
            _.each(builtinTypes.constantGroups, installConstantGroup);

            // Optional installed builtins
            _.each(installedBuiltinTypes.functionGroups, installFunctionGroup);
            _.forOwn(installedBuiltinTypes.classes, installClass);
            _.each(installedBuiltinTypes.constantGroups, installConstantGroup);
        };

    function PHPState(installedBuiltinTypes, stdin, stdout, stderr, pausable, optionSet) {
        var callStack = new CallStack(stderr),
            callFactory = new CallFactory(Call),
            valueFactory = new ValueFactory(pausable, callStack),
            referenceFactory = new ReferenceFactory(
                AccessorReference,
                NullReference,
                VariableReference,
                valueFactory
            ),
            classAutoloader = new ClassAutoloader(valueFactory),
            superGlobalScope = new SuperGlobalScope(callStack, valueFactory),
            scopeFactory = new ScopeFactory(Scope, callStack, superGlobalScope, valueFactory, referenceFactory),
            functionFactory = new FunctionFactory(scopeFactory, callFactory, valueFactory, callStack),
            closureFactory = new ClosureFactory(functionFactory, valueFactory, Closure),
            namespaceFactory = new NamespaceFactory(
                Namespace,
                callStack,
                functionFactory,
                valueFactory,
                classAutoloader
            ),
            globalNamespace = namespaceFactory.create(),
            globalScope,
            globalsSuperGlobal = superGlobalScope.defineVariable('GLOBALS');

        scopeFactory.setClosureFactory(closureFactory);
        globalScope = scopeFactory.create(globalNamespace);
        scopeFactory.setGlobalScope(globalScope);
        classAutoloader.setGlobalNamespace(globalNamespace);
        valueFactory.setGlobalNamespace(globalNamespace);

        // Set up the $GLOBALS superglobal
        globalsSuperGlobal.setReference(
            referenceFactory.createAccessor(
                function () {
                    var globalValues = globalScope.exportVariables(),
                        globalsArray = valueFactory.coerce(globalValues);

                    // $GLOBALS should have a recursive reference to itself
                    globalsArray.getElementByKey(valueFactory.createString('GLOBALS'))
                        .setValue(globalsArray);

                    return globalsArray;
                },
                function (newNative) {
                    // Clear these accessors first
                    globalsSuperGlobal.unset();

                    globalsSuperGlobal.setValue(valueFactory.coerce(newNative));
                }
            )
        );

        this.callStack = callStack;
        this.globalNamespace = globalNamespace;
        this.globalScope = globalScope;
        this.iniState = new INIState();
        this.optionSet = optionSet;
        this.referenceFactory = referenceFactory;
        this.callStack = callStack;
        this.classAutoloader = classAutoloader;
        this.pausable = pausable;
        this.stderr = stderr;
        this.stdin = stdin;
        this.stdout = stdout;
        this.superGlobalScope = superGlobalScope;
        this.valueFactory = valueFactory;
        this.PHPException = null;

        setUpState(this, installedBuiltinTypes);
    }

    _.extend(PHPState.prototype, {
        defineSuperGlobal: function (name, value) {
            this.superGlobalScope.defineVariable(name).setValue(value);
        },

        defineSuperGlobalAccessor: function (name, valueGetter, valueSetter) {
            var state = this,
                accessorReference = new AccessorReference(state.valueFactory, valueGetter, valueSetter);

            state.superGlobalScope.defineVariable(name).setReference(accessorReference);
        },

        getCallStack: function () {
            return this.callStack;
        },

        getConstant: function (name) {
            var value;

            try {
                value = this.globalNamespace.getConstant(name, true);
            } catch (error) {
                return null;
            }

            return value.getNative();
        },

        getGlobalNamespace: function () {
            return this.globalNamespace;
        },

        getGlobalScope: function () {
            return this.globalScope;
        },

        getOptions: function () {
            return this.optionSet.getOptions();
        },

        getPHPExceptionClass: function () {
            return this.PHPException;
        },

        getReferenceFactory: function () {
            return this.referenceFactory;
        },

        getStderr: function () {
            return this.stderr;
        },

        getStdin: function () {
            return this.stdin;
        },

        getStdout: function () {
            return this.stdout;
        },

        getSuperGlobalScope: function () {
            return this.superGlobalScope;
        },

        getValueFactory: function () {
            return this.valueFactory;
        }
    });

    return PHPState;
}, {strict: true});

},{"./Call":93,"./CallFactory":94,"./CallStack":95,"./ClassAutoloader":97,"./Closure":98,"./ClosureFactory":99,"./FunctionFactory":102,"./INIState":103,"./Namespace":107,"./NamespaceFactory":108,"./Reference/AccessorReference":113,"./Reference/Null":115,"./Reference/Variable":120,"./ReferenceFactory":121,"./Scope":123,"./ScopeFactory":124,"./SuperGlobalScope":126,"./ValueFactory":137,"./builtin/builtins":139,"microdash":28,"pauser":85,"util":172}],113:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    util = require('util'),
    Reference = require('./Reference');

function AccessorReference(valueFactory, valueGetter, valueSetter) {
    this.valueFactory = valueFactory;
    this.valueGetter = valueGetter;
    this.valueSetter = valueSetter;
}

util.inherits(AccessorReference, Reference);

_.extend(AccessorReference.prototype, {
    getReference: function () {
        return this;
    },

    getValue: function () {
        var reference = this;

        return reference.valueFactory.coerce(reference.valueGetter());
    },

    setValue: function (value) {
        this.valueSetter(value.getNative());

        return value;
    }
});

module.exports = AccessorReference;

},{"./Reference":118,"microdash":28,"util":172}],114:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    phpCommon = require('phpcommon'),
    util = require('util'),
    KeyReferencePair = require('../KeyReferencePair'),
    KeyValuePair = require('../KeyValuePair'),
    PHPError = phpCommon.PHPError,
    Reference = require('./Reference');

function ElementReference(valueFactory, callStack, arrayValue, key, value, reference) {
    if (value && reference) {
        throw new Error('Array elements can only have a value or be a reference, not both');
    }

    this.arrayValue = arrayValue;
    this.key = key;
    this.reference = reference || null;
    this.callStack = callStack;
    this.value = value || null;
    this.valueFactory = valueFactory;
}

util.inherits(ElementReference, Reference);

_.extend(ElementReference.prototype, {
    clone: function () {
        var element = this;

        return new ElementReference(element.valueFactory, element.callStack, element.arrayValue, element.key, element.value);
    },

    getInstancePropertyByName: function (name) {
        return this.getValue().getInstancePropertyByName(name);
    },

    getKey: function () {
        return this.key;
    },

    /**
     * Fetches the relevant type of Pair class to represent this array element.
     * If the element is a reference (to a variable, another array element or object property)
     * then a KeyReferencePair will be returned.
     * Otherwise the element simply holds a value, in which case a KeyValuePair will be returned.
     *
     * @param {Value|undefined} overrideKey Optional key to use rather than this element's
     * @returns {KeyReferencePair|KeyValuePair}
     */
    getPair: function (overrideKey) {
        var element = this;

        if (!overrideKey) {
            overrideKey = element.key;
        }

        if (element.value) {
            return new KeyValuePair(overrideKey, element.value);
        }

        if (element.reference) {
            return new KeyReferencePair(overrideKey, element.reference);
        }

        throw new Error('Element is not defined');
    },

    getReference: function () {
        return this;
    },

    getValue: function () {
        var element = this;

        // Special value of native null (vs. NullValue) represents undefined
        if (!element.value && !element.reference) {
            element.callStack.raiseError(PHPError.E_NOTICE, 'Undefined ' + element.arrayValue.referToElement(element.key.getNative()));
            return element.valueFactory.createNull();
        }

        return element.value ? element.value : element.reference.getValue();
    },

    getValueReference: function () {
        var element = this;

        return element.reference || element.value || null;
    },

    isDefined: function () {
        var element = this;

        return element.value || element.reference;
    },

    isReference: function () {
        return !!this.reference;
    },

    isSet: function () {
        var element = this;

        if (element.value) {
            return element.value.isSet();
        }

        if (element.reference) {
            return element.reference.getValue().isSet();
        }

        return false;
    },

    setReference: function (reference) {
        var element = this;

        element.reference = reference;
        element.value = null;

        element.arrayValue.defineElement(element);

        return reference;
    },

    setValue: function (value) {
        var element = this,
            isFirstElement = (element.arrayValue.getLength() === 0);

        if (element.key === null) {
            // This reference refers to a new element to push onto the end of an array
            element.key = element.arrayValue.pushElement(element);
        }

        if (element.reference) {
            element.reference.setValue(value);
        } else {
            element.arrayValue.defineElement(element);
            element.value = value.getForAssignment();
        }

        if (isFirstElement) {
            element.arrayValue.pointToElement(element);
        }

        return value;
    },

    unset: function () {
        var element = this;

        element.value = element.reference = null;
    }
});

module.exports = ElementReference;

},{"../KeyReferencePair":104,"../KeyValuePair":105,"./Reference":118,"microdash":28,"phpcommon":87,"util":172}],115:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    util = require('util'),
    Reference = require('./Reference');

function NullReference(valueFactory, options) {
    options = options || {};

    this.onSet = options.onSet;
    this.valueFactory = valueFactory;
}

util.inherits(NullReference, Reference);

_.extend(NullReference.prototype, {
    getReference: function () {
        return this;
    },

    getValue: function () {
        return this.valueFactory.createNull();
    },

    isSet: function () {
        return false;
    },

    setValue: function () {
        var reference = this;

        if (reference.onSet) {
            reference.onSet();
        }
    }
});

module.exports = NullReference;

},{"./Reference":118,"microdash":28,"util":172}],116:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    util = require('util'),
    Reference = require('./Reference');

function ObjectElement(valueFactory, objectValue, keyValue) {
    this.keyValue = keyValue;
    this.objectValue = objectValue;
    this.valueFactory = valueFactory;
}

util.inherits(ObjectElement, Reference);

_.extend(ObjectElement.prototype, {
    getReference: function () {
        return this;
    },

    getValue: function () {
        var element = this;

        return element.objectValue.callMethod('offsetGet', [element.keyValue]);
    },

    isSet: function () {
        var element = this;

        return element.objectValue.callMethod('offsetExists', [element.keyValue]).getNative();
    },

    setValue: function (value) {
        var element = this;

        element.objectValue.callMethod('offsetSet', [element.keyValue, value]);
    },

    unset: function () {
        var element = this;

        element.objectValue.callMethod('offsetUnset', [element.keyValue]);
    }
});

module.exports = ObjectElement;

},{"./Reference":118,"microdash":28,"util":172}],117:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    hasOwn = {}.hasOwnProperty,
    phpCommon = require('phpcommon'),
    util = require('util'),
    PHPError = phpCommon.PHPError,
    Reference = require('./Reference');

function PropertyReference(valueFactory, callStack, objectValue, nativeObject, key) {
    this.objectValue = objectValue;
    this.key = key;
    this.nativeObject = nativeObject;
    this.reference = null;
    this.callStack = callStack;
    this.valueFactory = valueFactory;
}

util.inherits(PropertyReference, Reference);

_.extend(PropertyReference.prototype, {
    clone: function () {
        var property = this;

        return new PropertyReference(
            property.valueFactory,
            property.callStack,
            property.objectValue,
            property.nativeObject,
            property.key
        );
    },

    getInstancePropertyByName: function (name) {
        return this.getValue().getInstancePropertyByName(name);
    },

    getKey: function () {
        return this.key;
    },

    getReference: function () {
        return this;
    },

    getValue: function () {
        var property = this,
            nativeObject = property.nativeObject,
            nativeKey = property.key.getNative();

        // Special value of native null (vs. NullValue) represents undefined
        if (!property.isDefined()) {
            property.callStack.raiseError(
                PHPError.E_NOTICE,
                'Undefined ' + property.objectValue.referToElement(
                    nativeKey
                )
            );

            return property.valueFactory.createNull();
        }

        return property.reference ?
            property.reference.getValue() :
            property.valueFactory.coerce(
                nativeObject[nativeKey]
            );
    },

    isDefined: function () {
        var defined = true,
            otherObject,
            property = this,
            nativeObject = property.nativeObject,
            nativeKey = property.key.getNative();

        if (property.reference) {
            return true;
        }

        // Allow properties inherited via the prototype chain up to but not including Object.prototype
        if (!hasOwn.call(nativeObject, nativeKey)) {
            otherObject = nativeObject;

            do {
                otherObject = Object.getPrototypeOf(otherObject);
                if (!otherObject || otherObject === Object.prototype) {
                    defined = false;
                    break;
                }
            } while (!hasOwn.call(otherObject, nativeKey));
        }

        // Check that the property resolves to something other than null,
        // otherwise it is not set
        if (
            defined &&
            property.valueFactory.coerce(nativeObject[nativeKey]).getType() === 'null'
        ) {
            return false;
        }

        return defined;
    },

    isReference: function () {
        return !!this.reference;
    },

    isSet: function () {
        return this.isDefined();
    },

    setReference: function (reference) {
        var property = this;

        property.reference = reference;

        return reference;
    },

    setValue: function (value) {
        var property = this,
            nativeObject = property.nativeObject,
            nativeKey = property.key.getNative(),
            isFirstProperty = (property.objectValue.getLength() === 0);

        // Ensure we write the native value to properties on native JS objects
        function getValueForAssignment() {
            if (property.objectValue.getClassName() === 'JSObject') {
                return value.getNative();
            }

            return value.getForAssignment();
        }

        if (property.reference) {
            property.reference.setValue(value);
        } else {
            nativeObject[nativeKey] = getValueForAssignment();
        }

        if (isFirstProperty) {
            property.objectValue.pointToProperty(property);
        }

        return value;
    },

    unset: function () {
        var property = this,
            nativeObject = property.nativeObject,
            nativeKey = property.key.getNative();

        // Clear value and/or reference to mark as unset
        property.value = property.reference = null;

        // Delete the property from the native object
        delete nativeObject[nativeKey];
    }
});

module.exports = PropertyReference;

},{"./Reference":118,"microdash":28,"phpcommon":87,"util":172}],118:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash');

function Reference() {
}

_.extend(Reference.prototype, {
    getReference: function () {
        return this;
    },

    getValue: function () {
        throw new Error('Not implemented');
    },

    isSet: function () {
        throw new Error('Not implemented');
    },

    setValue: function () {
        throw new Error('Not implemented');
    }
});

module.exports = Reference;

},{"microdash":28}],119:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    util = require('util'),
    Reference = require('./Reference');

function StaticPropertyReference(classObject, name, visibility, value) {
    this.classObject = classObject;
    this.name = name;
    this.reference = null;
    this.value = value;
    this.visibility = visibility;
}

util.inherits(StaticPropertyReference, Reference);

_.extend(StaticPropertyReference.prototype, {
    getInstancePropertyByName: function (name) {
        return this.getValue().getInstancePropertyByName(name);
    },

    getName: function () {
        return this.name;
    },

    getReference: function () {
        return this;
    },

    getValue: function () {
        var property = this;

        return property.value ? property.value : property.reference.getValue();
    },

    getVisibility: function () {
        return this.visibility;
    },

    isReference: function () {
        return !!this.reference;
    },

    setReference: function (reference) {
        var property = this;

        property.reference = reference;
        property.value = null;
    },

    setValue: function (value) {
        var property = this;

        if (property.reference) {
            property.reference.setValue(value);
        } else {
            property.value = value.getForAssignment();
        }
    }
});

module.exports = StaticPropertyReference;

},{"./Reference":118,"microdash":28,"util":172}],120:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    util = require('util'),
    Reference = require('./Reference');

function VariableReference(variable) {
    this.variable = variable;
}

util.inherits(VariableReference, Reference);

_.extend(VariableReference.prototype, {
    getForAssignment: function () {
        return this.getValue();
    },

    getInstancePropertyByName: function (name) {
        return this.getValue().getInstancePropertyByName(name);
    },

    getReference: function () {
        return this;
    },

    getValue: function () {
        return this.variable.getValue();
    },

    setValue: function (value) {
        this.variable.setValue(value);

        return value;
    }
});

module.exports = VariableReference;

},{"./Reference":118,"microdash":28,"util":172}],121:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

module.exports = require('pauser')([
    require('microdash')
], function (
    _
) {
    /**
     * @param {class} AccessorReference
     * @param {class} NullReference
     * @param {class} VariableReference
     * @param {ValueFactory} valueFactory
     * @constructor
     */
    function ReferenceFactory(
        AccessorReference,
        NullReference,
        VariableReference,
        valueFactory
    ) {
        /**
         * @type {class}
         */
        this.AccessorReference = AccessorReference;
        /**
         * @type {class}
         */
        this.NullReference = NullReference;
        /**
         * @type {ValueFactory}
         */
        this.valueFactory = valueFactory;
        /**
         * @type {class}
         */
        this.VariableReference = VariableReference;
    }

    _.extend(ReferenceFactory.prototype, {
        /**
         * Creates an AccessorReference
         *
         * @param {function} valueGetter
         * @param {function} valueSetter
         * @returns {AccessorReference}
         */
        createAccessor: function (valueGetter, valueSetter) {
            var factory = this;

            return new factory.AccessorReference(factory.valueFactory, valueGetter, valueSetter);
        },

        /**
         * Creates a NullReference
         *
         * @returns {NullReference}
         */
        createNull: function () {
            var factory = this;

            return new factory.NullReference(factory.valueFactory);
        },

        /**
         * Creates a new VariableReference
         *
         * @param {Variable} variable
         * @returns {VariableReference}
         */
        createVariable: function (variable) {
            return new this.VariableReference(variable);
        }
    });

    return ReferenceFactory;
}, {strict: true});

},{"microdash":28,"pauser":85}],122:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

module.exports = require('pauser')([
    require('microdash'),
    require('./PHPState'),
    require('./Stream')
], function (
    _,
    PHPState,
    Stream
) {
    /**
     * PHPCore API encapsulator.
     *
     * @param {class} Environment
     * @param {class} Engine
     * @param {class} OptionSet
     * @param {class} PHPState
     * @param {object} phpCommon
     * @param {Resumable} pausable
     * @constructor
     */
    function Runtime(Environment, Engine, OptionSet, PHPState, phpCommon, pausable) {
        /**
         * @type {{classes: {}, constantGroups: Array, functionGroups: Array}}
         */
        this.builtins = {
            classes: {},
            constantGroups: [],
            functionGroups: []
        };
        /**
         * @type {class}
         */
        this.Engine = Engine;
        /**
         * @type {class}
         */
        this.Environment = Environment;
        /**
         * @type {class}
         */
        this.OptionSet = OptionSet;
        /**
         * @type {Resumable}
         */
        this.pausable = pausable;
        /**
         * @type {Object}
         */
        this.phpCommon = phpCommon;
        /**
         * @type {class}
         */
        this.PHPState = PHPState;
    }

    _.extend(Runtime.prototype, {
        /**
         * Creates a factory function that can be called to create
         * a new Engine instance using this runtime's context.
         *
         * @param {Function} wrapper
         * @returns {Function}
         */
        compile: function (wrapper) {
            var runtime = this,
                pausable = runtime.pausable,
                phpCommon = runtime.phpCommon;

            /**
             * Creates a new Engine instance using this runtime's context.
             *
             * @param {object} options
             * @param {Environment|null} environment
             * @param {Scope|null} topLevelScope
             * @returns {Engine}
             */
            function factory(options, environment, topLevelScope) {
                if (environment) {
                    options = _.extend({}, environment.getOptions(), options);
                } else {
                    environment = runtime.createEnvironment(options);
                }

                return new runtime.Engine(
                    environment,
                    topLevelScope || null,
                    phpCommon,
                    options,
                    wrapper,
                    pausable
                );
            }

            /**
             * Creates a new factory function with some optional default options,
             * environment and top-level Scope
             *
             * @param {object|null|undefined} defaultOptions
             * @param {Environment|null|undefined} defaultEnvironment
             * @param {Scope|null|undefined} defaultTopLevelScope
             * @returns {Function}
             */
            factory.using = function (defaultOptions, defaultEnvironment, defaultTopLevelScope) {
                /**
                 * A proxying factory function that applies these defaults
                 * and then forwards onto the original factory function
                 *
                 * @param {object|null|undefined} options
                 * @param {Environment|null|undefined} environment
                 * @param {Scope|null|undefined} topLevelScope
                 * @returns {Engine}
                 */
                function proxy(options, environment, topLevelScope) {
                    options = _.extend({}, defaultOptions, options);
                    environment = environment || defaultEnvironment;
                    topLevelScope = topLevelScope || defaultTopLevelScope;

                    return factory(options, environment, topLevelScope);
                }

                return proxy;
            };

            return factory;
        },

        /**
         * Creates a new Environment instance, useful for sharing a runtime
         * context between modules.
         * A factory function returned from `.compile(...)` may be called
         * passing an Environment instance in order to reuse it, eg.
         * to make classes, functions and global variables from one module
         * available in another outside the use of includes.
         *
         * @param {object} options
         * @returns {Environment}
         */
        createEnvironment: function (options) {
            var runtime = this,
                stdin = new Stream(),
                stdout = new Stream(),
                stderr = new Stream(),
                optionSet = new runtime.OptionSet(options || {}),
                state = new runtime.PHPState(
                    runtime.builtins,
                    stdin,
                    stdout,
                    stderr,
                    runtime.pausable,
                    optionSet
                );

            return new runtime.Environment(state);
        },

        /**
         * Installs a new set of builtins, to be available to all modules
         * compiled and executed by this runtime.
         * All fields are optional - for example, this method can be used
         * to only define a new class without also defining any constants or functions.
         *
         * @param {{classes: {}, constantGroups: Array, functionGroups: Array}} newBuiltins
         */
        install: function (newBuiltins) {
            var builtins = this.builtins;

            [].push.apply(builtins.functionGroups, newBuiltins.functionGroups);
            _.extend(builtins.classes, newBuiltins.classes);
            [].push.apply(builtins.constantGroups, newBuiltins.constantGroups);
        }
    });

    return Runtime;
}, {strict: true});

},{"./PHPState":112,"./Stream":125,"microdash":28,"pauser":85}],123:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

module.exports = require('pauser')([
    require('microdash'),
    require('phpcommon'),
    require('./Variable')
], function (
    _,
    phpCommon,
    Variable
) {
    var hasOwn = {}.hasOwnProperty,
        IS_STATIC = 'isStatic',
        PHPFatalError = phpCommon.PHPFatalError;

    function Scope(
        callStack,
        globalScope,
        superGlobalScope,
        closureFactory,
        valueFactory,
        referenceFactory,
        namespace,
        currentClass,
        currentFunction,
        thisObject
    ) {
        var thisObjectVariable = new Variable(callStack, valueFactory, 'this');

        this.callStack = callStack;
        this.closureFactory = closureFactory;
        this.currentClass = currentClass;
        this.currentFunction = currentFunction;
        this.errorsSuppressed = false;
        this.globalScope = globalScope;
        this.namespace = namespace;
        this.referenceFactory = referenceFactory;
        this.superGlobalScope = superGlobalScope;
        this.thisObject = currentFunction && currentFunction[IS_STATIC] ? null : thisObject;
        this.valueFactory = valueFactory;
        this.variables = {
            'this': thisObjectVariable
        };

        if (thisObject && (!currentFunction || !currentFunction[IS_STATIC])) {
            thisObjectVariable.setValue(thisObject);
        }
    }

    _.extend(Scope.prototype, {
        /**
         * Creates a closure, either static (with no `$this` object bound) or non-static
         *
         * @param {Function} func
         * @param {boolean|undefined} isStatic
         * @returns {Closure}
         */
        createClosure: function (func, isStatic) {
            var scope = this,
                thisObject = null;

            // Fetch the `$this` object to bind to the closure from the current scope,
            // if the closure is a normal (non-static) one. Otherwise, if the closure is static
            // then it will have no `$this` object bound to it
            if (!isStatic) {
                thisObject = scope.thisObject;
            }

            return scope.closureFactory.create(
                scope,
                func,
                scope.namespace,
                scope.currentClass,
                thisObject
            );
        },

        defineVariable: function (name) {
            var scope = this,
                variable = new Variable(scope.callStack, scope.valueFactory, name);

            scope.variables[name] = variable;

            return variable;
        },

        defineVariables: function (names) {
            var scope = this;

            _.each(names, function (name) {
                scope.defineVariable(name);
            });
        },

        /**
         * Returns a hash with the values of all variables defined
         * for this scope, including all superglobals
         *
         * @returns {Object.<string, Value>}
         */
        exportVariables: function () {
            var scope = this,
                values = scope.superGlobalScope.exportVariables();

            _.forOwn(scope.variables, function (variable, variableName) {
                if (variable.isDefined()) {
                    values[variableName] = variable.getValue();
                }
            });

            return values;
        },

        expose: function (object, name) {
            var scope = this,
                valueFactory = scope.valueFactory;

            scope.defineVariable(name).setValue(valueFactory.coerce(object));
        },

        getClassName: function () {
            var scope = this;

            return scope.valueFactory.createString(
                scope.currentClass ? scope.currentClass.getName() : ''
            );
        },

        /**
         * Fetches the name of the current class scope
         *
         * @returns {StringValue}
         * @throws {PHPFatalError} When there is no current class scope
         */
        getClassNameOrThrow: function () {
            var scope = this;

            if (!scope.currentClass) {
                throw new PHPFatalError(PHPFatalError.SELF_WHEN_NO_ACTIVE_CLASS);
            }

            return scope.valueFactory.createString(scope.currentClass.getName());
        },

        getCurrentClass: function () {
            return this.currentClass;
        },

        getFunctionName: function () {
            var scope = this,
                functionName = '';

            if (scope.currentFunction) {
                functionName = scope.currentFunction.funcName;

                if (!scope.currentClass) {
                    functionName = scope.namespace.getPrefix() + functionName;
                }
            }

            return scope.valueFactory.createString(functionName);
        },

        getMethodName: function () {
            var scope = this,
                functionName = '';

            if (scope.currentFunction) {
                functionName = scope.currentFunction.funcName;

                if (scope.currentClass) {
                    // Methods are prefixed with namespace, class and `::`
                    functionName = scope.currentClass.getName() + '::' + functionName;
                } else {
                    // Normal functions are prefixed with namespace
                    functionName = scope.namespace.getPrefix() + functionName;
                }
            }

            return scope.valueFactory.createString(functionName);
        },

        getThisObject: function () {
            return this.thisObject;
        },

        getVariable: function (name) {
            var scope = this,
                variable;

            // Look in the current scope for the variable first
            if (hasOwn.call(scope.variables, name)) {
                return scope.variables[name];
            }

            // If not found, look in the super global scope
            variable = scope.superGlobalScope.getVariable(name);

            if (!variable) {
                // Variable is not local or a super-global: implicitly define it
                variable = new Variable(scope.callStack, scope.valueFactory, name);
                scope.variables[name] = variable;

                if (scope.errorsSuppressed) {
                    variable.setValue(scope.valueFactory.createNull());
                }
            }

            return variable;
        },

        /**
         * Imports a global variable into this scope by defining the variable
         * in this scope and setting its reference to point to the global one.
         *
         * @param {string} variableName
         */
        importGlobal: function (variableName) {
            var scope = this;

            scope.getVariable(variableName).setReference(
                scope.referenceFactory.createVariable(
                    scope.globalScope.getVariable(variableName)
                )
            );
        },

        suppressErrors: function () {
            this.errorsSuppressed = true;
        },

        suppressOwnErrors: function () {
            this.ownErrorsSuppressed = true;
        },

        suppressesErrors: function () {
            return this.errorsSuppressed;
        },

        suppressesOwnErrors: function () {
            return this.ownErrorsSuppressed;
        },

        unsuppressErrors: function () {
            this.errorsSuppressed = false;
        },

        unsuppressOwnErrors: function () {
            this.ownErrorsSuppressed = false;
        }
    });

    return Scope;
}, {strict: true});

},{"./Variable":138,"microdash":28,"pauser":85,"phpcommon":87}],124:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash');

/**
 * @param {class} Scope
 * @param {CallStack} callStack
 * @param {SuperGlobalScope} superGlobalScope
 * @param {ValueFactory} valueFactory
 * @param {ReferenceFactory} referenceFactory
 * @constructor
 */
function ScopeFactory(Scope, callStack, superGlobalScope, valueFactory, referenceFactory) {
    /**
     * @type {CallStack}
     */
    this.callStack = callStack;
    /**
     * @type {ClosureFactory}
     */
    this.closureFactory = null;
    /**
     * @type {Scope}
     */
    this.globalScope = null;
    /**
     * @type {ReferenceFactory}
     */
    this.referenceFactory = referenceFactory;
    /**
     * @type {class}
     */
    this.Scope = Scope;
    /**
     * @type {SuperGlobalScope}
     */
    this.superGlobalScope = superGlobalScope;
    /**
     * @type {ValueFactory}
     */
    this.valueFactory = valueFactory;
}

_.extend(ScopeFactory.prototype, {
    /**
     * Creates a new Scope
     *
     * @param {Namespace} namespace
     * @param {Class|null} currentClass
     * @param {Function|null} currentFunction
     * @param {ObjectValue|null} thisObject
     * @returns {Scope}
     */
    create: function (namespace, currentClass, currentFunction, thisObject) {
        var factory = this;

        return new factory.Scope(
            factory.callStack,
            factory.globalScope,
            factory.superGlobalScope,
            factory.closureFactory,
            factory.valueFactory,
            factory.referenceFactory,
            namespace || null,
            currentClass || null,
            currentFunction || null,
            thisObject || null
        );
    },

    /**
     * Sets the ClosureFactory service to pass to Scopes created by this factory
     *
     * @param {ClosureFactory} closureFactory
     */
    setClosureFactory: function (closureFactory) {
        this.closureFactory = closureFactory;
    },

    /**
     * Sets the global Scope to pass to Scopes created by this factory
     *
     * @param {Scope} globalScope
     */
    setGlobalScope: function (globalScope) {
        this.globalScope = globalScope;
    }
});

module.exports = ScopeFactory;

},{"microdash":28}],125:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    util = require('util'),
    EventEmitter = require('events').EventEmitter;

function Stream() {
    EventEmitter.call(this);

    this.data = '';
}

util.inherits(Stream, EventEmitter);

_.extend(Stream.prototype, {
    read: function (length) {
        var data,
            stream = this;

        if (!length && length !== 0) {
            data = stream.data;
            stream.data = '';
        } else {
            data = stream.data.substr(0, length);
            stream.data = stream.data.substr(length);
        }

        return data;
    },

    readAll: function () {
        var stream = this;

        return stream.read(stream.data.length);
    },

    write: function (data) {
        var stream = this;

        stream.data += data;
        stream.emit('data', data);
    }
});

module.exports = Stream;

},{"events":24,"microdash":28,"util":172}],126:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

module.exports = require('pauser')([
    require('microdash'),
    require('./Variable')
], function (
    _,
    Variable
) {
    var hasOwn = {}.hasOwnProperty;

    /**
     * @param {CallStack} callStack
     * @param {ValueFactory} valueFactory
     * @constructor
     */
    function SuperGlobalScope(callStack, valueFactory) {
        /**
         * @type {CallStack}
         */
        this.callStack = callStack;
        /**
         * @type {ValueFactory}
         */
        this.valueFactory = valueFactory;
        /**
         * @type {Object.<string, Variable>}
         */
        this.variables = {};
    }

    _.extend(SuperGlobalScope.prototype, {
        /**
         * Defines a new variable in the super global scope and returns it
         *
         * @param {string} name
         * @returns {Variable}
         */
        defineVariable: function (name) {
            var scope = this,
                variable = new Variable(scope.callStack, scope.valueFactory, name);

            scope.variables[name] = variable;

            return variable;
        },

        /**
         * Returns a hash with the values of all variables defined
         * for the super global scope. The $GLOBALS superglobal is excluded
         *
         * @returns {Object.<string, Value>}
         */
        exportVariables: function () {
            var values = {};

            _.forOwn(this.variables, function (variable, variableName) {
                // Avoid infinite recursion by not attempting to export GLOBALS itself
                if (variableName === 'GLOBALS') {
                    return;
                }

                values[variableName] = variable.getValue();
            });

            return values;
        },

        /**
         * Fetches an existing variable from the super global scope
         *
         * @param {string} name
         * @returns {Variable|null}
         */
        getVariable: function (name) {
            var scope = this;

            return hasOwn.call(scope.variables, name) ? scope.variables[name] : null;
        }
    });

    return SuperGlobalScope;
}, {strict: true});

},{"./Variable":138,"microdash":28,"pauser":85}],127:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

module.exports = require('pauser')([
    require('microdash'),
    require('phpcommon'),
    require('./Reference/Null')
], function (
    _,
    phpCommon,
    NullReference
) {
    var PHPError = phpCommon.PHPError,
        PHPFatalError = phpCommon.PHPFatalError,
        createNullReference = function (value) {
            var callStack = value.callStack;

            return new NullReference(value.factory, {
                onSet: function () {
                    callStack.raiseError(PHPError.E_WARNING, 'Cannot use a scalar value as an array');
                }
            });
        },
        throwUnimplemented = function () {
            throw new Error('Unimplemented');
        };

    function Value(factory, callStack, type, value) {
        this.factory = factory;
        this.callStack = callStack;
        this.type = type;
        this.value = value;
    }

    _.extend(Value.prototype, {
        addToArray: function () {
            throw new PHPFatalError(PHPFatalError.UNSUPPORTED_OPERAND_TYPES);
        },

        addToFloat: function (floatValue) {
            var leftValue = this;

            // Coerce to float and return a float if either operand is a float
            return leftValue.factory.createFloat(leftValue.coerceToFloat().getNative() + floatValue.getNative());
        },

        addToNull: function () {
            return this;
        },

        addToString: function (stringValue) {
            return stringValue.coerceToNumber().add(this.coerceToNumber());
        },

        callMethod: function (name) {
            throw new PHPFatalError(PHPFatalError.NON_OBJECT_METHOD_CALL, {
                name: name
            });
        },

        callStaticMethod: function () {
            throw new PHPFatalError(PHPFatalError.CLASS_NAME_NOT_VALID);
        },

        coerceToArray: function () {
            var value = this;

            return value.factory.createArray([value]);
        },

        coerceToFloat: function () {
            var value = this;

            return value.factory.createFloat(Number(value.value));
        },

        coerceToNumber: function () {
            return this.coerceToFloat();
        },

        coerceToObject: function () {
            var value = this,
                object = value.factory.createStdClassObject();

            /**
             * Scalars are coerced to objects as follows:
             *
             * > var_dump((object)21);
             *
             * object(stdClass)#1 (1) {
             *   ["scalar"]=>
             *   int(21)
             * }
             */
            object.getInstancePropertyByName(value.factory.createString('scalar')).setValue(value);

            return object;
        },

        coerceToString: throwUnimplemented,

        concat: function (rightValue) {
            var leftValue = this;

            return leftValue.factory.createString(
                leftValue.coerceToString().getNative() + rightValue.coerceToString().getNative()
            );
        },

        divide: function () {
            throw new PHPFatalError(PHPFatalError.UNSUPPORTED_OPERAND_TYPES);
        },

        divideByArray: function () {
            throw new PHPFatalError(PHPFatalError.UNSUPPORTED_OPERAND_TYPES);
        },

        divideByBoolean: function () {
            throw new PHPFatalError(PHPFatalError.UNSUPPORTED_OPERAND_TYPES);
        },

        divideByFloat: function () {
            throw new PHPFatalError(PHPFatalError.UNSUPPORTED_OPERAND_TYPES);
        },

        divideByInteger: function () {
            throw new PHPFatalError(PHPFatalError.UNSUPPORTED_OPERAND_TYPES);
        },

        divideByNull: function () {
            throw new PHPFatalError(PHPFatalError.UNSUPPORTED_OPERAND_TYPES);
        },

        divideByObject: function () {
            throw new PHPFatalError(PHPFatalError.UNSUPPORTED_OPERAND_TYPES);
        },

        divideByString: function () {
            throw new PHPFatalError(PHPFatalError.UNSUPPORTED_OPERAND_TYPES);
        },

        getCallableName: throwUnimplemented,

        getConstantByName: function () {
            throw new PHPFatalError(PHPFatalError.CLASS_NAME_NOT_VALID);
        },

        getElementByKey: function () {
            return createNullReference(this);
        },

        getForAssignment: function () {
            return this;
        },

        getInstancePropertyByName: throwUnimplemented,

        getLength: function () {
            return this.coerceToString().getLength();
        },

        getNative: function () {
            return this.value;
        },

        getPushElement: function () {
            return createNullReference(this);
        },

        getReference: function () {
            throw new PHPFatalError(PHPFatalError.ONLY_VARIABLES_BY_REFERENCE);
        },

        getStaticPropertyByName: function () {
            throw new PHPFatalError(PHPFatalError.CLASS_NAME_NOT_VALID);
        },

        getType: function () {
            return this.type;
        },

        getValue: function () {
            return this;
        },

        isAnInstanceOf: throwUnimplemented,

        isTheClassOfArray: function () {
            throw new PHPFatalError(PHPFatalError.CLASS_NAME_NOT_VALID);
        },

        isTheClassOfBoolean: function () {
            throw new PHPFatalError(PHPFatalError.CLASS_NAME_NOT_VALID);
        },

        isTheClassOfFloat: function () {
            throw new PHPFatalError(PHPFatalError.CLASS_NAME_NOT_VALID);
        },

        isTheClassOfInteger: function () {
            throw new PHPFatalError(PHPFatalError.CLASS_NAME_NOT_VALID);
        },

        isTheClassOfNull: function () {
            throw new PHPFatalError(PHPFatalError.CLASS_NAME_NOT_VALID);
        },

        isTheClassOfObject: function () {
            throw new PHPFatalError(PHPFatalError.CLASS_NAME_NOT_VALID);
        },

        isTheClassOfString: function () {
            throw new PHPFatalError(PHPFatalError.CLASS_NAME_NOT_VALID);
        },

        isEqualTo: function (rightValue) {
            /*jshint eqeqeq:false */
            var leftValue = this;

            return leftValue.factory.createBoolean(rightValue.value == leftValue.value);
        },

        isEqualToArray: function (rightValue) {
            return this.isEqualTo(rightValue);
        },

        isEqualToFloat: function (rightValue) {
            return this.isEqualTo(rightValue);
        },

        isEqualToInteger: function (rightValue) {
            return this.isEqualTo(rightValue);
        },

        isEqualToNull: function (rightValue) {
            return this.isEqualTo(rightValue);
        },

        isEqualToObject: function (rightValue) {
            return this.isEqualTo(rightValue);
        },

        /**
         * Compares this value to another value, returning bool(true)
         * if this value is greater than the other and false otherwise
         *
         * @param {Value} rightValue
         * @returns {BooleanValue}
         */
        isGreaterThan: function (rightValue) {
            var leftValue = this,
                factory = leftValue.factory;

            return factory.createBoolean(
                leftValue.coerceToNumber().getNative() > rightValue.coerceToNumber().getNative()
            );
        },

        /**
         * Compares this value to another value, returning bool(true)
         * if this value is greater than or equal to the other and false otherwise
         *
         * @param {Value} rightValue
         * @returns {BooleanValue}
         */
        isGreaterThanOrEqual: function (rightValue) {
            var leftValue = this,
                factory = leftValue.factory;

            return factory.createBoolean(
                leftValue.coerceToNumber().getNative() >= rightValue.coerceToNumber().getNative()
            );
        },

        isIdenticalTo: function (rightValue) {
            var leftValue = this;

            return leftValue.factory.createBoolean(
                rightValue.type === leftValue.type &&
                rightValue.value === leftValue.value
            );
        },

        isIdenticalToArray: function (rightValue) {
            return this.isIdenticalTo(rightValue);
        },

        isIdenticalToObject: function (rightValue) {
            return this.isIdenticalTo(rightValue);
        },

        /**
         * Compares this value to another value, returning bool(true)
         * if this value is less than the other and false otherwise
         *
         * @param {Value} rightValue
         * @returns {BooleanValue}
         */
        isLessThan: function (rightValue) {
            var leftValue = this,
                factory = leftValue.factory;

            return factory.createBoolean(
                leftValue.coerceToNumber().getNative() < rightValue.coerceToNumber().getNative()
            );
        },

        /**
         * Compares this value to another value, returning bool(true)
         * if this value is less than or equal to the other and false otherwise
         *
         * @param {Value} rightValue
         * @returns {BooleanValue}
         */
        isLessThanOrEqual: function (rightValue) {
            var leftValue = this,
                factory = leftValue.factory;

            return factory.createBoolean(
                leftValue.coerceToNumber().getNative() <= rightValue.coerceToNumber().getNative()
            );
        },

        isNotEqualTo: function (rightValue) {
            var leftValue = this;

            return leftValue.factory.createBoolean(!leftValue.isEqualTo(rightValue).getNative());
        },

        isNotIdenticalTo: function (rightValue) {
            var leftValue = this;

            return leftValue.factory.createBoolean(!leftValue.isIdenticalTo(rightValue).getNative());
        },

        isNumeric: throwUnimplemented,

        isSet: function () {
            // All values except NULL are classed as 'set'
            return true;
        },

        logicalAnd: function (rightValue) {
            var leftValue = this;

            return leftValue.factory.createBoolean(
                leftValue.coerceToBoolean().getNative() &&
                rightValue.coerceToBoolean().getNative()
            );
        },

        logicalNot: function () {
            var value = this;

            return value.factory.createBoolean(!value.coerceToBoolean().getNative());
        },

        subtractFromNull: function () {
            throw new PHPFatalError(PHPFatalError.UNSUPPORTED_OPERAND_TYPES);
        }
    });

    return Value;
}, {strict: true});

},{"./Reference/Null":115,"microdash":28,"pauser":85,"phpcommon":87}],128:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

module.exports = require('pauser')([
    require('microdash'),
    require('phpcommon'),
    require('util'),
    require('../Reference/Element'),
    require('../KeyReferencePair'),
    require('../KeyValuePair'),
    require('../Reference/Null'),
    require('../Reference/Reference'),
    require('../Value'),
    require('../Variable')
], function (
    _,
    phpCommon,
    util,
    ElementReference,
    KeyReferencePair,
    KeyValuePair,
    NullReference,
    Reference,
    Value,
    Variable
) {
    var hasOwn = {}.hasOwnProperty,
        PHPError = phpCommon.PHPError,
        PHPFatalError = phpCommon.PHPFatalError;

    function ArrayValue(factory, callStack, orderedElements, type) {
        var elements = [],
            keysToElements = [],
            value = this;

        _.each(orderedElements, function (orderedElement, key) {
            var element,
                elementReference = null,
                elementValue = null;

            if (orderedElement instanceof KeyValuePair) {
                key = orderedElement.getKey();
                elementValue = orderedElement.getValue();
            } else if (orderedElement instanceof KeyReferencePair) {
                key = orderedElement.getKey();
                elementReference = orderedElement.getReference();
            } else {
                if (_.isNumber(key)) {
                    key = factory.createInteger(keysToElements.length);
                } else {
                    key = factory.createFromNative(key);
                }

                if (orderedElement instanceof Reference) {
                    elementReference = orderedElement;
                } else if (orderedElement instanceof Variable) {
                    // TODO: Prevent Variables ever being passed to the ArrayValue ctor, only References
                    elementValue = orderedElement.getValue();
                } else {
                    elementValue = factory.coerce(orderedElement);
                }
            }

            if (elementValue) {
                element = new ElementReference(factory, callStack, value, key, elementValue);
            } else {
                element = new ElementReference(factory, callStack, value, key, null, elementReference);
            }

            elements.push(element);
            keysToElements[key.getNative()] = element;
        });

        Value.call(this, factory, callStack, type || 'array', elements);

        this.keysToElements = keysToElements;
        this.pointer = 0;
    }

    util.inherits(ArrayValue, Value);

    _.extend(ArrayValue.prototype, {
        add: function (rightValue) {
            return rightValue.addToArray(this);
        },

        addToArray: function (leftValue) {
            var rightValue = this,
                resultArray = leftValue.clone();

            _.forOwn(rightValue.keysToElements, function (element, key) {
                if (!hasOwn.call(resultArray.keysToElements, key)) {
                    resultArray.getElementByKey(element.getKey()).setValue(element.getValue());
                }
            });

            return resultArray;
        },

        addToBoolean: function () {
            throw new PHPFatalError(PHPFatalError.UNSUPPORTED_OPERAND_TYPES);
        },

        addToFloat: function () {
            throw new PHPFatalError(PHPFatalError.UNSUPPORTED_OPERAND_TYPES);
        },

        addToInteger: function () {
            throw new PHPFatalError(PHPFatalError.UNSUPPORTED_OPERAND_TYPES);
        },

        addToNull: function () {
            throw new PHPFatalError(PHPFatalError.UNSUPPORTED_OPERAND_TYPES);
        },

        addToObject: function (objectValue) {
            return objectValue.addToArray(this);
        },

        addToString: function () {
            throw new PHPFatalError(PHPFatalError.UNSUPPORTED_OPERAND_TYPES);
        },

        /**
         * Calls a static or instance method, referenced by the first two elements of this array
         *
         * @param {Value[]} args
         * @param {Namespace|NamespaceScope} namespaceOrNamespaceScope
         * @returns {Value}
         */
        call: function (args, namespaceOrNamespaceScope) {
            var methodNameValue,
                objectOrClassValue,
                value = this.value;

            if (value.length < 2) {
                throw new PHPFatalError(PHPFatalError.FUNCTION_NAME_MUST_BE_STRING);
            }

            objectOrClassValue = value[0].getValue();
            methodNameValue = value[1].getValue();

            if (objectOrClassValue.getType() === 'string') {
                return objectOrClassValue.callStaticMethod(
                    methodNameValue,
                    args,
                    namespaceOrNamespaceScope
                );
            }

            return objectOrClassValue.callMethod(
                methodNameValue.getNative(),
                args,
                namespaceOrNamespaceScope
            );
        },

        clone: function () {
            var arrayValue = this,
                orderedElements = [];

            _.each(arrayValue.value, function (element) {
                if (element.isDefined()) {
                    orderedElements.push(element.getPair());
                }
            });

            return new ArrayValue(arrayValue.factory, arrayValue.callStack, orderedElements, arrayValue.type);
        },

        coerceToArray: function () {
            return this;
        },

        coerceToBoolean: function () {
            var value = this;

            return value.factory.createBoolean(value.value.length > 0);
        },

        coerceToInteger: function () {
            var value = this;

            return value.factory.createInteger(value.value.length === 0 ? 0 : 1);
        },

        coerceToKey: function () {
            this.callStack.raiseError(PHPError.E_WARNING, 'Illegal offset type');
        },

        coerceToNumber: function () {
            return this.coerceToInteger();
        },

        coerceToObject: function () {
            var value = this,
                object = value.factory.createStdClassObject();

            _.each(value.value, function (element) {
                object.getInstancePropertyByName(element.getKey()).setValue(element.getValue());
            });

            return object;
        },

        coerceToString: function () {
            return this.factory.createString('Array');
        },

        defineElement: function (elementReference) {
            var value = this;

            if (value.value.indexOf(elementReference) === -1) {
                value.value.push(elementReference);
            }
        },

        getForAssignment: function () {
            return this.clone();
        },

        getKeys: function () {
            var keys = [];

            _.each(this.value, function (element) {
                keys.push(element.getKey());
            });

            return keys;
        },

        /**
         * Exports a wrapped PHP indexed array to a native array, or
         * an associative array to a plain JS object
         *
         * @returns {Array|object}
         */
        getNative: function () {
            var hasNonNumericKey = false,
                result = [],
                value = this;

            _.each(value.value, function (element) {
                // Treat string keys that have a numeric value as numeric
                if (!isFinite(element.getKey().getNative())) {
                    hasNonNumericKey = true;
                }
            });

            result = hasNonNumericKey ? {} : [];

            _.each(value.value, function (element) {
                result[element.getKey().getNative()] = element.getValue().getNative();
            });

            return result;
        },

        getCurrentElement: function () {
            var value = this;

            return value.value[value.pointer] || value.factory.createNull();
        },

        getElementByKey: function (key) {
            var element,
                keyValue,
                value = this;

            key = key.coerceToKey(value.callStack);

            if (!key) {
                // Could not be coerced to a key: error will already have been handled, just return NULL
                return new NullReference(value.factory);
            }

            keyValue = key.getNative();

            if (!hasOwn.call(value.keysToElements, keyValue)) {
                element = new ElementReference(value.factory, value.callStack, value, key, null);

                value.keysToElements[keyValue] = element;
            }

            return value.keysToElements[keyValue];
        },

        getElementByIndex: function (index) {
            var value = this;

            return value.value[index] || (function () {
                    value.callStack.raiseError(PHPError.E_NOTICE, 'Undefined ' + value.referToElement(index));

                    return new NullReference(value.factory);
                }());
        },

        /**
         * Fetches a KeyValuePair or KeyReferencePair for the specified array element,
         * optionally allowing the key to be overridden
         *
         * @param {Value} key
         * @param {Value|undefined} overrideKey
         * @returns {KeyValuePair|KeyReferencePair}
         */
        getElementPairByKey: function (key, overrideKey) {
            return this.getElementByKey(key).getPair(overrideKey);
        },

        getValueReferences: function () {
            var references = [];

            _.each(this.value, function (element) {
                references.push(element.getValueReference());
            });

            return references;
        },

        getKeyByIndex: function (index) {
            var value = this,
                element = value.value[index];

            return element ? element.key : null;
        },

        getLength: function () {
            return this.value.length;
        },

        getPointer: function () {
            return this.pointer;
        },

        getPushElement: function () {
            var value = this;

            return new ElementReference(value.factory, value.callStack, value, null, null);
        },

        getValues: function () {
            var values = [];

            _.each(this.value, function (element) {
                values.push(element.getValue());
            });

            return values;
        },

        isAnInstanceOf: function (classNameValue) {
            return classNameValue.isTheClassOfArray(this);
        },

        isEqualTo: function (rightValue) {
            return rightValue.isEqualToArray(this);
        },

        isEqualToNull: function () {
            var value = this;

            return value.factory.createBoolean(value.value.length === 0);
        },

        isEqualToArray: function (rightValue) {
            var equal = true,
                leftValue = this,
                factory = leftValue.factory;

            if (rightValue.value.length !== leftValue.value.length) {
                return factory.createBoolean(false);
            }

            _.forOwn(rightValue.keysToElements, function (element, nativeKey) {
                if (!hasOwn.call(leftValue.keysToElements, nativeKey) || element.getValue().isNotEqualTo(leftValue.keysToElements[nativeKey].getValue()).getNative()) {
                    equal = false;
                    return false;
                }
            });

            return factory.createBoolean(equal);
        },

        isEqualToBoolean: function (rightValue) {
            var leftValue = this;

            return leftValue.factory.createBoolean(rightValue.getNative() === (leftValue.value.length > 0));
        },

        isEqualToFloat: function () {
            return this.factory.createBoolean(false);
        },

        isEqualToInteger: function () {
            return this.factory.createBoolean(false);
        },

        isEqualToObject: function () {
            return this.factory.createBoolean(false);
        },

        isEqualToString: function () {
            return this.factory.createBoolean(false);
        },

        isIdenticalTo: function (rightValue) {
            return rightValue.isIdenticalToArray(this);
        },

        isIdenticalToArray: function (rightValue) {
            var identical = true,
                leftValue = this,
                factory = leftValue.factory;

            if (rightValue.value.length !== leftValue.value.length) {
                return factory.createBoolean(false);
            }

            _.each(rightValue.value, function (element, index) {
                if (
                    leftValue.value[index].getKey().isNotIdenticalTo(element.getKey()).getNative() ||
                    leftValue.value[index].getValue().isNotIdenticalTo(element.getValue()).getNative()
                ) {
                    identical = false;
                    return false;
                }
            });

            return factory.createBoolean(identical);
        },

        /**
         * Arrays are never numeric: always returns false
         *
         * @returns {boolean}
         */
        isNumeric: function () {
            return false;
        },

        next: function () {
            this.pointer++;
        },

        onesComplement: function () {
            throw new PHPFatalError(PHPFatalError.UNSUPPORTED_OPERAND_TYPES);
        },

        pointToElement: function (elementReference) {
            var value = this;

            _.each(value.value, function (element, index) {
                if (element.getKey().isEqualTo(elementReference.getKey()).getNative()) {
                    value.setPointer(index);
                }
            });
        },

        push: function (otherValue) {
            var value = this,
                index = value.factory.createInteger(value.getLength());

            value.getElementByKey(index).setValue(otherValue);

            return value;
        },

        pushElement: function (elementReference) {
            var value = this,
                key = value.getLength();

            value.keysToElements[key] = elementReference;
            value.value.push(elementReference);

            return value.factory.createInteger(key);
        },

        referToElement: function (key) {
            return 'offset: ' + key;
        },

        reset: function () {
            var value = this;

            value.pointer = 0;

            return value;
        },

        setPointer: function (pointer) {
            this.pointer = pointer;
        },

        shiftLeftBy: function (rightValue) {
            return this.coerceToInteger().shiftLeftBy(rightValue);
        },

        shiftRightBy: function (rightValue) {
            return this.coerceToInteger().shiftRightBy(rightValue);
        },

        sort: function (callback) {
            this.value.sort(callback);
        }
    });

    return ArrayValue;
}, {strict: true});

},{"../KeyReferencePair":104,"../KeyValuePair":105,"../Reference/Element":114,"../Reference/Null":115,"../Reference/Reference":118,"../Value":127,"../Variable":138,"microdash":28,"pauser":85,"phpcommon":87,"util":172}],129:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

module.exports = require('pauser')([
    require('microdash'),
    require('util'),
    require('./String')
], function (
    _,
    util,
    StringValue
) {
    function BarewordStringValue(factory, callStack, value) {
        StringValue.call(this, factory, callStack, value);
    }

    util.inherits(BarewordStringValue, StringValue);

    _.extend(BarewordStringValue.prototype, {
        call: function (args, namespaceOrNamespaceScope) {
            return namespaceOrNamespaceScope.getFunction(this.value).apply(null, args);
        },

        /**
         * Calls a static method of the class this string refers to
         *
         * @param {StringValue} nameValue
         * @param {Value[]} args
         * @param {Namespace|NamespaceScope} namespaceOrNamespaceScope
         * @returns {Value}
         */
        callStaticMethod: function (nameValue, args, namespaceOrNamespaceScope) {
            var value = this,
                classObject = namespaceOrNamespaceScope.getClass(value.value);

            return classObject.callMethod(nameValue.getNative(), args);
        },

        /**
         * Fetches the fully-qualified version of this name (function or class)
         *
         * @param {Namespace|NamespaceScope} namespaceOrNamespaceScope
         * @returns {StringValue}
         */
        getCallableName: function (namespaceOrNamespaceScope) {
            var rightValue = this,
                resolvedClass = namespaceOrNamespaceScope.resolveClass(rightValue.value);

            return resolvedClass.namespace.getPrefix() + resolvedClass.name;
        },

        /**
         * Fetches the value of a constant from the class this string refers to
         *
         * @param {string} name
         * @param {Namespace|NamespaceScope} namespaceOrNamespaceScope
         * @returns {Value}
         */
        getConstantByName: function (name, namespaceOrNamespaceScope) {
            var value = this,
                classObject = namespaceOrNamespaceScope.getClass(value.value);

            return classObject.getConstantByName(name);
        },

        /**
         * Fetches the value of a static property of the class this string refers to
         *
         * @param {StringValue} nameValue
         * @param {Namespace|NamespaceScope} namespaceOrNamespaceScope
         * @returns {Value}
         */
        getStaticPropertyByName: function (nameValue, namespaceOrNamespaceScope) {
            var value = this,
                classObject = namespaceOrNamespaceScope.getClass(value.value);

            return classObject.getStaticPropertyByName(nameValue.getNative());
        },

        isTheClassOfObject: function (objectValue, namespaceOrNamespaceScope) {
            var rightValue = this,
                fqcn = rightValue.getCallableName(namespaceOrNamespaceScope);

            return rightValue.factory.createBoolean(
                objectValue.classIs(fqcn)
            );
        }
    });

    return BarewordStringValue;
}, {strict: true});

},{"./String":136,"microdash":28,"pauser":85,"util":172}],130:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

module.exports = require('pauser')([
    require('microdash'),
    require('phpcommon'),
    require('util'),
    require('../Value')
], function (
    _,
    phpCommon,
    util,
    Value
) {
    var PHPError = phpCommon.PHPError,
        PHPFatalError = phpCommon.PHPFatalError;

    function BooleanValue(factory, callStack, value) {
        Value.call(this, factory, callStack, 'boolean', !!value);
    }

    util.inherits(BooleanValue, Value);

    _.extend(BooleanValue.prototype, {
        add: function (rightValue) {
            return rightValue.addToBoolean(this);
        },

        addToBoolean: function (rightValue) {
            var value = this;

            return value.factory.createInteger(value.value + rightValue.value);
        },

        addToInteger: function (integerValue) {
            return integerValue.addToBoolean(this);
        },

        addToNull: function () {
            return this.coerceToInteger();
        },

        addToObject: function (objectValue) {
            return objectValue.addToBoolean(this);
        },

        coerceToBoolean: function () {
            return this;
        },

        coerceToInteger: function () {
            var value = this;

            return value.factory.createInteger(value.value ? 1 : 0);
        },

        coerceToKey: function () {
            return this.coerceToInteger();
        },

        coerceToNumber: function () {
            return this.coerceToInteger();
        },

        coerceToString: function () {
            var value = this;

            return value.factory.createString(value.value ? '1' : '');
        },

        divide: function (rightValue) {
            return rightValue.divideByBoolean(this);
        },

        divideByBoolean: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        divideByFloat: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        divideByInteger: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        divideByNonArray: function (leftValue) {
            var coercedLeftValue,
                rightValue = this,
                divisor = rightValue.getNative(),
                quotient;

            if (divisor === false) {
                rightValue.callStack.raiseError(PHPError.E_WARNING, 'Division by zero');

                return rightValue.factory.createBoolean(false);
            }

            coercedLeftValue = leftValue.coerceToNumber();
            quotient = coercedLeftValue.getNative() / divisor;

            return coercedLeftValue.getType() === 'float' ?
                rightValue.factory.createFloat(quotient) :
                rightValue.factory.createInteger(quotient);
        },

        divideByNull: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        divideByObject: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        divideByString: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        getElement: function () {
            // Array access on booleans always returns null, no notice or warning is raised
            return this.factory.createNull();
        },

        isAnInstanceOf: function (classNameValue) {
            return classNameValue.isTheClassOfBoolean(this);
        },

        isEqualTo: function (rightValue) {
            var leftValue = this,
                factory = leftValue.factory;

            return factory.createBoolean(rightValue.coerceToBoolean().value === leftValue.value);
        },

        isEqualToObject: function () {
            return this;
        },

        isEqualToString: function (stringValue) {
            var booleanValue = this;

            return stringValue.factory.createBoolean(
                stringValue.coerceToBoolean().getNative() === booleanValue.getNative()
            );
        },

        /**
         * Booleans are never numeric: always returns false
         *
         * @returns {boolean}
         */
        isNumeric: function () {
            return false;
        },

        onesComplement: function () {
            throw new PHPFatalError(PHPFatalError.UNSUPPORTED_OPERAND_TYPES);
        },

        shiftLeftBy: function (rightValue) {
            return this.coerceToInteger().shiftLeftBy(rightValue);
        },

        shiftRightBy: function (rightValue) {
            return this.coerceToInteger().shiftRightBy(rightValue);
        }
    });

    return BooleanValue;
}, {strict: true});

},{"../Value":127,"microdash":28,"pauser":85,"phpcommon":87,"util":172}],131:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

module.exports = require('pauser')([
    require('microdash'),
    require('util'),
    require('../Value')
], function (
    _,
    util,
    Value
) {
    function ExitValue(factory, callStack, statusValue) {
        Value.call(this, factory, callStack, 'exit', null);

        this.statusValue = statusValue;
    }

    util.inherits(ExitValue, Value);

    _.extend(ExitValue.prototype, {
        getStatus: function () {
            var value = this;

            return value.statusValue ? value.statusValue.getNative() : 0;
        }
    });

    return ExitValue;
}, {strict: true});

},{"../Value":127,"microdash":28,"pauser":85,"util":172}],132:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

module.exports = require('pauser')([
    require('microdash'),
    require('phpcommon'),
    require('util'),
    require('../Value')
], function (
    _,
    phpCommon,
    util,
    Value
) {
    var PHPError = phpCommon.PHPError;

    function FloatValue(factory, callStack, value) {
        Value.call(this, factory, callStack, 'float', value);
    }

    util.inherits(FloatValue, Value);

    _.extend(FloatValue.prototype, {
        add: function (rightValue) {
            return rightValue.addToFloat(this);
        },

        addToBoolean: function (booleanValue) {
            var value = this;

            return value.factory.createFloat(value.value + Number(booleanValue.value));
        },

        addToInteger: function (integerValue) {
            var value = this;

            return value.factory.createFloat(value.value + integerValue.value);
        },

        addToObject: function (objectValue) {
            return objectValue.addToFloat(this);
        },

        addToNull: function () {
            return this.coerceToNumber();
        },

        coerceToBoolean: function () {
            var value = this;

            return value.factory.createBoolean(!!value.value);
        },

        coerceToFloat: function () {
            return this;
        },

        coerceToInteger: function () {
            /*jshint bitwise: false */
            var value = this;

            return value.factory.createInteger(value.value >> 0);
        },

        coerceToKey: function () {
            return this.coerceToInteger();
        },

        coerceToNumber: function () {
            return this;
        },

        coerceToString: function () {
            var value = this;

            return value.factory.createString(value.value + '');
        },

        divide: function (rightValue) {
            return rightValue.divideByFloat(this);
        },

        divideByBoolean: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        divideByFloat: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        divideByInteger: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        divideByNonArray: function (leftValue) {
            var coercedLeftValue,
                rightValue = this,
                divisor = rightValue.getNative();

            if (divisor === 0) {
                rightValue.callStack.raiseError(PHPError.E_WARNING, 'Division by zero');

                return rightValue.factory.createBoolean(false);
            }

            coercedLeftValue = leftValue.coerceToNumber();

            return rightValue.factory.createFloat(coercedLeftValue.getNative() / divisor);
        },

        divideByNull: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        divideByObject: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        divideByString: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        getElement: function () {
            // Array access on floats always returns null, no notice or warning is raised
            return this.factory.createNull();
        },

        isAnInstanceOf: function (classNameValue) {
            return classNameValue.isTheClassOfFloat(this);
        },

        isEqualTo: function (rightValue) {
            return rightValue.isEqualToFloat(this);
        },

        isEqualToFloat: function (rightValue) {
            var leftValue = this;

            return leftValue.factory.createBoolean(rightValue.value === leftValue.value);
        },

        isEqualToInteger: function (rightValue) {
            var leftValue = this;

            return leftValue.factory.createBoolean(rightValue.coerceToFloat().value === leftValue.value);
        },

        isEqualToNull: function () {
            var leftValue = this;

            return leftValue.factory.createBoolean(leftValue.value === 0);
        },

        isEqualToObject: function (objectValue) {
            return objectValue.isEqualToFloat(this);
        },

        isEqualToString: function (stringValue) {
            var floatValue = this;

            return floatValue.factory.createBoolean(floatValue.value === stringValue.coerceToFloat().value);
        },

        /**
         * Floats are always numeric: always returns true
         *
         * @returns {boolean}
         */
        isNumeric: function () {
            return true;
        },

        onesComplement: function () {
            /*jshint bitwise: false */
            return this.factory.createInteger(~this.value);
        },

        shiftLeftBy: function (rightValue) {
            return this.coerceToInteger().shiftLeftBy(rightValue);
        },

        shiftRightBy: function (rightValue) {
            return this.coerceToInteger().shiftRightBy(rightValue);
        },

        subtract: function (rightValue) {
            var leftValue = this,
                factory = leftValue.factory;

            rightValue = rightValue.coerceToNumber();

            return factory.createFloat(leftValue.getNative() - rightValue.getNative());
        },

        toNegative: function () {
            var value = this;

            return value.factory.createFloat(-value.value);
        },

        toPositive: function () {
            var value = this;

            return value.factory.createInteger(+value.value);
        }
    });

    return FloatValue;
}, {strict: true});

},{"../Value":127,"microdash":28,"pauser":85,"phpcommon":87,"util":172}],133:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

module.exports = require('pauser')([
    require('microdash'),
    require('phpcommon'),
    require('util'),
    require('../Value')
], function (
    _,
    phpCommon,
    util,
    Value
) {
    var PHPError = phpCommon.PHPError;

    function IntegerValue(factory, callStack, value) {
        Value.call(this, factory, callStack, 'integer', value);
    }

    util.inherits(IntegerValue, Value);

    _.extend(IntegerValue.prototype, {
        add: function (rightValue) {
            return rightValue.addToInteger(this);
        },

        addToBoolean: function (booleanValue) {
            var value = this;

            return value.factory.createInteger(value.value + booleanValue.value);
        },

        addToInteger: function (rightValue) {
            var value = this;

            return value.factory.createInteger(value.value + rightValue.value);
        },

        coerceToBoolean: function () {
            var value = this;

            return value.factory.createBoolean(!!value.value);
        },

        coerceToFloat: function () {
            var value = this;

            return value.factory.createFloat(value.value);
        },

        coerceToInteger: function () {
            return this;
        },

        coerceToKey: function () {
            return this;
        },

        coerceToNumber: function () {
            return this;
        },

        coerceToString: function () {
            var value = this;

            return value.factory.createString(value.value.toString());
        },

        decrement: function () {
            var value = this;

            return value.factory.createInteger(value.value - 1);
        },

        divide: function (rightValue) {
            return rightValue.divideByInteger(this);
        },

        divideByBoolean: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        divideByFloat: function (leftValue) {
            var coercedLeftValue,
                rightValue = this,
                divisor = rightValue.getNative();

            if (divisor === 0) {
                rightValue.callStack.raiseError(PHPError.E_WARNING, 'Division by zero');

                return rightValue.factory.createBoolean(false);
            }

            coercedLeftValue = leftValue.coerceToNumber();

            return rightValue.factory.createFloat(coercedLeftValue.getNative() / divisor);
        },

        divideByInteger: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        divideByNonArray: function (leftValue) {
            var coercedLeftValue,
                rightValue = this,
                divisor = rightValue.getNative(),
                quotient;

            if (divisor === 0) {
                rightValue.callStack.raiseError(PHPError.E_WARNING, 'Division by zero');

                return rightValue.factory.createBoolean(false);
            }

            coercedLeftValue = leftValue.coerceToNumber();

            quotient = coercedLeftValue.getNative() / divisor;

            // Return result as a float if needed, otherwise keep as integer
            return Math.round(quotient) === quotient ?
                rightValue.factory.createInteger(quotient) :
                rightValue.factory.createFloat(quotient);
        },

        divideByNull: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        divideByObject: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        divideByString: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        getElement: function () {
            // Array access on integers always returns null, no notice or warning is raised
            return this.factory.createNull();
        },

        increment: function () {
            var value = this;

            return value.factory.createInteger(value.value + 1);
        },

        isAnInstanceOf: function (classNameValue) {
            return classNameValue.isTheClassOfInteger(this);
        },

        isEqualTo: function (rightValue) {
            return rightValue.isEqualToInteger(this);
        },

        isEqualToInteger: function (rightValue) {
            var leftValue = this;

            return leftValue.factory.createBoolean(rightValue.value === leftValue.value);
        },

        isEqualToNull: function () {
            var leftValue = this;

            return leftValue.factory.createBoolean(leftValue.value === 0);
        },

        isEqualToObject: function (objectValue) {
            return objectValue.isEqualToInteger(this);
        },

        isEqualToString: function (stringValue) {
            var integerValue = this;

            return integerValue.factory.createBoolean(integerValue.getNative() === parseFloat(stringValue.getNative()));
        },

        /**
         * Integers are always numeric: always returns true
         *
         * @returns {boolean}
         */
        isNumeric: function () {
            return true;
        },

        multiply: function (rightValue) {
            var leftValue = this,
                factory = leftValue.factory,
                rightType = rightValue.getType();

            // Coerce to float and return a float if either operand is a float
            if (rightType === 'float') {
                return factory.createFloat(leftValue.coerceToFloat().getNative() + rightValue.coerceToFloat().getNative());
            }

            return factory.createInteger(leftValue.getNative() * rightValue.getNative());
        },

        onesComplement: function () {
            /*jshint bitwise: false */
            return this.factory.createInteger(~this.value);
        },

        shiftLeftBy: function (rightValue) {
            /*jshint bitwise: false */
            var leftValue = this,
                factory = leftValue.factory;

            return factory.createInteger(leftValue.getNative() << rightValue.coerceToInteger().getNative());
        },

        shiftRightBy: function (rightValue) {
            /*jshint bitwise: false */
            var leftValue = this,
                factory = leftValue.factory;

            return factory.createInteger(leftValue.getNative() >> rightValue.coerceToInteger().getNative());
        },

        subtract: function (rightValue) {
            var leftValue = this,
                factory = leftValue.factory;

            rightValue = rightValue.coerceToNumber();

            // Coerce to float and return a float if either operand is a float
            if (rightValue.getType() === 'float') {
                return factory.createFloat(leftValue.coerceToFloat().getNative() - rightValue.coerceToFloat().getNative());
            }

            return factory.createInteger(leftValue.getNative() - rightValue.getNative());
        },

        subtractFromNull: function () {
            var value = this;

            return value.factory.createInteger(-value.getNative());
        },

        toNegative: function () {
            var value = this;

            return value.factory.createInteger(-value.value);
        },

        toPositive: function () {
            var value = this;

            return value.factory.createInteger(+value.value);
        }
    });

    return IntegerValue;
}, {strict: true});

},{"../Value":127,"microdash":28,"pauser":85,"phpcommon":87,"util":172}],134:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

module.exports = require('pauser')([
    require('microdash'),
    require('phpcommon'),
    require('util'),
    require('../Value')
], function (
    _,
    phpCommon,
    util,
    Value
) {
    var PHPError = phpCommon.PHPError;

    function NullValue(factory, callStack) {
        Value.call(this, factory, callStack, 'null', null);
    }

    util.inherits(NullValue, Value);

    _.extend(NullValue.prototype, {
        add: function (rightValue) {
            return rightValue.addToNull();
        },

        addToBoolean: function (booleanValue) {
            return booleanValue.coerceToInteger();
        },

        coerceToArray: function () {
            // Null just casts to an empty array
            return this.factory.createArray();
        },

        coerceToBoolean: function () {
            return this.factory.createBoolean(false);
        },

        coerceToKey: function () {
            return this.factory.createString('');
        },

        coerceToString: function () {
            return this.factory.createString('');
        },

        divide: function (rightValue) {
            return rightValue.divideByNull(this);
        },

        divideByBoolean: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        divideByFloat: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        divideByInteger: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        divideByNonArray: function () {
            var rightValue = this;

            rightValue.callStack.raiseError(PHPError.E_WARNING, 'Division by zero');

            return rightValue.factory.createBoolean(false);
        },

        divideByNull: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        divideByObject: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        divideByString: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        getInstancePropertyByName: function () {
            var value = this;

            value.callStack.raiseError(
                PHPError.E_NOTICE,
                'Trying to get property of non-object'
            );

            return value.factory.createNull();
        },

        isAnInstanceOf: function (classNameValue) {
            return classNameValue.isTheClassOfNull(this);
        },

        isEqualTo: function (rightValue) {
            return rightValue.isEqualToNull(this);
        },

        isEqualToFloat: function (floatValue) {
            return floatValue.isEqualToNull();
        },

        isEqualToNull: function () {
            return this.factory.createBoolean(true);
        },

        isEqualToObject: function (objectValue) {
            return objectValue.isEqualToNull();
        },

        isEqualToString: function (stringValue) {
            return stringValue.isEqualToNull();
        },

        /**
         * Null is never numeric: always returns false
         *
         * @returns {boolean}
         */
        isNumeric: function () {
            return false;
        },

        isSet: function () {
            return false;
        },

        subtract: function (rightValue) {
            return rightValue.subtractFromNull();
        }
    });

    return NullValue;
}, {strict: true});

},{"../Value":127,"microdash":28,"pauser":85,"phpcommon":87,"util":172}],135:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

module.exports = require('pauser')([
    require('microdash'),
    require('phpcommon'),
    require('util'),
    require('../Closure'),
    require('../KeyValuePair'),
    require('../Reference/Null'),
    require('../Reference/ObjectElement'),
    require('../Reference/Property'),
    require('../Value')
], function (
    _,
    phpCommon,
    util,
    Closure,
    KeyValuePair,
    NullReference,
    ObjectElement,
    PropertyReference,
    Value
) {
    var hasOwn = {}.hasOwnProperty,
        getPropertyCaseInsensitive = function (object, property) {
            var found = false,
                lowerCaseProperty = property.toLowerCase(),
                otherObject,
                value = null;

            _.forOwn(object, function (propertyValue, propertyName) {
                if (propertyName.toLowerCase() === lowerCaseProperty) {
                    found = true;
                    value = propertyValue;
                    return false;
                }
            });

            if (!found) {
                otherObject = Object.getPrototypeOf(object);

                if (!otherObject) {
                    return null;
                }

                return getPropertyCaseInsensitive(otherObject, property);
            }

            return {
                object: object,
                value: value
            };
        },
        PHPError = phpCommon.PHPError,
        PHPFatalError = phpCommon.PHPFatalError;

    function ObjectValue(factory, callStack, object, classObject, id) {
        Value.call(this, factory, callStack, 'object', object);

        this.classObject = classObject;
        this.id = id;
        this.pointer = 0;
        this.properties = {};
    }

    util.inherits(ObjectValue, Value);

    _.extend(ObjectValue.prototype, {
        add: function (rightValue) {
            return rightValue.addToObject(this);
        },

        addToArray: function () {
            var value = this;

            value.callStack.raiseError(
                PHPError.E_NOTICE,
                'Object of class ' + value.classObject.getName() + ' could not be converted to int'
            );

            throw new PHPFatalError(PHPFatalError.UNSUPPORTED_OPERAND_TYPES);
        },

        addToBoolean: function (booleanValue) {
            var value = this;

            value.callStack.raiseError(
                PHPError.E_NOTICE,
                'Object of class ' + value.classObject.getName() + ' could not be converted to int'
            );

            return value.factory.createInteger((booleanValue.value ? 1 : 0) + 1);
        },

        addToFloat: function (floatValue) {
            var value = this;

            value.callStack.raiseError(
                PHPError.E_NOTICE,
                'Object of class ' + value.classObject.getName() + ' could not be converted to int'
            );

            return value.factory.createFloat(floatValue.value + 1);
        },

        /**
         * When this object is a Closure instance, returns a new Closure
         * with the specified bound `$this` object and a new current class scope
         *
         * @param {ObjectValue|NullValue} thisValue
         * @param {Class|undefined} scopeClass
         * @returns {Closure}
         */
        bindClosure: function (thisValue, scopeClass) {
            var value = this;

            if (!(value.value instanceof Closure)) {
                throw new Error('bindClosure() :: Value is not a Closure');
            }

            return value.value.bind(thisValue, scopeClass);
        },

        call: function (args) {
            return this.callMethod('__invoke', args);
        },

        /**
         * Calls the specified method of this object
         *
         * @param {string} name
         * @param {Value[]} args
         * @returns {Value}
         */
        callMethod: function (name, args) {
            var value = this;

            return value.classObject.callMethod(name, args, value);
        },

        callStaticMethod: function (nameValue, args) {
            // Could be a static call in object context, in which case we want to pass
            // the object value through.
            // This will be handled by a fetch of `callStack.getThisObject()` inside `.callMethod(...)`
            return this.classObject.callMethod(nameValue.getNative(), args);
        },

        classIs: function (className) {
            return this.classObject.is(className);
        },

        clone: function () {
            throw new Error('Unimplemented');
        },

        coerceToArray: function () {
            var elements = [],
                value = this,
                factory = value.factory;

            _.forOwn(value.value, function (propertyValue, propertyName) {
                elements.push(
                    new KeyValuePair(
                        factory.coerce(propertyName),
                        factory.coerce(propertyValue)
                    )
                );
            });

            return value.factory.createArray(elements);
        },

        coerceToBoolean: function () {
            return this.factory.createBoolean(true);
        },

        coerceToInteger: function () {
            var value = this;

            value.callStack.raiseError(
                PHPError.E_NOTICE,
                'Object of class ' + value.classObject.getName() + ' could not be converted to int'
            );

            return value.factory.createInteger(1);
        },

        coerceToNumber: function () {
            return this.coerceToInteger();
        },

        coerceToKey: function () {
            this.callStack.raiseError(PHPError.E_WARNING, 'Illegal offset type');
        },

        coerceToObject: function () {
            // Already an object: no coercion needed
            return this;
        },

        coerceToString: function () {
            return this.callMethod('__toString');
        },

        divide: function (rightValue) {
            return rightValue.divideByObject(this);
        },

        divideByBoolean: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        divideByFloat: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        divideByInteger: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        divideByNonArray: function (leftValue) {
            // Trigger notice due to coercion
            this.coerceToInteger();

            // Objects are always cast to int(1), so divisor will always be 1
            return leftValue.coerceToNumber();
        },

        divideByNull: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        divideByObject: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        divideByString: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        getCallableName: function () {
            var value = this;

            if (value.classObject.is('Closure')) {
                return value.value.funcName;
            }

            return value.getClassName() + '::__invoke()';
        },

        /**
         * Fetches the Class of this object
         *
         * @returns {Class}
         */
        getClass: function () {
            return this.classObject;
        },

        getClassName: function () {
            return this.classObject.getName();
        },

        getConstantByName: function (name) {
            return this.classObject.getConstantByName(name);
        },

        getElementByIndex: function (index) {
            var value = this,
                names = value.getInstancePropertyNames();

            if (!hasOwn.call(names, index)) {
                value.callStack.raiseError(
                    PHPError.E_NOTICE,
                    'Undefined ' + value.referToElement(index)
                );

                return new NullReference(value.factory);
            }

            return value.getInstancePropertyByName(names[index]);
        },

        getElementByKey: function (key) {
            var value = this;

            key = key.coerceToKey(value.callStack);

            if (!key) {
                // Could not be coerced to a key: error will already have been handled, just return NULL
                return new NullReference(value.factory);
            }

            if (value.classObject.is('ArrayAccess')) {
                return new ObjectElement(value.factory, value, key);
            }

            throw new PHPFatalError(PHPFatalError.CANNOT_USE_WRONG_TYPE_AS, {
                actual: value.classObject.getName(),
                expected: 'array'
            });
        },

        getForAssignment: function () {
            return this;
        },

        getForThrow: function () {
            return this.value;
        },

        getID: function () {
            return this.id;
        },

        getProperty: function (name) {
            var value = this,
                nameValue = value.factory.createString(name);

            return value.getInstancePropertyByName(nameValue).getValue();
        },

        getInstancePropertyByName: function (nameValue) {
            var nameKey = nameValue.coerceToKey(),
                name = nameKey.getNative(),
                value = this;

            if (value.classObject.hasStaticPropertyByName(name)) {
                value.callStack.raiseError(
                    PHPError.E_STRICT,
                    'Accessing static property ' + value.classObject.getName() + '::$' + name + ' as non static'
                );
            }

            if (!hasOwn.call(value.properties, name)) {
                value.properties[name] = new PropertyReference(
                    value.factory,
                    value.callStack,
                    value,
                    value.value,
                    nameKey
                );
            }

            return value.properties[name];
        },

        getInstancePropertyNames: function () {
            var nameHash = {},
                names = [],
                value = this;

            _.forOwn(value.value, function (value, name) {
                nameHash[name] = true;
            });

            _.forOwn(value.properties, function (value, name) {
                if (value.isDefined()) {
                    nameHash[name] = true;
                }
            });

            _.forOwn(nameHash, function (t, name) {
                names.push(value.factory.coerce(name));
            });

            return names;
        },

        getKeyByIndex: function (index) {
            var value = this,
                keys = value.getInstancePropertyNames();

            return keys[index] || null;
        },

        getLength: function () {
            return this.getInstancePropertyNames().length;
        },

        /**
         * Unwraps this PHP object value to something that non-PHPCore JS code will understand.
         * Special PHP classes like Closure and stdClass are unwrapped specially
         *
         * @returns {Function|PHPObject|object|*}
         */
        getNative: function () {
            var result,
                value = this;

            if (value.classObject.getName() === 'Closure') {
                // When calling a PHP closure from JS, preserve thisObj
                // by passing it in (wrapped) as the first argument
                return function () {
                    // Wrap thisObj in *Value object
                    var thisObj = value.factory.coerceObject(this),
                        args = [];

                    // Wrap all native JS values in *Value objects
                    _.each(arguments, function (arg) {
                        args.push(value.factory.coerce(arg));
                    });

                    return value.value.invoke(args, thisObj);
                };
            }

            // Don't wrap JS objects in PHPObject
            if (value.classObject.getName() === 'JSObject') {
                return value.value;
            }

            // Don't wrap stdClass objects in PHPObject, unwrap them recursively
            if (value.classObject.getName() === 'stdClass') {
                result = {};

                _.forOwn(value.value, function (propertyValue, propertyName) {
                    result[propertyName] = propertyValue.getNative();
                });

                return result;
            }

            return value.classObject.unwrapInstanceForJS(value, value.value);
        },

        getObject: function () {
            return this.value;
        },

        getPointer: function () {
            return this.pointer;
        },

        getStaticPropertyByName: function (nameValue) {
            return this.classObject.getStaticPropertyByName(nameValue.getNative());
        },

        /**
         * Invokes the native function this object wraps when it is an instance of Closure
         *
         * @param {Value[]} args
         * @returns {Value}
         */
        invokeClosure: function (args) {
            return this.value.invoke(args);
        },

        isAnInstanceOf: function (classNameValue, namespaceOrNamespaceScope) {
            return classNameValue.isTheClassOfObject(this, namespaceOrNamespaceScope);
        },

        isEqualTo: function (rightValue) {
            return rightValue.isEqualToObject(this);
        },

        isEqualToArray: function () {
            return this.factory.createBoolean(false);
        },

        isEqualToFloat: function (floatValue) {
            return this.factory.createBoolean(floatValue.getNative() === 1);
        },

        isEqualToInteger: function (integerValue) {
            return this.factory.createBoolean(integerValue.getNative() === 1);
        },

        isEqualToNull: function () {
            return this.factory.createBoolean(false);
        },

        isEqualToObject: function (rightValue) {
            var equal = true,
                leftValue = this,
                factory = leftValue.factory;

            if (
                rightValue.getLength() !== leftValue.getLength() ||
                rightValue.getClassName() !== leftValue.getClassName()
            ) {
                return factory.createBoolean(false);
            }

            _.forOwn(rightValue.value, function (element, nativeKey) {
                if (
                    !hasOwn.call(leftValue.value, nativeKey) ||
                    factory.coerce(element).isNotEqualTo(
                        leftValue.value[nativeKey].getValue()
                    ).getNative()
                ) {
                    equal = false;
                    return false;
                }
            });

            return factory.createBoolean(equal);
        },

        isEqualToString: function () {
            return this.factory.createBoolean(false);
        },

        isIdenticalTo: function (rightValue) {
            return rightValue.isIdenticalToObject(this);
        },

        isIdenticalToArray: function () {
            return this.factory.createBoolean(false);
        },

        isIdenticalToObject: function (rightValue) {
            var leftValue = this,
                factory = leftValue.factory;

            return factory.createBoolean(rightValue.value === leftValue.value);
        },

        /**
         * Objects are never numeric: always returns false
         *
         * @returns {boolean}
         */
        isNumeric: function () {
            return false;
        },

        isTheClassOfArray: function () {
            return this.factory.createBoolean(false);
        },

        isTheClassOfBoolean: function () {
            return this.factory.createBoolean(false);
        },

        isTheClassOfFloat: function () {
            return this.factory.createBoolean(false);
        },

        isTheClassOfInteger: function () {
            return this.factory.createBoolean(false);
        },

        isTheClassOfNull: function () {
            return this.factory.createBoolean(false);
        },

        isTheClassOfObject: function (leftValue) {
            var rightValue = this;

            return rightValue.factory.createBoolean(
                rightValue.classObject === leftValue.classObject ||
                    leftValue.classObject.extends(rightValue.classObject)
            );
        },

        isTheClassOfString: function () {
            return this.factory.createBoolean(false);
        },

        pointToProperty: function (propertyReference) {
            var index = 0,
                propertyName = propertyReference.getKey().getNative(),
                value = this;

            _.forOwn(value.value, function (property, name) {
                if (name === propertyName) {
                    value.setPointer(index);
                }

                index++;
            });
        },

        referToElement: function (key) {
            return 'property: ' + this.getClassName() + '::$' + key;
        },

        reset: function () {
            var value = this;

            value.pointer = 0;

            return value;
        },

        setPointer: function (pointer) {
            this.pointer = pointer;
        },

        setProperty: function (name, newValue) {
            var value = this,
                nameValue = value.factory.createString(name);

            value.getInstancePropertyByName(nameValue).setValue(newValue);
        }
    });

    return ObjectValue;
}, {strict: true});

},{"../Closure":98,"../KeyValuePair":105,"../Reference/Null":115,"../Reference/ObjectElement":116,"../Reference/Property":117,"../Value":127,"microdash":28,"pauser":85,"phpcommon":87,"util":172}],136:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

module.exports = require('pauser')([
    require('microdash'),
    require('phpcommon'),
    require('util'),
    require('../Reference/Null'),
    require('../Value')
], function (
    _,
    phpCommon,
    util,
    NullReference,
    Value
) {
    var PHPError = phpCommon.PHPError;

    function StringValue(factory, callStack, value) {
        Value.call(this, factory, callStack, 'string', value);
    }

    util.inherits(StringValue, Value);

    _.extend(StringValue.prototype, {
        add: function (rightValue) {
            return rightValue.addToString(this);
        },

        addToBoolean: function (booleanValue) {
            return this.coerceToNumber().add(booleanValue);
        },

        call: function (args, namespaceOrNamespaceScope) {
            return namespaceOrNamespaceScope.getGlobalNamespace().getFunction(this.value).apply(null, args);
        },

        /**
         * Calls a static method of the class this string refers to
         *
         * @param {StringValue} nameValue
         * @param {Value[]} args
         * @param {Namespace|NamespaceScope} namespaceOrNamespaceScope
         * @returns {Value}
         */
        callStaticMethod: function (nameValue, args, namespaceOrNamespaceScope) {
            var value = this,
                classObject = namespaceOrNamespaceScope.getGlobalNamespace().getClass(value.value);

            return classObject.callMethod(nameValue.getNative(), args);
        },

        coerceToBoolean: function () {
            return this.factory.createBoolean(this.value !== '' && this.value !== '0');
        },

        coerceToFloat: function () {
            var value = this;

            return value.factory.createFloat(/^(\d|-\d)/.test(value.value) ? parseFloat(value.value) : 0);
        },

        coerceToInteger: function () {
            var value = this;

            return value.factory.createInteger(/^(\d|-\d)/.test(value.value) ? parseInt(value.value, 10) : 0);
        },

        coerceToKey: function () {
            return this;
        },

        coerceToNumber: function () {
            var value = this,
                isInteger = /^[^.eE]*$/.test(value.value);

            if (isInteger) {
                return value.coerceToInteger();
            } else {
                return value.coerceToFloat();
            }
        },

        coerceToString: function () {
            return this;
        },

        divide: function (rightValue) {
            return rightValue.divideByString(this);
        },

        divideByBoolean: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        divideByFloat: function (leftValue) {
            var coercedLeftValue,
                rightValue = this,
                divisor = rightValue.coerceToNumber().getNative();

            if (divisor === 0) {
                rightValue.callStack.raiseError(PHPError.E_WARNING, 'Division by zero');

                return rightValue.factory.createBoolean(false);
            }

            coercedLeftValue = leftValue.coerceToNumber();

            return rightValue.factory.createFloat(coercedLeftValue.getNative() / divisor);
        },

        divideByInteger: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        divideByNonArray: function (leftValue) {
            var coercedLeftValue,
                rightValue = this,
                divisorValue = rightValue.coerceToNumber(),
                quotient;

            if (divisorValue.getNative() === 0) {
                rightValue.callStack.raiseError(PHPError.E_WARNING, 'Division by zero');

                return rightValue.factory.createBoolean(false);
            }

            coercedLeftValue = leftValue.coerceToNumber();

            quotient = coercedLeftValue.getNative() / divisorValue.getNative();

            // Return result as a float if needed, otherwise keep as integer
            return Math.round(quotient) !== quotient || divisorValue.getType() === 'float' ?
                rightValue.factory.createFloat(quotient) :
                rightValue.factory.createInteger(quotient);
        },

        divideByNull: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        divideByObject: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        divideByString: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        getCallableName: function () {
            // Strip any leading backslash off to normalise
            return this.value.replace(/^\\/, '');
        },

        /**
         * Fetches the value of a constant from the class this string refers to
         *
         * @param {string} name
         * @param {Namespace|NamespaceScope} namespaceOrNamespaceScope
         * @returns {Value}
         */
        getConstantByName: function (name, namespaceOrNamespaceScope) {
            var value = this,
                classObject = namespaceOrNamespaceScope.getGlobalNamespace().getClass(value.value);

            return classObject.getConstantByName(name);
        },

        getElementByKey: function (key) {
            var keyValue,
                value = this;

            key = key.coerceToKey(value.callStack);

            if (!key) {
                // Could not be coerced to a key: error will already have been handled, just return NULL
                return new NullReference(value.factory);
            }

            keyValue = key.getNative();

            return value.factory.createString(value.value.charAt(keyValue));
        },

        getLength: function () {
            return this.value.length;
        },

        /**
         * Fetches the value of a static property of the class this string refers to
         *
         * @param {StringValue} nameValue
         * @param {Namespace|NamespaceScope} namespaceOrNamespaceScope
         * @returns {Value}
         */
        getStaticPropertyByName: function (nameValue, namespaceOrNamespaceScope) {
            var value = this,
                classObject = namespaceOrNamespaceScope.getGlobalNamespace().getClass(value.value);

            return classObject.getStaticPropertyByName(nameValue.getNative());
        },

        isAnInstanceOf: function (classNameValue) {
            return classNameValue.isTheClassOfString(this);
        },

        isEqualTo: function (rightValue) {
            return rightValue.isEqualToString(this);
        },

        isEqualToNull: function () {
            var value = this;

            return value.factory.createBoolean(value.getNative() === '');
        },

        isEqualToObject: function () {
            return this.factory.createBoolean(false);
        },

        isEqualToString: function (rightValue) {
            var leftValue = this;

            return leftValue.factory.createBoolean(leftValue.value === rightValue.value);
        },

        /**
         * Returns true if the string is numeric, false otherwise
         *
         * @returns {boolean}
         */
        isNumeric: function () {
            return /(\d+(\.)?)?\d+([Ee][+-]\d+)?/.test(this.value);
        },

        isTheClassOfArray: function () {
            return this.factory.createBoolean(false);
        },

        isTheClassOfBoolean: function () {
            return this.factory.createBoolean(false);
        },

        isTheClassOfFloat: function () {
            return this.factory.createBoolean(false);
        },

        isTheClassOfInteger: function () {
            return this.factory.createBoolean(false);
        },

        isTheClassOfNull: function () {
            return this.factory.createBoolean(false);
        },

        isTheClassOfObject: function (objectValue) {
            var rightValue = this;

            return rightValue.factory.createBoolean(
                objectValue.classIs(rightValue.value)
            );
        },

        isTheClassOfString: function () {
            return this.factory.createBoolean(false);
        },

        onesComplement: function () {
            return this.factory.createString('?');
        }
    });

    return StringValue;
}, {strict: true});

},{"../Reference/Null":115,"../Value":127,"microdash":28,"pauser":85,"phpcommon":87,"util":172}],137:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

module.exports = require('pauser')([
    require('microdash'),
    require('phpcommon'),
    require('./Value/Array'),
    require('./Value/BarewordString'),
    require('./Value/Boolean'),
    require('./Value/Exit'),
    require('./Value/Float'),
    require('./Value/Integer'),
    require('./KeyValuePair'),
    require('./Value/Null'),
    require('./Value/Object'),
    require('./PHPObject'),
    require('./Value/String'),
    require('./Value')
], function (
    _,
    phpCommon,
    ArrayValue,
    BarewordStringValue,
    BooleanValue,
    ExitValue,
    FloatValue,
    IntegerValue,
    KeyValuePair,
    NullValue,
    ObjectValue,
    PHPObject,
    StringValue,
    Value
) {
    function ValueFactory(pausable, callStack) {
        this.nextObjectID = 1;
        this.callStack = callStack;
        this.globalNamespace = null;
        this.pausable = pausable;
    }

    _.extend(ValueFactory.prototype, {
        coerce: function (value) {
            if (value instanceof Value) {
                return value;
            }

            return this.createFromNative(value);
        },
        coerceObject: function (value) {
            var factory = this;

            if (value instanceof Value) {
                return value;
            }

            if (value === null || typeof value === 'undefined') {
                return factory.createNull();
            }

            if (typeof value !== 'object') {
                throw new Error('Only objects, null or undefined may be coerced to an object');
            }

            return factory.createObject(value, factory.globalNamespace.getClass('JSObject'));
        },
        createArray: function (value) {
            var factory = this;

            return new ArrayValue(factory, factory.callStack, value);
        },
        createBarewordString: function (value) {
            var factory = this;

            return new BarewordStringValue(factory, factory.callStack, value);
        },
        createBoolean: function (value) {
            var factory = this;

            return new BooleanValue(factory, factory.callStack, value);
        },
        createExit: function (statusValue) {
            var factory = this;

            return new ExitValue(factory, factory.callStack, statusValue);
        },
        createFloat: function (value) {
            var factory = this;

            return new FloatValue(factory, factory.callStack, value);
        },
        /**
         * Coerces a native JavaScript value to a suitable *Value object,
         * based on its type. For example, a string primitive value from JS
         * will be coerced to a StringValue instance for PHP
         *
         * @param {*} nativeValue
         * @returns {Value}
         */
        createFromNative: function (nativeValue) {
            var factory = this;

            if (nativeValue === null || typeof nativeValue === 'undefined') {
                return factory.createNull();
            }

            if (_.isString(nativeValue)) {
                return factory.createString(nativeValue);
            }

            if (_.isNumber(nativeValue)) {
                return factory.createInteger(nativeValue);
            }

            if (_.isBoolean(nativeValue)) {
                return factory.createBoolean(nativeValue);
            }

            if (_.isArray(nativeValue)) {
                return factory.createFromNativeArray(nativeValue);
            }

            return factory.createFromNativeObject(nativeValue);
        },
        /**
         * Coerces a native JavaScript object to either an ArrayValue or ObjectValue object,
         * depending on its suitability to be cast as an associative array
         *
         * @param {object} nativeObject
         * @returns {ArrayValue|ObjectValue}
         */
        createFromNativeObject: function (nativeObject) {
            var factory = this,
                hasAMethod = false,
                orderedElements = [];

            // Handle plain objects -> associative arrays
            if (Object.getPrototypeOf(nativeObject) === Object.prototype) {
                _.forOwn(nativeObject, function (value) {
                    if (_.isFunction(value)) {
                        hasAMethod = true;
                        return false;
                    }
                });

                if (!hasAMethod) {
                    // Plain object has no methods: can be safely cast to an associative array
                    _.forOwn(nativeObject, function (value, key) {
                        orderedElements.push(new KeyValuePair(factory.coerce(key), factory.coerce(value)));
                    });

                    return factory.createArray(orderedElements);
                }

                // Plain object, but has methods: needs to be cast to a JSObject
            }

            return factory.createObject(nativeObject, factory.globalNamespace.getClass('JSObject'));
        },
        /**
         * Takes a native Array object and converts it to a wrapped ArrayValue for PHP
         *
         * @param {Array} nativeArray
         * @returns {ArrayValue}
         */
        createFromNativeArray: function (nativeArray) {
            var factory = this,
                orderedElements = [];

            _.each(nativeArray, function (value, index) {
                orderedElements[index] = value;
            });

            _.forOwn(nativeArray, function (value, key) {
                if (!isFinite(key) || key >= nativeArray.length) {
                    orderedElements.push(new KeyValuePair(factory.coerce(key), factory.coerce(value)));
                }
            });

            return factory.createArray(orderedElements);
        },
        createInteger: function (value) {
            var factory = this;

            return new IntegerValue(factory, factory.callStack, value);
        },
        createNull: function () {
            var factory = this;

            return new NullValue(factory, factory.callStack);
        },
        createObject: function (value, classObject) {
            var factory = this;

            // Object ID tracking is incomplete: ID should be freed when all references are lost
            return new ObjectValue(factory, factory.callStack, value, classObject, factory.nextObjectID++);
        },
        createPHPObject: function (object) {
            var factory = this;

            return new PHPObject(factory.pausable, factory, object);
        },
        createStdClassObject: function () {
            var factory = this;

            return factory.globalNamespace.getClass('stdClass').instantiate();
        },
        createString: function (value) {
            var factory = this;

            return new StringValue(factory, factory.callStack, value);
        },
        isValue: function (object) {
            return object instanceof Value;
        },
        setGlobalNamespace: function (globalNamespace) {
            this.globalNamespace = globalNamespace;
        }
    });

    return ValueFactory;
}, {strict: true});

},{"./KeyValuePair":105,"./PHPObject":111,"./Value":127,"./Value/Array":128,"./Value/BarewordString":129,"./Value/Boolean":130,"./Value/Exit":131,"./Value/Float":132,"./Value/Integer":133,"./Value/Null":134,"./Value/Object":135,"./Value/String":136,"microdash":28,"pauser":85,"phpcommon":87}],138:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

module.exports = require('pauser')([
    require('microdash'),
    require('phpcommon'),
    require('./Reference/Variable')
], function (
    _,
    phpCommon,
    VariableReference
) {
    var PHPError = phpCommon.PHPError,
        PHPFatalError = phpCommon.PHPFatalError;

    function Variable(callStack, valueFactory, name) {
        this.name = name;
        this.reference = null;
        this.callStack = callStack;
        this.value = null;
        this.valueFactory = valueFactory;
    }

    _.extend(Variable.prototype, {
        decrementBy: function (rightValue) {
            var variable = this;

            variable.setValue(variable.getValue().subtract(rightValue));
        },

        getInstancePropertyByName: function (name) {
            var variable = this;

            if (
                variable.name === 'this' &&
                (variable.value === null || variable.value.getType() === 'null')
            ) {
                throw new PHPFatalError(PHPFatalError.USED_THIS_OUTSIDE_OBJECT_CONTEXT);
            }

            return variable.getValue().getInstancePropertyByName(name);
        },

        getName: function () {
            return this.name;
        },

        getValue: function () {
            var variable = this;

            if (variable.value) {
                return variable.value;
            }

            if (variable.reference) {
                return variable.reference.getValue();
            }

            variable.callStack.raiseError(PHPError.E_NOTICE, 'Undefined variable: ' + variable.name);

            return variable.valueFactory.createNull();
        },

        getNative: function () {
            return this.getValue().getNative();
        },

        getReference: function () {
            return new VariableReference(this);
        },

        incrementBy: function (rightValue) {
            var variable = this;

            variable.setValue(variable.getValue().add(rightValue));
        },

        isDefined: function () {
            var variable = this;

            return variable.value || variable.reference;
        },

        isSet: function () {
            var variable = this;

            return variable.isDefined() && variable.getValue().isSet();
        },

        postDecrement: function () {
            var variable = this,
                decrementedValue = variable.value.decrement(),
                result = variable.value;

            if (decrementedValue) {
                variable.value = decrementedValue;
            }

            return result;
        },

        preDecrement: function () {
            var variable = this,
                decrementedValue = variable.value.decrement();

            if (decrementedValue) {
                variable.value = decrementedValue;
            }

            return variable.value;
        },

        postIncrement: function () {
            var variable = this,
                incrementedValue = variable.value.increment(),
                result = variable.value;

            if (incrementedValue) {
                variable.value = incrementedValue;
            }

            return result;
        },

        preIncrement: function () {
            var variable = this,
                incrementedValue = variable.value.increment();

            if (incrementedValue) {
                variable.value = incrementedValue;
            }

            return variable.value;
        },

        setValue: function (value) {
            var variable = this;

            if (variable.reference) {
                variable.reference.setValue(value);
            } else {
                variable.value = value.getForAssignment();
            }

            return value;
        },

        setReference: function (reference) {
            var variable = this;

            variable.reference = reference;
            variable.value = null;
        },

        toArray: function () {
            return this.value.toArray();
        },

        toBoolean: function () {
            return this.value.toBoolean();
        },

        toFloat: function () {
            return this.value.toFloat();
        },

        toInteger: function () {
            return this.value.toInteger();
        },

        unset: function () {
            var variable = this;

            variable.value = variable.reference = null;
        }
    });

    return Variable;
}, {strict: true});

},{"./Reference/Variable":120,"microdash":28,"pauser":85,"phpcommon":87}],139:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

module.exports = require('pauser')([
    require('./constants/reserved'),
    require('./functions/spl'),
    require('./classes/stdClass'),
    require('./interfaces/ArrayAccess'),
    require('./classes/Closure'),
    require('./classes/Exception'),
    require('./classes/JSObject')
], function (
    reservedConstants,
    splFunctions,
    stdClass,
    ArrayAccess,
    Closure,
    Exception,
    JSObject
) {
    return {
        classes: {
            'stdClass': stdClass,
            'ArrayAccess': ArrayAccess,
            'Closure': Closure,
            'Exception': Exception,
            'JSObject': JSObject
        },
        constantGroups: [
            reservedConstants
        ],
        functionGroups: [
            splFunctions
        ]
    };
}, {strict: true});

},{"./classes/Closure":140,"./classes/Exception":141,"./classes/JSObject":142,"./classes/stdClass":143,"./constants/reserved":144,"./functions/spl":145,"./interfaces/ArrayAccess":146,"pauser":85}],140:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    PHPError = require('phpcommon').PHPError;

module.exports = function (internals) {
    var callStack = internals.callStack,
        createStaticMethod = function (method) {
            method.isStatic = true;

            return method;
        },
        globalNamespace = internals.globalNamespace,
        valueFactory = internals.valueFactory;

    function Closure() {

    }

    _.extend(Closure.prototype, {
        /**
         * Duplicates a closure with a specific bound object and class scope
         *
         * @see {@link https://secure.php.net/manual/en/closure.bind.php}
         *
         * @param {ObjectValue|Variable} closureReference
         * @param {ObjectValue|Variable|undefined} newThisReference
         * @param {StringValue|Variable|undefined} newScopeReference
         */
        'bind': createStaticMethod(function (closureReference, newThisReference, newScopeReference) {
            var closureValue,
                newScopeValue,
                newThisValue,
                scopeClass,
                scopeClassName;

            if (!closureReference) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'Closure::bind() expects at least 2 parameters, 0 given'
                );
                return valueFactory.createNull();
            }

            if (!newThisReference) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'Closure::bind() expects at least 2 parameters, 1 given'
                );
                return valueFactory.createNull();
            }

            closureValue = closureReference.getValue();

            if (closureValue.getType() !== 'object' || !closureValue.classIs('Closure')) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'Closure::bind() expects parameter 1 to be Closure, ' + closureValue.getType() + ' given'
                );
                return valueFactory.createNull();
            }

            newThisValue = newThisReference.getValue();

            if (newThisValue.getType() !== 'object' && newThisValue.getType() !== 'null') {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'Closure::bind() expects parameter 2 to be object, ' + newThisValue.getType() + ' given'
                );
                return valueFactory.createNull();
            }

            newScopeValue = newScopeReference ? newScopeReference.getValue() : null;

            if (newScopeValue) {
                if (newScopeValue.getType() === 'object') {
                    // Use object's class as the scope class
                    scopeClassName = newScopeValue.getClassName();
                } else {
                    // For any other type, coerce to string to use as class name
                    // (yes, even integers/floats or resources)
                    scopeClassName = newScopeValue.coerceToString().getNative();
                }
            } else {
                scopeClassName = null;
            }

            // Fetch the class to use as the static scope if specified,
            // otherwise if not specified or "static", use the class of the `$this` object
            if (scopeClassName && scopeClassName !== 'static') {
                scopeClass = globalNamespace.getClass(scopeClassName);
            } else if (newThisValue.getType() !== 'null') {
                scopeClass = newThisValue.getClass();
            } else {
                scopeClass = null;
            }

            return valueFactory.createObject(
                closureValue.bindClosure(newThisValue, scopeClass),
                globalNamespace.getClass('Closure')
            );
        }),

        /**
         * Duplicates a closure with a specific bound object and class scope
         *
         * @see {@link https://secure.php.net/manual/en/closure.bindto.php}
         *
         * @param {ObjectValue|Variable|undefined} newThisReference
         * @param {StringValue|Variable|undefined} newScopeReference
         */
        'bindTo': function (newThisReference, newScopeReference) {
            var closureValue = this,
                newScopeValue,
                newThisValue,
                scopeClass,
                scopeClassName;

            if (!newThisReference) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'Closure::bindTo() expects at least 1 parameter, 0 given'
                );
                return valueFactory.createNull();
            }

            newThisValue = newThisReference.getValue();

            if (newThisValue.getType() !== 'object' && newThisValue.getType() !== 'null') {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'Closure::bindTo() expects parameter 1 to be object, ' + newThisValue.getType() + ' given'
                );
                return valueFactory.createNull();
            }

            newScopeValue = newScopeReference ? newScopeReference.getValue() : null;

            if (newScopeValue) {
                if (newScopeValue.getType() === 'object') {
                    // Use object's class as the scope class
                    scopeClassName = newScopeValue.getClassName();
                } else {
                    // For any other type, coerce to string to use as class name
                    // (yes, even integers/floats or resources)
                    scopeClassName = newScopeValue.coerceToString().getNative();
                }
            } else {
                scopeClassName = null;
            }

            // Fetch the class to use as the static scope if specified,
            // otherwise if not specified or "static", use the class of the `$this` object
            if (scopeClassName && scopeClassName !== 'static') {
                scopeClass = globalNamespace.getClass(scopeClassName);
            } else if (newThisValue.getType() !== 'null') {
                scopeClass = newThisValue.getClass();
            } else {
                scopeClass = null;
            }

            return valueFactory.createObject(
                closureValue.bindClosure(newThisValue, scopeClass),
                globalNamespace.getClass('Closure')
            );
        },

        /**
         * Invokes the closure with the specified arguments, using calling magic.
         *
         * @see {@link http://php.net/manual/en/language.oop5.magic.php#language.oop5.magic.invoke}
         *
         * @returns {Value}
         */
        '__invoke': function () {
            return this.invokeClosure([].slice.call(arguments));
        }
    });

    internals.disableAutoCoercion();

    return Closure;
};

},{"microdash":28,"phpcommon":87}],141:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    phpCommon = require('phpcommon'),
    util = require('util'),
    PHPError = phpCommon.PHPError;

module.exports = function (internals) {
    function Exception() {

    }

    util.inherits(Exception, PHPError);

    _.extend(Exception.prototype, {

    });

    internals.disableAutoCoercion();

    return Exception;
};

},{"microdash":28,"phpcommon":87,"util":172}],142:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    PHPFatalError = require('phpcommon').PHPFatalError;

module.exports = function () {
    function JSObject() {

    }

    _.extend(JSObject.prototype, {
        /**
         * JSObject needs to implement its own way of calling out to native JS methods,
         * because the method property lookup needs to be case-sensitive, unlike PHP
         *
         * @param {string} name
         * @param {*[]} args
         * @returns {*}
         */
        '__call': function (name, args) {
            var object = this;

            if (!_.isFunction(object[name])) {
                throw new PHPFatalError(
                    PHPFatalError.UNDEFINED_METHOD,
                    {
                        className: 'JSObject',
                        methodName: name
                    }
                );
            }

            return object[name].apply(object, args);
        },

        '__invoke': function () {
            var object = this;

            if (!_.isFunction(object)) {
                throw new Error('Attempted to invoke a non-function JS object');
            }

            return object.apply(null, arguments);
        }
    });

    return JSObject;
};

},{"microdash":28,"phpcommon":87}],143:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

module.exports = function (internals) {
    function stdClass() {

    }

    internals.disableAutoCoercion();

    return stdClass;
};

},{}],144:[function(require,module,exports){
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */

'use strict';

module.exports = function () {
    return {
        'PHP_EOL': '\n'
    };
};

},{}],145:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

module.exports = require('pauser')([
    require('../../Variable')
], function (
    Variable
) {
    return function (internals) {
        var classAutoloader = internals.classAutoloader,
            valueFactory = internals.valueFactory;

        return {
            'spl_autoload_register': function (callableReference) {
                var isReference = (callableReference instanceof Variable),
                    callableValue = isReference ? callableReference.getValue() : callableReference;

                classAutoloader.appendAutoloadCallable(callableValue);
            },
            'spl_autoload_unregister': function (callableReference) {
                var isReference = (callableReference instanceof Variable),
                    callableValue = isReference ? callableReference.getValue() : callableReference;

                return valueFactory.createBoolean(
                    classAutoloader.removeAutoloadCallable(callableValue)
                );
            }
        };
    };
}, {strict: true});

},{"../../Variable":138,"pauser":85}],146:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

module.exports = function () {
    function ArrayAccess() {

    }

    return ArrayAccess;
};

},{}],147:[function(require,module,exports){
/*
 * PHPify - Browserify transform
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpify
 *
 * Released under the MIT license
 * https://github.com/uniter/phpify/raw/master/MIT-LICENSE.txt
 */

'use strict';

// Shorthand for referencing the asynchronous runtime API
module.exports = require('./api/async');

},{"./api/async":148}],148:[function(require,module,exports){
/*
 * PHPify - Browserify transform
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpify
 *
 * Released under the MIT license
 * https://github.com/uniter/phpify/raw/master/MIT-LICENSE.txt
 */

'use strict';

var API = require('../src/API'),
    FileSystem = require('../src/FileSystem'),
    Loader = require('../src/Loader'),
    phpRuntime = require('phpruntime'),
    api = new API(FileSystem, Loader, phpRuntime),
    loader = api.createLoader();

module.exports = loader;

},{"../src/API":149,"../src/FileSystem":150,"../src/Loader":151,"phpruntime":153}],149:[function(require,module,exports){
/*
 * PHPify - Browserify transform
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpify
 *
 * Released under the MIT license
 * https://github.com/uniter/phpify/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash');

/**
 * API entry point for creating Loaders for compiled PHP modules to use
 *
 * @param {class} FileSystem
 * @param {class} Loader
 * @param {Object} phpRuntime
 * @constructor
 */
function API(FileSystem, Loader, phpRuntime) {
    /**
     * @type {class}
     */
    this.FileSystem = FileSystem;
    /**
     * @type {class}
     */
    this.Loader = Loader;
    /**
     * @type {Object}
     */
    this.phpRuntime = phpRuntime;
}

_.extend(API.prototype, {
    /**
     * Creates a new, isolated Loader along with a FileSystem
     * and PHPCore/PHPRuntime environment for compiled PHP modules to use
     *
     * @returns {Loader}
     */
    createLoader: function () {
        var api = this,
            fileSystem = new api.FileSystem(),
            environment = api.phpRuntime.createEnvironment({
                fileSystem: fileSystem,
                include: function (filePath, promise) {
                    var result;

                    try {
                        result = fileSystem.compilePHPFile(filePath);
                    } catch (error) {
                        promise.reject(error);
                        return;
                    }

                    promise.resolve(result);
                }
            });

        return new api.Loader(fileSystem, environment);
    }
});

module.exports = API;

},{"microdash":28}],150:[function(require,module,exports){
/*
 * PHPify - Browserify transform
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpify
 *
 * Released under the MIT license
 * https://github.com/uniter/phpify/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    path = require('path');

/**
 * Virtual FileSystem for use in the browser with compiled PHP modules
 *
 * @constructor
 */
function FileSystem() {
    /**
     * A special function, generated by the PHP module compiler,
     * that can be called to fetch the module wrapper of any compiled modules
     * or return true/false to determine whether they exist
     *
     * @type {Function|null}
     */
    this.phpModuleFactoryFetcher = null;
}

_.extend(FileSystem.prototype, {
    /**
     * Fetches the module wrapper factory function for a compiled PHP module,
     * if it exists in the compiled bundle
     *
     * @param {string} filePath
     * @returns {Function}
     * @throws {Error} Throws when the specified compiled module does not exist
     */
    compilePHPFile: function (filePath) {
        var fileSystem = this,
            moduleFactory;

        filePath = fileSystem.realPath(filePath);
        moduleFactory = fileSystem.phpModuleFactoryFetcher(filePath, false);

        if (moduleFactory === null) {
            throw new Error('File "' + filePath + '" is not in the compiled PHP file map');
        }

        return moduleFactory;
    },

    /**
     * Initializes the FileSystem with a fetcher function that will return
     * the wrapper factory function for compiled PHP modules
     *
     * @param {Function} phpModuleFactoryFetcher
     */
    init: function (phpModuleFactoryFetcher) {
        this.phpModuleFactoryFetcher = phpModuleFactoryFetcher;
    },

    /**
     * Determines whether the specified directory path exists in the FileSystem.
     * Currently always returns true, as we cannot be sure from the info we have
     *
     * @returns {boolean}
     */
    isDirectory: function () {
        // TODO: Implement once we have support for non-PHP files in the VFS
        return true;
    },

    /**
     * Determines whether the specified file exists in the FileSystem.
     * Currently only compiled PHP modules can be in the FileSystem, so only those
     * may be detected.
     *
     * @param {string} filePath
     * @returns {boolean}
     */
    isFile: function (filePath) {
        var fileSystem = this;

        filePath = fileSystem.realPath(filePath);

        return fileSystem.phpModuleFactoryFetcher(filePath, true);
    },

    /**
     * Converts the specified module path to a full one,
     * normalizing any parent- or current-directory symbols
     *
     * @param {string} filePath
     * @returns {string}
     */
    realPath: function (filePath) {
        filePath = path.normalize(filePath);

        return filePath;
    }
});

module.exports = FileSystem;

},{"microdash":28,"path":42}],151:[function(require,module,exports){
/*
 * PHPify - Browserify transform
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpify
 *
 * Released under the MIT license
 * https://github.com/uniter/phpify/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash');

/**
 * Public API for compiled PHP modules
 *
 * @param {FileSystem} fileSystem
 * @param {Environment} environment
 * @constructor
 */
function Loader(fileSystem, environment) {
    /**
     * @type {Environment}
     */
    this.environment = environment;
    /**
     * @type {FileSystem}
     */
    this.fileSystem = fileSystem;
    /**
     * @type {boolean}
     */
    this.isInited = false;
}

_.extend(Loader.prototype, {
    /**
     * Fetches the compiled module wrapper of a PHP module, if it exists
     *
     * @param {string} filePath
     * @returns {Function|null}
     */
    compilePHPFile: function (filePath) {
        return this.fileSystem.compilePHPFile(filePath);
    },

    /**
     * Initializes the Loader with a function
     * for fetching the compiled module wrappers of PHP modules
     *
     * @param {Function} phpModuleFactoryFetcher
     */
    init: function (phpModuleFactoryFetcher) {
        var loader = this;

        // Only init once
        if (loader.isInited) {
            return;
        }

        loader.isInited = true;

        loader.fileSystem.init(phpModuleFactoryFetcher);
    },

    /**
     * Creates a new module wrapper from the provided one, with its "path" option
     * set to the specified one. Used by all compiled PHP modules
     *
     * @param {string} filePath
     * @param {Function} moduleFactory
     * @returns {Function}
     */
    load: function (filePath, moduleFactory) {
        return moduleFactory.using({path: filePath}, this.environment);
    }
});

module.exports = Loader;

},{"microdash":28}],152:[function(require,module,exports){
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */

'use strict';

var builtins = require('./src/builtin/builtins'),
    runtime = require('phpcore/async');

runtime.install(builtins);

module.exports = runtime;

},{"./src/builtin/builtins":154,"phpcore/async":92}],153:[function(require,module,exports){
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */

'use strict';

module.exports = require('./async');

},{"./async":152}],154:[function(require,module,exports){
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */

'use strict';

var arrayConstants = require('./constants/array'),
    arrayFunctions = require('./functions/array'),
    classFunctions = require('./functions/class'),
    constantFunctions = require('./functions/misc/constant'),
    Countable = require('./interfaces/Countable'),
    filesystemConstants = require('./constants/filesystem'),
    filesystemFunctions = require('./functions/filesystem'),
    functionHandlingFunctions = require('./functions/functionHandling'),
    InvalidArgumentException = require('./classes/InvalidArgumentException'),
    phpConstants = require('./constants/php'),
    stringFunctions = require('./functions/string'),
    timeFunctions = require('./functions/time'),
    variableHandlingFunctions = require('./functions/variableHandling');

module.exports = {
    classes: {
        'Countable': Countable,
        'InvalidArgumentException': InvalidArgumentException
    },
    constantGroups: [
        arrayConstants,
        filesystemConstants,
        phpConstants
    ],
    functionGroups: [
        arrayFunctions,
        classFunctions,
        constantFunctions,
        filesystemFunctions,
        functionHandlingFunctions,
        stringFunctions,
        timeFunctions,
        variableHandlingFunctions
    ]
};

},{"./classes/InvalidArgumentException":155,"./constants/array":156,"./constants/filesystem":157,"./constants/php":158,"./functions/array":159,"./functions/class":160,"./functions/filesystem":161,"./functions/functionHandling":162,"./functions/misc/constant":164,"./functions/string":165,"./functions/time":166,"./functions/variableHandling":167,"./interfaces/Countable":168}],155:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

module.exports = function (internals) {
    var globalNamespace = internals.globalNamespace;

    function InvalidArgumentException() {

    }

    InvalidArgumentException.superClass = globalNamespace.getClass('Exception');

    return InvalidArgumentException;
};

},{}],156:[function(require,module,exports){
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */

'use strict';

module.exports = function () {
    return {
        'COUNT_NORMAL': 0,
        'COUNT_RECURSIVE': 1
    };
};

},{}],157:[function(require,module,exports){
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */

'use strict';

module.exports = function () {
    return {
        'DIRECTORY_SEPARATOR': '/'
    };
};

},{}],158:[function(require,module,exports){
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */

'use strict';

var MAJOR_VERSION = 5,
    MINOR_VERSION = 4,
    RELEASE_VERSION = 0;

module.exports = function () {
    return {
        'PHP_VERSION_ID': MAJOR_VERSION * 10000 + MINOR_VERSION * 100 + RELEASE_VERSION
    };
};

},{}],159:[function(require,module,exports){
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    hasOwn = {}.hasOwnProperty,
    phpCommon = require('phpcommon'),
    COUNT_NORMAL = 0,
    IMPLODE = 'implode',
    SORT_REGULAR = 0,
    PHPError = phpCommon.PHPError;

module.exports = function (internals) {
    var callStack = internals.callStack,
        methods,
        valueFactory = internals.valueFactory;

    methods = {
        /**
         * Merges one or more arrays together, returning a new array with the result
         *
         * @see {@link https://secure.php.net/manual/en/function.array-merge.php}
         *
         * @returns {IntegerValue}
         */
        'array_merge': function () {
            var nativeKeyToElementMap = {},
                mergedElements,
                nativeKeys = [],
                nextIndex = 0,
                returnNull = false;

            if (arguments.length === 0) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'array_merge() expects at least 1 parameter, 0 given'
                );
                return valueFactory.createNull();
            }

            _.each(arguments, function (arrayReference, argumentIndex) {
                var arrayValue = arrayReference.getValue();

                if (arrayValue.getType() !== 'array') {
                    callStack.raiseError(
                        PHPError.E_WARNING,
                        'array_merge(): Argument #' + (argumentIndex + 1) + ' is not an array'
                    );
                    returnNull = true;
                    return false;
                }

                _.each(arrayValue.getKeys(), function (key) {
                    var mergedKey,
                        nativeKey;

                    if (key.isNumeric()) {
                        nativeKey = nextIndex++;
                        mergedKey = valueFactory.createInteger(nativeKey);
                        nativeKeys.push(nativeKey);
                    } else {
                        nativeKey = key.getNative();
                        mergedKey = key;

                        if (!hasOwn.call(nativeKeyToElementMap, nativeKey)) {
                            nativeKeys.push(nativeKey);
                        }
                    }

                    nativeKeyToElementMap[nativeKey] = arrayValue.getElementPairByKey(key, mergedKey);
                });
            });

            if (returnNull) {
                return valueFactory.createNull();
            }

            mergedElements = _.map(nativeKeys, function (nativeKey) {
                return nativeKeyToElementMap[nativeKey];
            });

            return valueFactory.createArray(mergedElements);
        },
        'array_push': function (arrayReference) {
            var arrayValue = arrayReference.getValue(),
                i,
                reference,
                value;

            for (i = 1; i < arguments.length; i++) {
                reference = arguments[i];
                value = reference.getValue();
                arrayValue.push(value);
            }

            return valueFactory.createInteger(arrayValue.getLength());
        },
        /**
         * Counts the specified array or object. May be hooked
         * by implementing interface Countable
         *
         * @see {@link https://secure.php.net/manual/en/function.count.php}
         *
         * @param {Variable|Value} arrayReference
         * @param {Variable|Value} modeReference
         * @returns {IntegerValue}
         */
        'count': function (arrayReference, modeReference) {
            var array = arrayReference.getValue(),
                mode = modeReference ? modeReference.getNative() : 0,
                type = array.getType();

            if (type === 'object' && array.classIs('Countable')) {
                return array.callMethod('count');
            }

            if (mode !== COUNT_NORMAL) {
                throw new Error('Unsupported mode for count(...) :: ' + mode);
            }

            return valueFactory.createInteger(
                type === 'array' || type === 'object' ? array.getLength() : 1
            );
        },
        'current': function (arrayReference) {
            var arrayValue = arrayReference.getValue();

            if (arrayValue.getPointer() >= arrayValue.getLength()) {
                return valueFactory.createBoolean(false);
            }

            return arrayValue.getCurrentElement().getValue();
        },
        'implode': function (glueReference, piecesReference) {
            var glueValue = glueReference.getValue(),
                piecesValue = piecesReference.getValue(),
                tmp,
                values;

            // For backwards-compatibility, PHP supports receiving args in either order
            if (glueValue.getType() === 'array') {
                tmp = glueValue;
                glueValue = piecesValue;
                piecesValue = tmp;
            }

            values = piecesValue.getValues();

            _.each(values, function (value, key) {
                values[key] = value.coerceToString().getNative();
            });

            return valueFactory.createString(values.join(glueValue.getNative()));
        },
        'join': function (glueReference, piecesReference) {
            return methods[IMPLODE](glueReference, piecesReference);
        },
        /**
         * Sorts an array in-place, by key, in reverse order
         *
         * @see {@link https://secure.php.net/manual/en/function.krsort.php}
         *
         * @param {Variable|Value} arrayReference
         * @param {Variable|Value|undefined} sortFlagsReference
         * @returns {IntegerValue}
         */
        'krsort': function (arrayReference, sortFlagsReference) {
            var arrayValue,
                sortFlags;

            if (!arrayReference) {
                callStack.raiseError(PHPError.E_WARNING, 'krsort() expects at least 1 parameter, 0 given');
                return valueFactory.createBoolean(false);
            }

            arrayValue = arrayReference.getValue();
            sortFlags = sortFlagsReference ? sortFlagsReference.getValue().getNative() : SORT_REGULAR;

            if (arrayValue.getType() !== 'array') {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'krsort() expects parameter 1 to be array, ' +
                    arrayValue.getType() +
                    ' given'
                );
                return valueFactory.createBoolean(false);
            }

            if (sortFlags !== SORT_REGULAR) {
                throw new Error(
                    'krsort() :: Only SORT_REGULAR (' +
                    SORT_REGULAR +
                    ') is supported, ' +
                    sortFlags +
                    ' given'
                );
            }

            arrayValue.sort(function (elementA, elementB) {
                var nativeKeyA = elementA.getKey().getNative(),
                    nativeKeyB = elementB.getKey().getNative();

                return String(nativeKeyB).localeCompare(nativeKeyA);
            });

            return valueFactory.createBoolean(true);
        },
        'next': function (arrayReference) {
            var arrayValue = arrayReference.getValue();

            if (arrayValue.getType() !== 'array') {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'next() expects parameter 1 to be array, ' +
                    arrayValue.getType() +
                    ' given'
                );
                return valueFactory.createNull();
            }

            arrayValue.setPointer(arrayValue.getPointer() + 1);

            if (arrayValue.getPointer() >= arrayValue.getLength()) {
                return valueFactory.createBoolean(false);
            }

            return arrayValue.getCurrentElement().getValue();
        }
    };

    return methods;
};

},{"microdash":28,"phpcommon":87}],160:[function(require,module,exports){
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */

'use strict';

module.exports = function (internals) {
    var classAutoloader = internals.classAutoloader,
        globalNamespace = internals.globalNamespace,
        valueFactory = internals.valueFactory;

    return {
        /**
         * Determines whether the specified class exists
         *
         * @see {@link https://secure.php.net/manual/en/function.class-exists.php}
         *
         * @param {Variable|Value} classNameReference      The name of the class to check for
         * @param {Variable|Value} callAutoloaderReference True to invoke the autoloader, false otherwise
         * @returns {*}
         */
        'class_exists': function (classNameReference, callAutoloaderReference) {
            var className = classNameReference.getNative(),
                callAutoloader = callAutoloaderReference ? callAutoloaderReference.getNative() : true;

            // Autoload the class if not already defined and autoloading is requested
            if (!globalNamespace.hasClass(className) && callAutoloader) {
                classAutoloader.autoloadClass(className);
            }

            return valueFactory.createBoolean(globalNamespace.hasClass(className));
        }
    };
};

},{}],161:[function(require,module,exports){
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */

'use strict';

var INCLUDE_PATH_INI = 'include_path',
    PHPError = require('phpcommon').PHPError;

module.exports = function (internals) {
    var callStack = internals.callStack,
        iniState = internals.iniState,
        optionSet = internals.optionSet,
        valueFactory = internals.valueFactory;

    function getFileSystem() {
        var fileSystem = optionSet.getOption('fileSystem');

        if (!fileSystem) {
            throw new Error('filesystem :: No `fileSystem` option is configured');
        }

        return fileSystem;
    }

    return {
        'dirname': function (pathReference) {
            var pathValue = pathReference.getValue(),
                path = pathValue.getNative();

            if (path && path.indexOf('/') === -1) {
                path = '.';
            } else {
                path = path.replace(/\/[^\/]+$/, '');
            }

            pathValue = valueFactory.createString(path);

            return pathValue;
        },
        /**
         * Determines whether a file or directory exists with the given path
         *
         * @see {@link https://secure.php.net/manual/en/function.file-exists.php}
         *
         * @returns {BooleanValue}
         */
        'file_exists': function (pathReference) {
            var fileSystem,
                path;

            if (!pathReference) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'file_exists() expects exactly 1 parameter, 0 given'
                );
                return valueFactory.createNull();
            }

            fileSystem = getFileSystem();
            path = pathReference.getValue().getNative();

            return valueFactory.createBoolean(fileSystem.isFile(path) || fileSystem.isDirectory(path));
        },
        'get_include_path': function () {
            return valueFactory.createString(iniState.get(INCLUDE_PATH_INI));
        },
        /**
         * Determines whether a file (not a directory) exists with the given path
         *
         * @see {@link https://secure.php.net/manual/en/function.is-file.php}
         *
         * @returns {BooleanValue}
         */
        'is_file': function (pathReference) {
            var fileSystem,
                path;

            if (!pathReference) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'is_file() expects exactly 1 parameter, 0 given'
                );
                return valueFactory.createNull();
            }

            fileSystem = getFileSystem();
            path = pathReference.getValue().getNative();

            return valueFactory.createBoolean(fileSystem.isFile(path));
        },
        'set_include_path': function (newIncludePathReference) {
            var oldIncludePath = iniState.get(INCLUDE_PATH_INI);

            iniState.set(INCLUDE_PATH_INI, newIncludePathReference.getValue().getNative());

            return valueFactory.createString(oldIncludePath);
        }
    };
};

},{"phpcommon":87}],162:[function(require,module,exports){
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    CallbackValue = require('./functionHandling/CallbackValue'),
    PHPError = require('phpcommon').PHPError;

module.exports = function (internals) {
    var callStack = internals.callStack,
        globalNamespace = internals.globalNamespace,
        valueFactory = internals.valueFactory;

    return {
        /**
         * Calls the specified function, returning its result
         *
         * @see {@link https://secure.php.net/manual/en/function.call-user-func.php}
         *
         * @param {Variable|Value} callbackReference       The function or callable to call
         * @param {...Variable|...Value} argumentReference Variable no. of arguments to pass to the callable
         * @returns {Value}
         */
        'call_user_func': function (callbackReference, argumentReference) { //jshint ignore:line
            var callbackValue = callbackReference.getValue(),
                expectedReferenceArgumentIndex = null,
                expectedReferenceError = {},
                argumentValues = _.map(
                    [].slice.call(arguments, 1),
                    function (argumentReference, argumentIndex) {
                        return new CallbackValue(
                            function () {
                                expectedReferenceArgumentIndex = argumentIndex;
                                throw expectedReferenceError;
                            },
                            function () {
                                return argumentReference.getValue();
                            }
                        );
                    }
                );

            try {
                return callbackValue.call(argumentValues, globalNamespace);
            } catch (error) {
                // Allow any other errors through
                if (error !== expectedReferenceError) {
                    throw error;
                }

                callStack.raiseError(
                    PHPError.E_WARNING,
                    'Parameter ' + (expectedReferenceArgumentIndex + 1) +
                        ' to ' + callbackValue.getCallableName(globalNamespace) +
                        '() expected to be a reference, value given'
                );

                return valueFactory.createNull();
            }
        },
        /**
         * Calls the specified function, returning its result
         *
         * @see {@link https://secure.php.net/manual/en/function.call-user-func-array.php}
         *
         * @param {Variable|Value} callbackReference      The function or callable to call
         * @param {Variable|Value} argumentArrayReference An array of arguments to pass to the callable
         * @returns {Value}
         */
        'call_user_func_array': function (callbackReference, argumentArrayReference) {
            var callbackValue = callbackReference.getValue(),
                argumentArrayValue = argumentArrayReference.getValue(),
                argumentValues = argumentArrayValue.getValueReferences();

            return callbackValue.call(argumentValues, globalNamespace);
        },
        /**
         * Determines whether the specified function exists,
         * returning true if so and false otherwise
         *
         * @see {@link https://secure.php.net/manual/en/function.function-exists.php}
         *
         * @param {Variable|Value} nameReference The name of the function to check for
         * @returns {BooleanValue}
         */
        'function_exists': function (nameReference) {
            var name = nameReference.getValue().getNative().replace(/^\\/, '');

            try {
                globalNamespace.getFunction(name);
            } catch (e) {
                return valueFactory.createBoolean(false);
            }

            return valueFactory.createBoolean(true);
        }
    };
};

},{"./functionHandling/CallbackValue":163,"microdash":28,"phpcommon":87}],163:[function(require,module,exports){
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash');

/**
 * Represents a Value object whose reference or value
 * are fetched with a callback function
 *
 * @param {Function} referenceCallback
 * @param {Function} valueCallback
 * @constructor
 */
function CallbackValue(referenceCallback, valueCallback) {
    /**
     * @type {Function}
     */
    this.referenceCallback = referenceCallback;
    /**
     * @type {Function}
     */
    this.valueCallback = valueCallback;
}

_.extend(CallbackValue.prototype, {
    /**
     * Fetches the reference for this value via the provided callback
     *
     * @returns {*}
     */
    getReference: function () {
        return this.referenceCallback();
    },

    /**
     * Fetches the eventual value of this value via the provided callback
     *
     * @returns {*}
     */
    getValue: function () {
        return this.valueCallback();
    }
});

module.exports = CallbackValue;

},{"microdash":28}],164:[function(require,module,exports){
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */

'use strict';

var PHPError = require('phpcommon').PHPError;

module.exports = function (internals) {
    var callStack = internals.callStack,
        globalNamespace = internals.globalNamespace,
        valueFactory = internals.valueFactory;

    return {
        /**
         * Defines a new constant, optionally making it case-insensitive (in name)
         *
         * @see {@link https://secure.php.net/manual/en/function.define.php}
         *
         * @param {Value|Variable} nameValue
         * @param {Value|Variable} valueValue
         * @param {Value|Variable|undefined} isCaseInsensitive
         * @returns {IntegerValue}
         */
        'define': function (nameValue, valueValue, isCaseInsensitive) {
            var match,
                name,
                namespace,
                path;

            if (arguments.length === 0) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'define() expects at least 2 parameters, 0 given'
                );
                return valueFactory.createNull();
            }

            name = nameValue.getValue().getNative();
            isCaseInsensitive = isCaseInsensitive ? isCaseInsensitive.getValue().getNative() : false;
            valueValue = valueValue.getValue();

            name = name.replace(/^\//, '');
            match = name.match(/^(.*?)\\([^\\]+)$/);

            if (match) {
                path = match[1];
                name = match[2];
                namespace = globalNamespace.getDescendant(path);
            } else {
                namespace = globalNamespace;
            }

            namespace.defineConstant(name, valueValue, {
                caseInsensitive: isCaseInsensitive
            });
        },
        /**
         * Returns true if a constant is defined with the given name, false otherwise
         *
         * @see {@link https://secure.php.net/manual/en/function.defined.php}
         *
         * @param {Value|Variable} nameValue
         * @returns {BooleanValue}
         */
        'defined': function (nameValue) {
            var match,
                name,
                namespace,
                path;

            if (arguments.length === 0) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'defined() expects exactly 1 parameter, 0 given'
                );
                return valueFactory.createNull();
            }

            name = nameValue.getValue().getNative();

            name = name.replace(/^\//, '');
            match = name.match(/^(.*?)\\([^\\]+)$/);

            if (match) {
                path = match[1];
                name = match[2];
                namespace = globalNamespace.getDescendant(path);
            } else {
                namespace = globalNamespace;
            }

            return valueFactory.createBoolean(namespace.hasConstant(name));
        }
    };
};

},{"phpcommon":87}],165:[function(require,module,exports){
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    phpCommon = require('phpcommon'),
    PHPError = phpCommon.PHPError;

module.exports = function (internals) {
    var callStack = internals.callStack,
        valueFactory = internals.valueFactory;

    return {
        'strlen': function (stringReference) {
            var stringValue = stringReference.getValue();

            if (stringValue.getType() === 'array' || stringValue.getType() === 'object') {
                callStack.raiseError(PHPError.E_WARNING, 'strlen() expects parameter 1 to be string, ' + stringValue.getType() + ' given');
                return valueFactory.createNull();
            }

            return valueFactory.createInteger(stringValue.getLength());
        },

        'str_replace': function (
            searchReference,
            replaceReference,
            subjectReference,
            countReference
        ) {
            function getNative(reference) {
                var value = reference.getValue();

                return value.getNative();
            }

            var count = 0,
                search,
                replacement,
                subject,
                replace = countReference ?
                    function replace(search, replacement, subject) {
                        return subject.replace(search, function () {
                            count++;

                            return replacement;
                        });
                    } :
                    function replace(search, replacement, subject) {
                        return subject.replace(search, replacement);
                    };

            if (arguments.length < 3) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'str_replace() expects at least 3 parameters, ' + arguments.length + ' given'
                );

                return valueFactory.createNull();
            }

            search = getNative(searchReference);
            replacement = getNative(replaceReference);
            subject = getNative(subjectReference);

            // Use a regex to search for substrings, for speed
            function buildRegex(search) {
                return new RegExp(
                    _.escapeRegExp(search),
                    'g'
                );
            }

            if (_.isArray(search)) {
                if (_.isArray(replacement)) {
                    // Search and replacement are both arrays
                    _.each(search, function (search, index) {
                        subject = replace(
                            buildRegex(search),
                            index < replacement.length ? replacement[index] : '',
                            subject
                        );
                    });
                } else {
                    // Only search is an array, replacement is just a string
                    _.each(search, function (search) {
                        subject = replace(
                            buildRegex(search),
                            replacement,
                            subject
                        );
                    });
                }
            } else {
                // Simple case: search and replacement are both strings
                subject = replace(
                    buildRegex(search),
                    replacement,
                    subject
                );
            }

            if (countReference) {
                countReference.setValue(valueFactory.createInteger(count));
            }

            return valueFactory.createString(subject);
        },

        'strpos': function (haystackReference, needleReference, offsetReference) {
            var haystack = haystackReference.getNative(),
                needle = needleReference.getNative(),
                offset = offsetReference ? offsetReference.getNative() : 0,
                position;

            // Negative offsets indicate no. of chars at end of haystack to scan
            if (offset < 0) {
                offset = haystack.length + offset;
            }

            position = haystack.substr(offset).indexOf(needle);

            if (position === -1) {
                return valueFactory.createBoolean(false);
            }

            return valueFactory.createInteger(offset + position);
        },

        'strrpos': function (haystackReference, needleReference, offsetReference) {
            var haystack = haystackReference.getValue().getNative(),
                needle = needleReference.getValue().getNative(),
                offset = offsetReference ? offsetReference.getValue().getNative() : 0,
                position;

            // Negative offsets indicate no. of chars at end of haystack to scan
            if (offset < 0) {
                offset = haystack.length + offset;
            }

            position = haystack.substr(offset).lastIndexOf(needle);

            if (position === -1) {
                return valueFactory.createBoolean(false);
            }

            return valueFactory.createInteger(offset + position);
        },

        'strtr': function (stringReference) {
            var from,
                to,
                i,
                replacePairs,
                replaceKeys,
                replaceValues,
                string = stringReference.getValue().getNative();

            if (arguments.length === 2) {
                // 2-operand form: second argument is an associative array
                // mapping substrings to search for to their replacements
                replacePairs = arguments[1].getValue();
                replaceKeys = replacePairs.getKeys();
                replaceValues = replacePairs.getValues();

                _.each(replaceKeys, function (key, index) {
                    var find = key.coerceToString().getNative(),
                        replace = replaceValues[index].coerceToString().getNative();

                    string = string.replace(
                        new RegExp(_.escapeRegExp(find), 'g'),
                        replace
                    );
                });
            } else {
                // 3-operand form: replace all characters in $from
                // with their counterparts at that index in $to
                from = arguments[1].getValue().getNative();
                to = arguments[2].getValue().getNative();

                for (i = 0; i < from.length && i < to.length; i++) {
                    string = string.replace(
                        new RegExp(_.escapeRegExp(from.charAt(i)), 'g'),
                        to.charAt(i)
                    );
                }
            }

            return valueFactory.createString(string);
        },

        'substr': function (stringReference, startReference, lengthReference) {
            var string = stringReference.getValue().getNative(),
                start = startReference.getValue().getNative(),
                length = lengthReference ? lengthReference.getValue().getNative() : string.length,
                substring;

            if (start < 0) {
                start = string.length + start;
            }

            if (length < 0) {
                length = string.length - start + length;
            }

            substring = string.substr(start, length);

            return valueFactory.createString(substring);
        }
    };
};

},{"microdash":28,"phpcommon":87}],166:[function(require,module,exports){
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */

'use strict';

var phpCommon = require('phpcommon'),
    PHPError = phpCommon.PHPError;

module.exports = function (internals) {
    var callStack = internals.callStack,
        pausable = internals.pausable;

    return {
        'usleep': function (microsecondsReference) {
            var microsecondsValue = microsecondsReference.getValue(),
                pause;

            if (microsecondsValue.getType() !== 'integer' && microsecondsValue.getType() !== 'float') {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'usleep() expects parameter 1 to be integer or float, ' +
                        microsecondsValue.getType() + ' given'
                );
                return;
            }

            pause = pausable.createPause();

            setTimeout(function () {
                pause.resume();
            }, microsecondsValue.getNative() / 1000);

            pause.now();
        }
    };
};

},{"phpcommon":87}],167:[function(require,module,exports){
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    hasOwn = {}.hasOwnProperty,
    phpCommon = require('phpcommon'),
    MAX_DUMPS = 20000,
    MAX_RECURSION_DEPTH = 5,
    MAX_STRING_LENGTH = 2048,
    PHPError = phpCommon.PHPError;

module.exports = function (internals) {
    var callStack = internals.callStack,
        stdout = internals.stdout,
        valueFactory = internals.valueFactory;

    function createTypeChecker(name, type) {
        return function (valueReference) {
            if (!valueReference) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    name + '() expects exactly 1 parameter, 0 given'
                );

                return valueFactory.createBoolean(false);
            }

            return valueFactory.createBoolean(valueReference.getValue().getType() === type);
        };
    }

    return {
        'is_array': createTypeChecker('is_array', 'array'),

        'is_bool': createTypeChecker('is_bool', 'boolean'),

        'is_float': createTypeChecker('is_float', 'float'),

        // NB: This output matches that of PHP with XDebug disabled
        'var_dump': function (valueReference) {
            var arrays = [],
                dumps = 0,
                value,
                objectIDHash = {};

            if (!valueReference) {
                callStack.raiseError(PHPError.E_WARNING, 'var_dump() expects at least 1 parameter, 0 given');
                return;
            }

            value = valueReference.getValue();

            function dump(value, depth, isReference) {
                var currentIndentation = new Array(depth).join('  '),
                    names,
                    nativeLength,
                    nativeValue,
                    nextIndentation = new Array(depth + 1).join('  '),
                    representation = currentIndentation;

                dumps++;

                if (depth > MAX_RECURSION_DEPTH || dumps > MAX_DUMPS) {
                    representation += '*RECURSION*';
                    return representation + '\n';
                }

                if (value.getType() === 'array') {
                    if (arrays.indexOf(value.getValue()) > -1) {
                        representation += '*RECURSION*';
                        return representation + '\n';
                    }

                    if (isReference) {
                        arrays.push(value.getValue());
                        representation += '&';
                    }

                    representation += 'array(' + value.getLength() + ') {\n';

                    _.each(value.getKeys(), function (key) {
                        var element = value.getElementByKey(key),
                            elementRepresentation;

                        elementRepresentation = dump(element.getValue(), depth + 1, element.isReference());

                        representation += nextIndentation +
                            '[' +
                            JSON.stringify(key.getNative()) +
                            ']=>\n' +
                            elementRepresentation;
                    });

                    representation += currentIndentation + '}';
                } else if (value.getType() === 'object') {
                    if (hasOwn.call(objectIDHash, value.getID())) {
                        representation += '*RECURSION*';
                        return representation + '\n';
                    }

                    if (isReference) {
                        representation += '&';
                    }

                    names = value.getInstancePropertyNames();

                    representation += 'object(' + value.getClassName() + ')#' + value.getID() + ' (' + names.length + ') {\n';

                    objectIDHash[value.getID()] = true;

                    _.each(names, function (nameValue) {
                        var property = value.getInstancePropertyByName(nameValue);
                        representation += nextIndentation +
                            '[' +
                            JSON.stringify(nameValue.getNative()) +
                            ']=>\n' +
                            dump(
                                property.getValue(),
                                depth + 1,
                                property.isReference()
                            );
                    });

                    representation += currentIndentation + '}';
                } else {
                    if (isReference) {
                        representation += '&';
                    }

                    switch (value.getType()) {
                    case 'boolean':
                        representation += 'bool(' + (value.getNative() ? 'true' : 'false') + ')';
                        break;
                    case 'float':
                        representation += 'float(' + value.getNative() + ')';
                        break;
                    case 'integer':
                        representation += 'int(' + value.getNative() + ')';
                        break;
                    case 'null':
                        representation += 'NULL';
                        break;
                    case 'string':
                        nativeValue = value.getNative();
                        nativeLength = nativeValue.length;

                        if (nativeLength > MAX_STRING_LENGTH) {
                            nativeValue = nativeValue.substr(0, MAX_STRING_LENGTH) + '...';
                        }

                        representation += 'string(' + nativeLength + ') "' + nativeValue + '"';
                        break;
                    }
                }

                return representation + '\n';
            }

            stdout.write(dump(value, 1));
        }
    };
};

},{"microdash":28,"phpcommon":87}],168:[function(require,module,exports){
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

'use strict';

module.exports = function () {
    function Countable() {

    }

    return Countable;
};

},{}],169:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],170:[function(require,module,exports){
/*
 * TemplateString - Simple template strings
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/asmblah/template-string/
 *
 * Released under the MIT license
 * https://github.com/asmblah/template-string/raw/master/MIT-LICENSE.txt
 */

'use strict';

var hasOwn = {}.hasOwnProperty;

/**
 * Replaces placeholders in `string` of the form `${...}`
 * if they are specified as own properties of `variables`
 *
 * @param {string} string
 * @param {Object.<string, string>} variables
 * @returns {string}
 */
function templateString(string, variables) {
    if (!variables) {
        // Nothing to do if no variables object was provided
        return string;
    }

    return string.replace(/\$\{([^}]+)}/g, function (all, name) {
        if (hasOwn.call(variables, name)) {
            return variables[name];
        }

        return all;
    });
}

module.exports = templateString;

},{}],171:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],172:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":171,"_process":169,"inherits":26}],173:[function(require,module,exports){
require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api").init(function (path, checkExistence) {
    var exists = false;

    function handlePath(aPath) {
        if (!checkExistence) {
            return aPath;
        }

        if (aPath === path) {
            exists = true;
        }

        return null;
    }

    switch (path) {
    case handlePath("php/src/MyApp/dispatchIt.php"): return require("./dispatchIt.php");
    case handlePath("vendor/autoload.php"): return require("./../../../vendor/autoload.php");
    case handlePath("vendor/composer/autoload_classmap.php"): return require("./../../../vendor/composer/autoload_classmap.php");
    case handlePath("vendor/composer/autoload_namespaces.php"): return require("./../../../vendor/composer/autoload_namespaces.php");
    case handlePath("vendor/composer/autoload_psr4.php"): return require("./../../../vendor/composer/autoload_psr4.php");
    case handlePath("vendor/composer/autoload_real.php"): return require("./../../../vendor/composer/autoload_real.php");
    case handlePath("vendor/composer/autoload_static.php"): return require("./../../../vendor/composer/autoload_static.php");
    case handlePath("vendor/composer/ClassLoader.php"): return require("./../../../vendor/composer/ClassLoader.php");
    case handlePath("vendor/symfony/event-dispatcher/ContainerAwareEventDispatcher.php"): return require("./../../../vendor/symfony/event-dispatcher/ContainerAwareEventDispatcher.php");
    case handlePath("vendor/symfony/event-dispatcher/Debug/TraceableEventDispatcher.php"): return require("./../../../vendor/symfony/event-dispatcher/Debug/TraceableEventDispatcher.php");
    case handlePath("vendor/symfony/event-dispatcher/Debug/TraceableEventDispatcherInterface.php"): return require("./../../../vendor/symfony/event-dispatcher/Debug/TraceableEventDispatcherInterface.php");
    case handlePath("vendor/symfony/event-dispatcher/Debug/WrappedListener.php"): return require("./../../../vendor/symfony/event-dispatcher/Debug/WrappedListener.php");
    case handlePath("vendor/symfony/event-dispatcher/DependencyInjection/RegisterListenersPass.php"): return require("./../../../vendor/symfony/event-dispatcher/DependencyInjection/RegisterListenersPass.php");
    case handlePath("vendor/symfony/event-dispatcher/Event.php"): return require("./../../../vendor/symfony/event-dispatcher/Event.php");
    case handlePath("vendor/symfony/event-dispatcher/EventDispatcher.php"): return require("./../../../vendor/symfony/event-dispatcher/EventDispatcher.php");
    case handlePath("vendor/symfony/event-dispatcher/EventDispatcherInterface.php"): return require("./../../../vendor/symfony/event-dispatcher/EventDispatcherInterface.php");
    case handlePath("vendor/symfony/event-dispatcher/EventSubscriberInterface.php"): return require("./../../../vendor/symfony/event-dispatcher/EventSubscriberInterface.php");
    case handlePath("vendor/symfony/event-dispatcher/GenericEvent.php"): return require("./../../../vendor/symfony/event-dispatcher/GenericEvent.php");
    case handlePath("vendor/symfony/event-dispatcher/ImmutableEventDispatcher.php"): return require("./../../../vendor/symfony/event-dispatcher/ImmutableEventDispatcher.php");
    case handlePath("vendor/symfony/event-dispatcher/Tests/AbstractEventDispatcherTest.php"): return require("./../../../vendor/symfony/event-dispatcher/Tests/AbstractEventDispatcherTest.php");
    case handlePath("vendor/symfony/event-dispatcher/Tests/ContainerAwareEventDispatcherTest.php"): return require("./../../../vendor/symfony/event-dispatcher/Tests/ContainerAwareEventDispatcherTest.php");
    case handlePath("vendor/symfony/event-dispatcher/Tests/Debug/TraceableEventDispatcherTest.php"): return require("./../../../vendor/symfony/event-dispatcher/Tests/Debug/TraceableEventDispatcherTest.php");
    case handlePath("vendor/symfony/event-dispatcher/Tests/DependencyInjection/RegisterListenersPassTest.php"): return require("./../../../vendor/symfony/event-dispatcher/Tests/DependencyInjection/RegisterListenersPassTest.php");
    case handlePath("vendor/symfony/event-dispatcher/Tests/EventDispatcherTest.php"): return require("./../../../vendor/symfony/event-dispatcher/Tests/EventDispatcherTest.php");
    case handlePath("vendor/symfony/event-dispatcher/Tests/EventTest.php"): return require("./../../../vendor/symfony/event-dispatcher/Tests/EventTest.php");
    case handlePath("vendor/symfony/event-dispatcher/Tests/GenericEventTest.php"): return require("./../../../vendor/symfony/event-dispatcher/Tests/GenericEventTest.php");
    case handlePath("vendor/symfony/event-dispatcher/Tests/ImmutableEventDispatcherTest.php"): return require("./../../../vendor/symfony/event-dispatcher/Tests/ImmutableEventDispatcherTest.php");
    }

    return checkExistence ? exists : null;
});
module.exports = require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api").load("php/src/MyApp/dispatchIt.php", require('/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime').compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.createNamespaceScope(namespace), namespaceResult, scope = tools.topLevelScope, currentClass = null;if (namespaceResult = (function (globalNamespace) {var namespace = globalNamespace.getDescendant("MyApp"), namespaceScope = tools.createNamespaceScope(namespace);namespaceScope.use("Symfony\\Component\\EventDispatcher\\EventDispatcher");tools.requireOnce(tools.getPathDirectory().concat(tools.valueFactory.createString("/../../../vendor/autoload.php")).getNative(), scope);scope.getVariable("eventDispatcher").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("EventDispatcher"), []));scope.getVariable("eventDispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("my.event"), tools.createClosure(function () {var scope = this;(stdout.write(tools.valueFactory.createString("Listener called!").coerceToString().getNative()), tools.valueFactory.createInteger(1));}, scope)]);scope.getVariable("eventDispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("dispatch").getNative(), [tools.valueFactory.createString("my.event")]);(stdout.write(tools.valueFactory.createString("and...").coerceToString().getNative()), tools.valueFactory.createInteger(1));scope.getVariable("eventDispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("dispatch").getNative(), [tools.valueFactory.createString("my.event")]);}(namespace))) { return namespaceResult; }return tools.valueFactory.createNull();}));
},{"./../../../vendor/autoload.php":174,"./../../../vendor/composer/ClassLoader.php":175,"./../../../vendor/composer/autoload_classmap.php":176,"./../../../vendor/composer/autoload_namespaces.php":177,"./../../../vendor/composer/autoload_psr4.php":178,"./../../../vendor/composer/autoload_real.php":179,"./../../../vendor/composer/autoload_static.php":180,"./../../../vendor/symfony/event-dispatcher/ContainerAwareEventDispatcher.php":181,"./../../../vendor/symfony/event-dispatcher/Debug/TraceableEventDispatcher.php":182,"./../../../vendor/symfony/event-dispatcher/Debug/TraceableEventDispatcherInterface.php":183,"./../../../vendor/symfony/event-dispatcher/Debug/WrappedListener.php":184,"./../../../vendor/symfony/event-dispatcher/DependencyInjection/RegisterListenersPass.php":185,"./../../../vendor/symfony/event-dispatcher/Event.php":186,"./../../../vendor/symfony/event-dispatcher/EventDispatcher.php":187,"./../../../vendor/symfony/event-dispatcher/EventDispatcherInterface.php":188,"./../../../vendor/symfony/event-dispatcher/EventSubscriberInterface.php":189,"./../../../vendor/symfony/event-dispatcher/GenericEvent.php":190,"./../../../vendor/symfony/event-dispatcher/ImmutableEventDispatcher.php":191,"./../../../vendor/symfony/event-dispatcher/Tests/AbstractEventDispatcherTest.php":192,"./../../../vendor/symfony/event-dispatcher/Tests/ContainerAwareEventDispatcherTest.php":193,"./../../../vendor/symfony/event-dispatcher/Tests/Debug/TraceableEventDispatcherTest.php":194,"./../../../vendor/symfony/event-dispatcher/Tests/DependencyInjection/RegisterListenersPassTest.php":195,"./../../../vendor/symfony/event-dispatcher/Tests/EventDispatcherTest.php":196,"./../../../vendor/symfony/event-dispatcher/Tests/EventTest.php":197,"./../../../vendor/symfony/event-dispatcher/Tests/GenericEventTest.php":198,"./../../../vendor/symfony/event-dispatcher/Tests/ImmutableEventDispatcherTest.php":199,"./dispatchIt.php":173,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api":147,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime":153}],174:[function(require,module,exports){
require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php");
module.exports = require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api").load("vendor/autoload.php", require('/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime').compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.createNamespaceScope(namespace), namespaceResult, scope = tools.topLevelScope, currentClass = null;tools.requireOnce(tools.getPathDirectory().concat(tools.valueFactory.createString("/composer")).concat(tools.valueFactory.createString("/autoload_real.php")).getNative(), scope);return tools.valueFactory.createBarewordString("ComposerAutoloaderInit420ecf0d2ea534165cf69ed795619dd8").callStaticMethod(tools.valueFactory.createBarewordString("getLoader"), [], namespaceScope);return tools.valueFactory.createNull();}));
},{"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api":147,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime":153,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php":173}],175:[function(require,module,exports){
require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php");
module.exports = require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api").load("vendor/composer/ClassLoader.php", require('/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime').compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.createNamespaceScope(namespace), namespaceResult, scope = tools.topLevelScope, currentClass = null;if (namespaceResult = (function (globalNamespace) {var namespace = globalNamespace.getDescendant("Composer\\Autoload"), namespaceScope = tools.createNamespaceScope(namespace);(function () {var currentClass = namespace.defineClass("ClassLoader", {superClass: null, interfaces: [], staticProperties: {}, properties: {"prefixLengthsPsr4": tools.valueFactory.createArray([]), "prefixDirsPsr4": tools.valueFactory.createArray([]), "fallbackDirsPsr4": tools.valueFactory.createArray([]), "prefixesPsr0": tools.valueFactory.createArray([]), "fallbackDirsPsr0": tools.valueFactory.createArray([]), "useIncludePath": tools.valueFactory.createBoolean(false), "classMap": tools.valueFactory.createArray([]), "classMapAuthoritative": tools.valueFactory.createBoolean(false)}, methods: {"getPrefixes": {isStatic: false, method: function () {var scope = this;if ((tools.valueFactory.createBarewordString("empty").call([scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("prefixesPsr0"))], namespaceScope) || tools.valueFactory.createNull()).logicalNot().coerceToBoolean().getNative()) {return (tools.valueFactory.createBarewordString("call_user_func_array").call([tools.valueFactory.createString("array_merge"), scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("prefixesPsr0"))], namespaceScope) || tools.valueFactory.createNull());}return tools.valueFactory.createArray([]);}}, "getPrefixesPsr4": {isStatic: false, method: function () {var scope = this;return scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("prefixDirsPsr4")).getValue();}}, "getFallbackDirs": {isStatic: false, method: function () {var scope = this;return scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("fallbackDirsPsr0")).getValue();}}, "getFallbackDirsPsr4": {isStatic: false, method: function () {var scope = this;return scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("fallbackDirsPsr4")).getValue();}}, "getClassMap": {isStatic: false, method: function () {var scope = this;return scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("classMap")).getValue();}}, "addClassMap": {isStatic: false, method: function ($classMap) {var scope = this;scope.getVariable("classMap").setValue($classMap.getValue());if (scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("classMap")).getValue().coerceToBoolean().getNative()) {tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("classMap")).setValue((tools.valueFactory.createBarewordString("array_merge").call([scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("classMap")), scope.getVariable("classMap")], namespaceScope) || tools.valueFactory.createNull()));} else {tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("classMap")).setValue(scope.getVariable("classMap").getValue());}}}, "add": {isStatic: false, method: function ($prefix, $paths, $prepend) {var scope = this;scope.getVariable("prefix").setValue($prefix.getValue());scope.getVariable("paths").setValue($paths.getValue());scope.getVariable("prepend").setValue($prepend ? $prepend.getValue() : tools.valueFactory.createBoolean(false));if (scope.getVariable("prefix").getValue().logicalNot().coerceToBoolean().getNative()) {if (scope.getVariable("prepend").getValue().coerceToBoolean().getNative()) {tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("fallbackDirsPsr0")).setValue((tools.valueFactory.createBarewordString("array_merge").call([scope.getVariable("paths").getValue().coerceToArray(), scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("fallbackDirsPsr0"))], namespaceScope) || tools.valueFactory.createNull()));} else {tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("fallbackDirsPsr0")).setValue((tools.valueFactory.createBarewordString("array_merge").call([scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("fallbackDirsPsr0")), scope.getVariable("paths").getValue().coerceToArray()], namespaceScope) || tools.valueFactory.createNull()));}return tools.valueFactory.createNull();}scope.getVariable("first").setValue(scope.getVariable("prefix").getValue().getElementByKey(tools.valueFactory.createInteger(0)).getValue());if ((function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean(scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("prefixesPsr0")).getValue().getElementByKey(scope.getVariable("first").getValue()).getValue().getElementByKey(scope.getVariable("prefix").getValue()).isSet());scope.unsuppressOwnErrors(); return result;}(scope)).logicalNot().coerceToBoolean().getNative()) {tools.implyArray(tools.implyArray(tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("prefixesPsr0"))).getElementByKey(scope.getVariable("first").getValue())).getElementByKey(scope.getVariable("prefix").getValue()).setValue(scope.getVariable("paths").getValue().coerceToArray());return tools.valueFactory.createNull();}if (scope.getVariable("prepend").getValue().coerceToBoolean().getNative()) {tools.implyArray(tools.implyArray(tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("prefixesPsr0"))).getElementByKey(scope.getVariable("first").getValue())).getElementByKey(scope.getVariable("prefix").getValue()).setValue((tools.valueFactory.createBarewordString("array_merge").call([scope.getVariable("paths").getValue().coerceToArray(), scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("prefixesPsr0")).getValue().getElementByKey(scope.getVariable("first").getValue()).getValue().getElementByKey(scope.getVariable("prefix").getValue())], namespaceScope) || tools.valueFactory.createNull()));} else {tools.implyArray(tools.implyArray(tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("prefixesPsr0"))).getElementByKey(scope.getVariable("first").getValue())).getElementByKey(scope.getVariable("prefix").getValue()).setValue((tools.valueFactory.createBarewordString("array_merge").call([scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("prefixesPsr0")).getValue().getElementByKey(scope.getVariable("first").getValue()).getValue().getElementByKey(scope.getVariable("prefix").getValue()), scope.getVariable("paths").getValue().coerceToArray()], namespaceScope) || tools.valueFactory.createNull()));}}}, "addPsr4": {isStatic: false, method: function ($prefix, $paths, $prepend) {var scope = this;scope.getVariable("prefix").setValue($prefix.getValue());scope.getVariable("paths").setValue($paths.getValue());scope.getVariable("prepend").setValue($prepend ? $prepend.getValue() : tools.valueFactory.createBoolean(false));if (scope.getVariable("prefix").getValue().logicalNot().coerceToBoolean().getNative()) {if (scope.getVariable("prepend").getValue().coerceToBoolean().getNative()) {tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("fallbackDirsPsr4")).setValue((tools.valueFactory.createBarewordString("array_merge").call([scope.getVariable("paths").getValue().coerceToArray(), scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("fallbackDirsPsr4"))], namespaceScope) || tools.valueFactory.createNull()));} else {tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("fallbackDirsPsr4")).setValue((tools.valueFactory.createBarewordString("array_merge").call([scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("fallbackDirsPsr4")), scope.getVariable("paths").getValue().coerceToArray()], namespaceScope) || tools.valueFactory.createNull()));}} else {if ((function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean(scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("prefixDirsPsr4")).getValue().getElementByKey(scope.getVariable("prefix").getValue()).isSet());scope.unsuppressOwnErrors(); return result;}(scope)).logicalNot().coerceToBoolean().getNative()) {scope.getVariable("length").setValue((tools.valueFactory.createBarewordString("strlen").call([scope.getVariable("prefix")], namespaceScope) || tools.valueFactory.createNull()));if (tools.valueFactory.createString("\\").isNotIdenticalTo(scope.getVariable("prefix").getValue().getElementByKey(scope.getVariable("length").getValue().subtract(tools.valueFactory.createInteger(1))).getValue()).coerceToBoolean().getNative()) {throw tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("\\InvalidArgumentException"), [tools.valueFactory.createString("A non-empty PSR-4 prefix must end with a namespace separator.")]);}tools.implyArray(tools.implyArray(tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("prefixLengthsPsr4"))).getElementByKey(scope.getVariable("prefix").getValue().getElementByKey(tools.valueFactory.createInteger(0)).getValue())).getElementByKey(scope.getVariable("prefix").getValue()).setValue(scope.getVariable("length").getValue());tools.implyArray(tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("prefixDirsPsr4"))).getElementByKey(scope.getVariable("prefix").getValue()).setValue(scope.getVariable("paths").getValue().coerceToArray());} else {if (scope.getVariable("prepend").getValue().coerceToBoolean().getNative()) {tools.implyArray(tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("prefixDirsPsr4"))).getElementByKey(scope.getVariable("prefix").getValue()).setValue((tools.valueFactory.createBarewordString("array_merge").call([scope.getVariable("paths").getValue().coerceToArray(), scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("prefixDirsPsr4")).getValue().getElementByKey(scope.getVariable("prefix").getValue())], namespaceScope) || tools.valueFactory.createNull()));} else {tools.implyArray(tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("prefixDirsPsr4"))).getElementByKey(scope.getVariable("prefix").getValue()).setValue((tools.valueFactory.createBarewordString("array_merge").call([scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("prefixDirsPsr4")).getValue().getElementByKey(scope.getVariable("prefix").getValue()), scope.getVariable("paths").getValue().coerceToArray()], namespaceScope) || tools.valueFactory.createNull()));}}}}}, "set": {isStatic: false, method: function ($prefix, $paths) {var scope = this;scope.getVariable("prefix").setValue($prefix.getValue());scope.getVariable("paths").setValue($paths.getValue());if (scope.getVariable("prefix").getValue().logicalNot().coerceToBoolean().getNative()) {tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("fallbackDirsPsr0")).setValue(scope.getVariable("paths").getValue().coerceToArray());} else {tools.implyArray(tools.implyArray(tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("prefixesPsr0"))).getElementByKey(scope.getVariable("prefix").getValue().getElementByKey(tools.valueFactory.createInteger(0)).getValue())).getElementByKey(scope.getVariable("prefix").getValue()).setValue(scope.getVariable("paths").getValue().coerceToArray());}}}, "setPsr4": {isStatic: false, method: function ($prefix, $paths) {var scope = this;scope.getVariable("prefix").setValue($prefix.getValue());scope.getVariable("paths").setValue($paths.getValue());if (scope.getVariable("prefix").getValue().logicalNot().coerceToBoolean().getNative()) {tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("fallbackDirsPsr4")).setValue(scope.getVariable("paths").getValue().coerceToArray());} else {scope.getVariable("length").setValue((tools.valueFactory.createBarewordString("strlen").call([scope.getVariable("prefix")], namespaceScope) || tools.valueFactory.createNull()));if (tools.valueFactory.createString("\\").isNotIdenticalTo(scope.getVariable("prefix").getValue().getElementByKey(scope.getVariable("length").getValue().subtract(tools.valueFactory.createInteger(1))).getValue()).coerceToBoolean().getNative()) {throw tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("\\InvalidArgumentException"), [tools.valueFactory.createString("A non-empty PSR-4 prefix must end with a namespace separator.")]);}tools.implyArray(tools.implyArray(tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("prefixLengthsPsr4"))).getElementByKey(scope.getVariable("prefix").getValue().getElementByKey(tools.valueFactory.createInteger(0)).getValue())).getElementByKey(scope.getVariable("prefix").getValue()).setValue(scope.getVariable("length").getValue());tools.implyArray(tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("prefixDirsPsr4"))).getElementByKey(scope.getVariable("prefix").getValue()).setValue(scope.getVariable("paths").getValue().coerceToArray());}}}, "setUseIncludePath": {isStatic: false, method: function ($useIncludePath) {var scope = this;scope.getVariable("useIncludePath").setValue($useIncludePath.getValue());tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("useIncludePath")).setValue(scope.getVariable("useIncludePath").getValue());}}, "getUseIncludePath": {isStatic: false, method: function () {var scope = this;return scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("useIncludePath")).getValue();}}, "setClassMapAuthoritative": {isStatic: false, method: function ($classMapAuthoritative) {var scope = this;scope.getVariable("classMapAuthoritative").setValue($classMapAuthoritative.getValue());tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("classMapAuthoritative")).setValue(scope.getVariable("classMapAuthoritative").getValue());}}, "isClassMapAuthoritative": {isStatic: false, method: function () {var scope = this;return scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("classMapAuthoritative")).getValue();}}, "register": {isStatic: false, method: function ($prepend) {var scope = this;scope.getVariable("prepend").setValue($prepend ? $prepend.getValue() : tools.valueFactory.createBoolean(false));(tools.valueFactory.createBarewordString("spl_autoload_register").call([tools.valueFactory.createArray([scope.getVariable("this"), tools.valueFactory.createString("loadClass")]), tools.valueFactory.createBoolean(true), scope.getVariable("prepend")], namespaceScope) || tools.valueFactory.createNull());}}, "unregister": {isStatic: false, method: function () {var scope = this;(tools.valueFactory.createBarewordString("spl_autoload_unregister").call([tools.valueFactory.createArray([scope.getVariable("this"), tools.valueFactory.createString("loadClass")])], namespaceScope) || tools.valueFactory.createNull());}}, "loadClass": {isStatic: false, method: function ($class) {var scope = this;scope.getVariable("class").setValue($class.getValue());if (scope.getVariable("file").setValue(scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("findFile").getNative(), [scope.getVariable("class").getValue()])).coerceToBoolean().getNative()) {(tools.valueFactory.createBarewordString("includeFile").call([scope.getVariable("file")], namespaceScope) || tools.valueFactory.createNull());return tools.valueFactory.createBoolean(true);}}}, "findFile": {isStatic: false, method: function ($class) {var scope = this;scope.getVariable("class").setValue($class.getValue());if (tools.valueFactory.createString("\\").isEqualTo(scope.getVariable("class").getValue().getElementByKey(tools.valueFactory.createInteger(0)).getValue()).coerceToBoolean().getNative()) {scope.getVariable("class").setValue((tools.valueFactory.createBarewordString("substr").call([scope.getVariable("class"), tools.valueFactory.createInteger(1)], namespaceScope) || tools.valueFactory.createNull()));}if ((function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean(scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("classMap")).getValue().getElementByKey(scope.getVariable("class").getValue()).isSet());scope.unsuppressOwnErrors(); return result;}(scope)).coerceToBoolean().getNative()) {return scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("classMap")).getValue().getElementByKey(scope.getVariable("class").getValue()).getValue();}if (scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("classMapAuthoritative")).getValue().coerceToBoolean().getNative()) {return tools.valueFactory.createBoolean(false);}scope.getVariable("file").setValue(scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("findFileWithExtension").getNative(), [scope.getVariable("class").getValue(), tools.valueFactory.createString(".php")]));if (tools.valueFactory.createBoolean(scope.getVariable("file").getValue().isIdenticalTo(tools.valueFactory.createNull()).coerceToBoolean().getNative() && ((tools.valueFactory.createBarewordString("defined").call([tools.valueFactory.createString("HHVM_VERSION")], namespaceScope) || tools.valueFactory.createNull()).coerceToBoolean().getNative())).coerceToBoolean().getNative()) {scope.getVariable("file").setValue(scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("findFileWithExtension").getNative(), [scope.getVariable("class").getValue(), tools.valueFactory.createString(".hh")]));}if (scope.getVariable("file").getValue().isIdenticalTo(tools.valueFactory.createNull()).coerceToBoolean().getNative()) {return tools.implyArray(tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("classMap"))).getElementByKey(scope.getVariable("class").getValue()).setValue(tools.valueFactory.createBoolean(false));}return scope.getVariable("file").getValue();}}, "findFileWithExtension": {isStatic: false, method: function ($class, $ext) {var scope = this;scope.getVariable("class").setValue($class.getValue());scope.getVariable("ext").setValue($ext.getValue());scope.getVariable("logicalPathPsr4").setValue((tools.valueFactory.createBarewordString("strtr").call([scope.getVariable("class"), tools.valueFactory.createString("\\"), namespaceScope.getConstant("DIRECTORY_SEPARATOR")], namespaceScope) || tools.valueFactory.createNull()).concat(scope.getVariable("ext").getValue()));scope.getVariable("first").setValue(scope.getVariable("class").getValue().getElementByKey(tools.valueFactory.createInteger(0)).getValue());if ((function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean(scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("prefixLengthsPsr4")).getValue().getElementByKey(scope.getVariable("first").getValue()).isSet());scope.unsuppressOwnErrors(); return result;}(scope)).coerceToBoolean().getNative()) {var array_1 = scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("prefixLengthsPsr4")).getValue().getElementByKey(scope.getVariable("first").getValue()).getValue().reset();var length_1 = array_1.getLength();var pointer_1 = 0;block_1: while (pointer_1 < length_1) {scope.getVariable("prefix").setValue(array_1.getKeyByIndex(pointer_1));scope.getVariable("length").setValue(array_1.getElementByIndex(pointer_1).getValue());pointer_1++;if (tools.valueFactory.createInteger(0).isIdenticalTo((tools.valueFactory.createBarewordString("strpos").call([scope.getVariable("class"), scope.getVariable("prefix")], namespaceScope) || tools.valueFactory.createNull())).coerceToBoolean().getNative()) {var array_2 = scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("prefixDirsPsr4")).getValue().getElementByKey(scope.getVariable("prefix").getValue()).getValue().reset();var length_2 = array_2.getLength();var pointer_2 = 0;block_2: while (pointer_2 < length_2) {scope.getVariable("dir").setValue(array_2.getElementByIndex(pointer_2).getValue());pointer_2++;if ((tools.valueFactory.createBarewordString("file_exists").call([scope.getVariable("file").setValue(scope.getVariable("dir").getValue().concat(namespaceScope.getConstant("DIRECTORY_SEPARATOR")).concat((tools.valueFactory.createBarewordString("substr").call([scope.getVariable("logicalPathPsr4"), scope.getVariable("length")], namespaceScope) || tools.valueFactory.createNull())))], namespaceScope) || tools.valueFactory.createNull()).coerceToBoolean().getNative()) {return scope.getVariable("file").getValue();}}}}}var array_1 = scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("fallbackDirsPsr4")).getValue().reset();var length_1 = array_1.getLength();var pointer_1 = 0;block_1: while (pointer_1 < length_1) {scope.getVariable("dir").setValue(array_1.getElementByIndex(pointer_1).getValue());pointer_1++;if ((tools.valueFactory.createBarewordString("file_exists").call([scope.getVariable("file").setValue(scope.getVariable("dir").getValue().concat(namespaceScope.getConstant("DIRECTORY_SEPARATOR")).concat(scope.getVariable("logicalPathPsr4").getValue()))], namespaceScope) || tools.valueFactory.createNull()).coerceToBoolean().getNative()) {return scope.getVariable("file").getValue();}}if (tools.valueFactory.createBoolean(false).isNotIdenticalTo(scope.getVariable("pos").setValue((tools.valueFactory.createBarewordString("strrpos").call([scope.getVariable("class"), tools.valueFactory.createString("\\")], namespaceScope) || tools.valueFactory.createNull()))).coerceToBoolean().getNative()) {scope.getVariable("logicalPathPsr0").setValue((tools.valueFactory.createBarewordString("substr").call([scope.getVariable("logicalPathPsr4"), tools.valueFactory.createInteger(0), scope.getVariable("pos").getValue().add(tools.valueFactory.createInteger(1))], namespaceScope) || tools.valueFactory.createNull()).concat((tools.valueFactory.createBarewordString("strtr").call([(tools.valueFactory.createBarewordString("substr").call([scope.getVariable("logicalPathPsr4"), scope.getVariable("pos").getValue().add(tools.valueFactory.createInteger(1))], namespaceScope) || tools.valueFactory.createNull()), tools.valueFactory.createString("_"), namespaceScope.getConstant("DIRECTORY_SEPARATOR")], namespaceScope) || tools.valueFactory.createNull())));} else {scope.getVariable("logicalPathPsr0").setValue((tools.valueFactory.createBarewordString("strtr").call([scope.getVariable("class"), tools.valueFactory.createString("_"), namespaceScope.getConstant("DIRECTORY_SEPARATOR")], namespaceScope) || tools.valueFactory.createNull()).concat(scope.getVariable("ext").getValue()));}if ((function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean(scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("prefixesPsr0")).getValue().getElementByKey(scope.getVariable("first").getValue()).isSet());scope.unsuppressOwnErrors(); return result;}(scope)).coerceToBoolean().getNative()) {var array_1 = scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("prefixesPsr0")).getValue().getElementByKey(scope.getVariable("first").getValue()).getValue().reset();var length_1 = array_1.getLength();var pointer_1 = 0;block_1: while (pointer_1 < length_1) {scope.getVariable("prefix").setValue(array_1.getKeyByIndex(pointer_1));scope.getVariable("dirs").setValue(array_1.getElementByIndex(pointer_1).getValue());pointer_1++;if (tools.valueFactory.createInteger(0).isIdenticalTo((tools.valueFactory.createBarewordString("strpos").call([scope.getVariable("class"), scope.getVariable("prefix")], namespaceScope) || tools.valueFactory.createNull())).coerceToBoolean().getNative()) {var array_2 = scope.getVariable("dirs").getValue().reset();var length_2 = array_2.getLength();var pointer_2 = 0;block_2: while (pointer_2 < length_2) {scope.getVariable("dir").setValue(array_2.getElementByIndex(pointer_2).getValue());pointer_2++;if ((tools.valueFactory.createBarewordString("file_exists").call([scope.getVariable("file").setValue(scope.getVariable("dir").getValue().concat(namespaceScope.getConstant("DIRECTORY_SEPARATOR")).concat(scope.getVariable("logicalPathPsr0").getValue()))], namespaceScope) || tools.valueFactory.createNull()).coerceToBoolean().getNative()) {return scope.getVariable("file").getValue();}}}}}var array_1 = scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("fallbackDirsPsr0")).getValue().reset();var length_1 = array_1.getLength();var pointer_1 = 0;block_1: while (pointer_1 < length_1) {scope.getVariable("dir").setValue(array_1.getElementByIndex(pointer_1).getValue());pointer_1++;if ((tools.valueFactory.createBarewordString("file_exists").call([scope.getVariable("file").setValue(scope.getVariable("dir").getValue().concat(namespaceScope.getConstant("DIRECTORY_SEPARATOR")).concat(scope.getVariable("logicalPathPsr0").getValue()))], namespaceScope) || tools.valueFactory.createNull()).coerceToBoolean().getNative()) {return scope.getVariable("file").getValue();}}if (tools.valueFactory.createBoolean(scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("useIncludePath")).getValue().coerceToBoolean().getNative() && (scope.getVariable("file").setValue((tools.valueFactory.createBarewordString("stream_resolve_include_path").call([scope.getVariable("logicalPathPsr0")], namespaceScope) || tools.valueFactory.createNull())).coerceToBoolean().getNative())).coerceToBoolean().getNative()) {return scope.getVariable("file").getValue();}}}}, constants: {}}, namespaceScope);}());namespace.defineFunction("includeFile", function ($file) {var scope = this;scope.getVariable("file").setValue($file.getValue());tools.include(scope.getVariable("file").getValue().getNative(), scope);});}(namespace))) { return namespaceResult; }return tools.valueFactory.createNull();}));
},{"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api":147,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime":153,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php":173}],176:[function(require,module,exports){
require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php");
module.exports = require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api").load("vendor/composer/autoload_classmap.php", require('/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime').compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.createNamespaceScope(namespace), namespaceResult, scope = tools.topLevelScope, currentClass = null;scope.getVariable("vendorDir").setValue((tools.valueFactory.createBarewordString("dirname").call([(tools.valueFactory.createBarewordString("dirname").call([tools.getPath()], namespaceScope) || tools.valueFactory.createNull())], namespaceScope) || tools.valueFactory.createNull()));scope.getVariable("baseDir").setValue((tools.valueFactory.createBarewordString("dirname").call([scope.getVariable("vendorDir")], namespaceScope) || tools.valueFactory.createNull()));return tools.valueFactory.createArray([]);return tools.valueFactory.createNull();}));
},{"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api":147,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime":153,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php":173}],177:[function(require,module,exports){
require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php");
module.exports = require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api").load("vendor/composer/autoload_namespaces.php", require('/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime').compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.createNamespaceScope(namespace), namespaceResult, scope = tools.topLevelScope, currentClass = null;scope.getVariable("vendorDir").setValue((tools.valueFactory.createBarewordString("dirname").call([(tools.valueFactory.createBarewordString("dirname").call([tools.getPath()], namespaceScope) || tools.valueFactory.createNull())], namespaceScope) || tools.valueFactory.createNull()));scope.getVariable("baseDir").setValue((tools.valueFactory.createBarewordString("dirname").call([scope.getVariable("vendorDir")], namespaceScope) || tools.valueFactory.createNull()));return tools.valueFactory.createArray([]);return tools.valueFactory.createNull();}));
},{"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api":147,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime":153,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php":173}],178:[function(require,module,exports){
require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php");
module.exports = require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api").load("vendor/composer/autoload_psr4.php", require('/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime').compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.createNamespaceScope(namespace), namespaceResult, scope = tools.topLevelScope, currentClass = null;scope.getVariable("vendorDir").setValue((tools.valueFactory.createBarewordString("dirname").call([(tools.valueFactory.createBarewordString("dirname").call([tools.getPath()], namespaceScope) || tools.valueFactory.createNull())], namespaceScope) || tools.valueFactory.createNull()));scope.getVariable("baseDir").setValue((tools.valueFactory.createBarewordString("dirname").call([scope.getVariable("vendorDir")], namespaceScope) || tools.valueFactory.createNull()));return tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("Symfony\\Component\\EventDispatcher\\"), tools.valueFactory.createArray([scope.getVariable("vendorDir").getValue().concat(tools.valueFactory.createString("/symfony/event-dispatcher"))]))]);return tools.valueFactory.createNull();}));
},{"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api":147,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime":153,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php":173}],179:[function(require,module,exports){
require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php");
module.exports = require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api").load("vendor/composer/autoload_real.php", require('/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime').compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.createNamespaceScope(namespace), namespaceResult, scope = tools.topLevelScope, currentClass = null;(function () {var currentClass = namespace.defineClass("ComposerAutoloaderInit420ecf0d2ea534165cf69ed795619dd8", {superClass: null, interfaces: [], staticProperties: {"loader": {visibility: "private", value: tools.valueFactory.createNull()}}, properties: {}, methods: {"loadClassLoader": {isStatic: true, method: function ($class) {var scope = this;scope.getVariable("class").setValue($class.getValue());if (tools.valueFactory.createString("Composer\\Autoload\\ClassLoader").isIdenticalTo(scope.getVariable("class").getValue()).coerceToBoolean().getNative()) {tools.require(tools.getPathDirectory().concat(tools.valueFactory.createString("/ClassLoader.php")).getNative(), scope);}}}, "getLoader": {isStatic: true, method: function () {var scope = this;if (tools.valueFactory.createNull().isNotIdenticalTo(scope.getClassNameOrThrow().getStaticPropertyByName(tools.valueFactory.createBarewordString("loader"), namespaceScope).getValue()).coerceToBoolean().getNative()) {return scope.getClassNameOrThrow().getStaticPropertyByName(tools.valueFactory.createBarewordString("loader"), namespaceScope).getValue();}(tools.valueFactory.createBarewordString("spl_autoload_register").call([tools.valueFactory.createArray([tools.valueFactory.createString("ComposerAutoloaderInit420ecf0d2ea534165cf69ed795619dd8"), tools.valueFactory.createString("loadClassLoader")]), tools.valueFactory.createBoolean(true), tools.valueFactory.createBoolean(true)], namespaceScope) || tools.valueFactory.createNull());scope.getClassNameOrThrow().getStaticPropertyByName(tools.valueFactory.createBarewordString("loader"), namespaceScope).setValue(scope.getVariable("loader").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("\\Composer\\Autoload\\ClassLoader"), [])));(tools.valueFactory.createBarewordString("spl_autoload_unregister").call([tools.valueFactory.createArray([tools.valueFactory.createString("ComposerAutoloaderInit420ecf0d2ea534165cf69ed795619dd8"), tools.valueFactory.createString("loadClassLoader")])], namespaceScope) || tools.valueFactory.createNull());scope.getVariable("useStaticLoader").setValue(tools.valueFactory.createBoolean(namespaceScope.getConstant("PHP_VERSION_ID").isGreaterThanOrEqual(tools.valueFactory.createInteger(50600)).coerceToBoolean().getNative() && ((tools.valueFactory.createBarewordString("defined").call([tools.valueFactory.createString("HHVM_VERSION")], namespaceScope) || tools.valueFactory.createNull()).logicalNot().coerceToBoolean().getNative())));if (scope.getVariable("useStaticLoader").getValue().coerceToBoolean().getNative()) {tools.requireOnce(tools.getPathDirectory().concat(tools.valueFactory.createString("/autoload_static.php")).getNative(), scope);(tools.valueFactory.createBarewordString("call_user_func").call([tools.valueFactory.createBarewordString("\\Composer\\Autoload\\ComposerStaticInit420ecf0d2ea534165cf69ed795619dd8").callStaticMethod(tools.valueFactory.createBarewordString("getInitializer"), [scope.getVariable("loader")], namespaceScope)], namespaceScope) || tools.valueFactory.createNull());} else {scope.getVariable("map").setValue(tools.require(tools.getPathDirectory().concat(tools.valueFactory.createString("/autoload_namespaces.php")).getNative(), scope));var array_1 = scope.getVariable("map").getValue().reset();var length_1 = array_1.getLength();var pointer_1 = 0;block_1: while (pointer_1 < length_1) {scope.getVariable("namespace").setValue(array_1.getKeyByIndex(pointer_1));scope.getVariable("path").setValue(array_1.getElementByIndex(pointer_1).getValue());pointer_1++;scope.getVariable("loader").getValue().callMethod(tools.valueFactory.createBarewordString("set").getNative(), [scope.getVariable("namespace").getValue(), scope.getVariable("path").getValue()]);}scope.getVariable("map").setValue(tools.require(tools.getPathDirectory().concat(tools.valueFactory.createString("/autoload_psr4.php")).getNative(), scope));var array_1 = scope.getVariable("map").getValue().reset();var length_1 = array_1.getLength();var pointer_1 = 0;block_1: while (pointer_1 < length_1) {scope.getVariable("namespace").setValue(array_1.getKeyByIndex(pointer_1));scope.getVariable("path").setValue(array_1.getElementByIndex(pointer_1).getValue());pointer_1++;scope.getVariable("loader").getValue().callMethod(tools.valueFactory.createBarewordString("setPsr4").getNative(), [scope.getVariable("namespace").getValue(), scope.getVariable("path").getValue()]);}scope.getVariable("classMap").setValue(tools.require(tools.getPathDirectory().concat(tools.valueFactory.createString("/autoload_classmap.php")).getNative(), scope));if (scope.getVariable("classMap").getValue().coerceToBoolean().getNative()) {scope.getVariable("loader").getValue().callMethod(tools.valueFactory.createBarewordString("addClassMap").getNative(), [scope.getVariable("classMap").getValue()]);}}scope.getVariable("loader").getValue().callMethod(tools.valueFactory.createBarewordString("register").getNative(), [tools.valueFactory.createBoolean(true)]);return scope.getVariable("loader").getValue();}}}, constants: {}}, namespaceScope);}());return tools.valueFactory.createNull();}));
},{"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api":147,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime":153,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php":173}],180:[function(require,module,exports){
require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php");
module.exports = require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api").load("vendor/composer/autoload_static.php", require('/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime').compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.createNamespaceScope(namespace), namespaceResult, scope = tools.topLevelScope, currentClass = null;if (namespaceResult = (function (globalNamespace) {var namespace = globalNamespace.getDescendant("Composer\\Autoload"), namespaceScope = tools.createNamespaceScope(namespace);(function () {var currentClass = namespace.defineClass("ComposerStaticInit420ecf0d2ea534165cf69ed795619dd8", {superClass: null, interfaces: [], staticProperties: {"prefixLengthsPsr4": {visibility: "public", value: tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("S"), tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("Symfony\\Component\\EventDispatcher\\"), tools.valueFactory.createInteger(34))]))])}, "prefixDirsPsr4": {visibility: "public", value: tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("Symfony\\Component\\EventDispatcher\\"), tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createInteger(0), tools.getPathDirectory().concat(tools.valueFactory.createString("/..")).concat(tools.valueFactory.createString("/symfony/event-dispatcher")))]))])}}, properties: {}, methods: {"getInitializer": {isStatic: true, method: function ($loader) {var scope = this;scope.getVariable("loader").setValue($loader.getValue());return tools.valueFactory.createBarewordString("\\Closure").callStaticMethod(tools.valueFactory.createBarewordString("bind"), [tools.createClosure((function (parentScope) { return function () {var scope = this;scope.getVariable("loader").setValue(parentScope.getVariable("loader").getValue());tools.implyObject(scope.getVariable("loader")).getInstancePropertyByName(tools.valueFactory.createBarewordString("prefixLengthsPsr4")).setValue(tools.valueFactory.createBarewordString("ComposerStaticInit420ecf0d2ea534165cf69ed795619dd8").getStaticPropertyByName(tools.valueFactory.createBarewordString("prefixLengthsPsr4"), namespaceScope).getValue());tools.implyObject(scope.getVariable("loader")).getInstancePropertyByName(tools.valueFactory.createBarewordString("prefixDirsPsr4")).setValue(tools.valueFactory.createBarewordString("ComposerStaticInit420ecf0d2ea534165cf69ed795619dd8").getStaticPropertyByName(tools.valueFactory.createBarewordString("prefixDirsPsr4"), namespaceScope).getValue());}; }(scope)), scope), tools.valueFactory.createNull(), tools.valueFactory.createBarewordString("ClassLoader").getConstantByName("class", namespaceScope)], namespaceScope);}}}, constants: {}}, namespaceScope);}());}(namespace))) { return namespaceResult; }return tools.valueFactory.createNull();}));
},{"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api":147,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime":153,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php":173}],181:[function(require,module,exports){
require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php");
module.exports = require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api").load("vendor/symfony/event-dispatcher/ContainerAwareEventDispatcher.php", require('/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime').compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.createNamespaceScope(namespace), namespaceResult, scope = tools.topLevelScope, currentClass = null;if (namespaceResult = (function (globalNamespace) {var namespace = globalNamespace.getDescendant("Symfony\\Component\\EventDispatcher"), namespaceScope = tools.createNamespaceScope(namespace);(function () {var currentClass = namespace.defineClass("ContainerAwareEventDispatcher", {superClass: namespaceScope.getClass("EventDispatcher"), interfaces: [], staticProperties: {}, properties: {"container": null, "listenerIds": tools.valueFactory.createArray([]), "listeners": tools.valueFactory.createArray([])}, methods: {"__construct": {isStatic: false, method: function ($container) {var scope = this;scope.getVariable("container").setValue($container.getValue());tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("container")).setValue(scope.getVariable("container").getValue());}}, "addListenerService": {isStatic: false, method: function ($eventName, $callback, $priority) {var scope = this;scope.getVariable("eventName").setValue($eventName.getValue());scope.getVariable("callback").setValue($callback.getValue());scope.getVariable("priority").setValue($priority ? $priority.getValue() : tools.valueFactory.createInteger(0));if (tools.valueFactory.createBoolean((tools.valueFactory.createBarewordString("is_array").call([scope.getVariable("callback")], namespaceScope) || tools.valueFactory.createNull()).logicalNot().coerceToBoolean().getNative() || (tools.valueFactory.createInteger(2).isNotIdenticalTo((tools.valueFactory.createBarewordString("count").call([scope.getVariable("callback")], namespaceScope) || tools.valueFactory.createNull())).coerceToBoolean().getNative())).coerceToBoolean().getNative()) {throw tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("\\InvalidArgumentException"), [tools.valueFactory.createString("Expected an array(\"service\", \"method\") argument")]);}tools.implyArray(tools.implyArray(tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("listenerIds"))).getElementByKey(scope.getVariable("eventName").getValue())).getPushElement().setValue(tools.valueFactory.createArray([scope.getVariable("callback").getValue().getElementByKey(tools.valueFactory.createInteger(0)).getValue(), scope.getVariable("callback").getValue().getElementByKey(tools.valueFactory.createInteger(1)).getValue(), scope.getVariable("priority").getValue()]));}}, "removeListener": {isStatic: false, method: function ($eventName, $listener) {var scope = this;scope.getVariable("eventName").setValue($eventName.getValue());scope.getVariable("listener").setValue($listener.getValue());scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("lazyLoad").getNative(), [scope.getVariable("eventName").getValue()]);if ((function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean(scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listenerIds")).getValue().getElementByKey(scope.getVariable("eventName").getValue()).isSet());scope.unsuppressOwnErrors(); return result;}(scope)).coerceToBoolean().getNative()) {var array_1 = scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listenerIds")).getValue().getElementByKey(scope.getVariable("eventName").getValue()).getValue().reset();var length_1 = array_1.getLength();var pointer_1 = 0;block_1: while (pointer_1 < length_1) {scope.getVariable("i").setValue(array_1.getKeyByIndex(pointer_1));tools.createList([scope.getVariable("serviceId"),scope.getVariable("method"),scope.getVariable("priority")]).setValue(array_1.getElementByIndex(pointer_1).getValue());pointer_1++;scope.getVariable("key").setValue(scope.getVariable("serviceId").getValue().concat(tools.valueFactory.createString(".")).concat(scope.getVariable("method").getValue()));if (tools.valueFactory.createBoolean((function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean(scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listeners")).getValue().getElementByKey(scope.getVariable("eventName").getValue()).getValue().getElementByKey(scope.getVariable("key").getValue()).isSet());scope.unsuppressOwnErrors(); return result;}(scope)).coerceToBoolean().getNative() && (scope.getVariable("listener").getValue().isIdenticalTo(tools.valueFactory.createArray([scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listeners")).getValue().getElementByKey(scope.getVariable("eventName").getValue()).getValue().getElementByKey(scope.getVariable("key").getValue()).getValue(), scope.getVariable("method").getValue()])).coerceToBoolean().getNative())).coerceToBoolean().getNative()) {scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listeners")).getValue().getElementByKey(scope.getVariable("eventName").getValue()).getValue().getElementByKey(scope.getVariable("key").getValue()).unset();if ((tools.valueFactory.createBarewordString("empty").call([scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listeners")).getValue().getElementByKey(scope.getVariable("eventName").getValue())], namespaceScope) || tools.valueFactory.createNull()).coerceToBoolean().getNative()) {scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listeners")).getValue().getElementByKey(scope.getVariable("eventName").getValue()).unset();}scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listenerIds")).getValue().getElementByKey(scope.getVariable("eventName").getValue()).getValue().getElementByKey(scope.getVariable("i").getValue()).unset();if ((tools.valueFactory.createBarewordString("empty").call([scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listenerIds")).getValue().getElementByKey(scope.getVariable("eventName").getValue())], namespaceScope) || tools.valueFactory.createNull()).coerceToBoolean().getNative()) {scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listenerIds")).getValue().getElementByKey(scope.getVariable("eventName").getValue()).unset();}}}}tools.valueFactory.createBarewordString("parent").callStaticMethod(tools.valueFactory.createBarewordString("removeListener"), [scope.getVariable("eventName").getValue(), scope.getVariable("listener").getValue()], namespaceScope);}}, "hasListeners": {isStatic: false, method: function ($eventName) {var scope = this;scope.getVariable("eventName").setValue($eventName ? $eventName.getValue() : tools.valueFactory.createNull());if (tools.valueFactory.createNull().isIdenticalTo(scope.getVariable("eventName").getValue()).coerceToBoolean().getNative()) {return tools.valueFactory.createBoolean((tools.valueFactory.createBarewordString("count").call([scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listenerIds"))], namespaceScope) || tools.valueFactory.createNull()).coerceToBoolean().coerceToBoolean().getNative() || ((tools.valueFactory.createBarewordString("count").call([scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listeners"))], namespaceScope) || tools.valueFactory.createNull()).coerceToBoolean().coerceToBoolean().getNative()));}if ((function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean(scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listenerIds")).getValue().getElementByKey(scope.getVariable("eventName").getValue()).isSet());scope.unsuppressOwnErrors(); return result;}(scope)).coerceToBoolean().getNative()) {return tools.valueFactory.createBoolean(true);}return tools.valueFactory.createBarewordString("parent").callStaticMethod(tools.valueFactory.createBarewordString("hasListeners"), [scope.getVariable("eventName").getValue()], namespaceScope);}}, "getListeners": {isStatic: false, method: function ($eventName) {var scope = this;scope.getVariable("eventName").setValue($eventName ? $eventName.getValue() : tools.valueFactory.createNull());if (tools.valueFactory.createNull().isIdenticalTo(scope.getVariable("eventName").getValue()).coerceToBoolean().getNative()) {var array_1 = scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listenerIds")).getValue().reset();var length_1 = array_1.getLength();var pointer_1 = 0;block_1: while (pointer_1 < length_1) {scope.getVariable("serviceEventName").setValue(array_1.getKeyByIndex(pointer_1));scope.getVariable("args").setValue(array_1.getElementByIndex(pointer_1).getValue());pointer_1++;scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("lazyLoad").getNative(), [scope.getVariable("serviceEventName").getValue()]);}} else {scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("lazyLoad").getNative(), [scope.getVariable("eventName").getValue()]);}return tools.valueFactory.createBarewordString("parent").callStaticMethod(tools.valueFactory.createBarewordString("getListeners"), [scope.getVariable("eventName").getValue()], namespaceScope);}}, "getListenerPriority": {isStatic: false, method: function ($eventName, $listener) {var scope = this;scope.getVariable("eventName").setValue($eventName.getValue());scope.getVariable("listener").setValue($listener.getValue());scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("lazyLoad").getNative(), [scope.getVariable("eventName").getValue()]);return tools.valueFactory.createBarewordString("parent").callStaticMethod(tools.valueFactory.createBarewordString("getListenerPriority"), [scope.getVariable("eventName").getValue(), scope.getVariable("listener").getValue()], namespaceScope);}}, "addSubscriberService": {isStatic: false, method: function ($serviceId, $class) {var scope = this;scope.getVariable("serviceId").setValue($serviceId.getValue());scope.getVariable("class").setValue($class.getValue());var array_1 = scope.getVariable("class").getValue().callStaticMethod(tools.valueFactory.createBarewordString("getSubscribedEvents"), [], namespaceScope).reset();var length_1 = array_1.getLength();var pointer_1 = 0;block_1: while (pointer_1 < length_1) {scope.getVariable("eventName").setValue(array_1.getKeyByIndex(pointer_1));scope.getVariable("params").setValue(array_1.getElementByIndex(pointer_1).getValue());pointer_1++;if ((tools.valueFactory.createBarewordString("is_string").call([scope.getVariable("params")], namespaceScope) || tools.valueFactory.createNull()).coerceToBoolean().getNative()) {tools.implyArray(tools.implyArray(tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("listenerIds"))).getElementByKey(scope.getVariable("eventName").getValue())).getPushElement().setValue(tools.valueFactory.createArray([scope.getVariable("serviceId").getValue(), scope.getVariable("params").getValue(), tools.valueFactory.createInteger(0)]));} else {if ((tools.valueFactory.createBarewordString("is_string").call([scope.getVariable("params").getValue().getElementByKey(tools.valueFactory.createInteger(0))], namespaceScope) || tools.valueFactory.createNull()).coerceToBoolean().getNative()) {tools.implyArray(tools.implyArray(tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("listenerIds"))).getElementByKey(scope.getVariable("eventName").getValue())).getPushElement().setValue(tools.valueFactory.createArray([scope.getVariable("serviceId").getValue(), scope.getVariable("params").getValue().getElementByKey(tools.valueFactory.createInteger(0)).getValue(), ((function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean(scope.getVariable("params").getValue().getElementByKey(tools.valueFactory.createInteger(1)).isSet());scope.unsuppressOwnErrors(); return result;}(scope)).coerceToBoolean().getNative() ? scope.getVariable("params").getValue().getElementByKey(tools.valueFactory.createInteger(1)).getValue() : tools.valueFactory.createInteger(0))]));} else {var array_2 = scope.getVariable("params").getValue().reset();var length_2 = array_2.getLength();var pointer_2 = 0;block_2: while (pointer_2 < length_2) {scope.getVariable("listener").setValue(array_2.getElementByIndex(pointer_2).getValue());pointer_2++;tools.implyArray(tools.implyArray(tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("listenerIds"))).getElementByKey(scope.getVariable("eventName").getValue())).getPushElement().setValue(tools.valueFactory.createArray([scope.getVariable("serviceId").getValue(), scope.getVariable("listener").getValue().getElementByKey(tools.valueFactory.createInteger(0)).getValue(), ((function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean(scope.getVariable("listener").getValue().getElementByKey(tools.valueFactory.createInteger(1)).isSet());scope.unsuppressOwnErrors(); return result;}(scope)).coerceToBoolean().getNative() ? scope.getVariable("listener").getValue().getElementByKey(tools.valueFactory.createInteger(1)).getValue() : tools.valueFactory.createInteger(0))]));}}}}}}, "getContainer": {isStatic: false, method: function () {var scope = this;return scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("container")).getValue();}}, "lazyLoad": {isStatic: false, method: function ($eventName) {var scope = this;scope.getVariable("eventName").setValue($eventName.getValue());if ((function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean(scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listenerIds")).getValue().getElementByKey(scope.getVariable("eventName").getValue()).isSet());scope.unsuppressOwnErrors(); return result;}(scope)).coerceToBoolean().getNative()) {var array_1 = scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listenerIds")).getValue().getElementByKey(scope.getVariable("eventName").getValue()).getValue().reset();var length_1 = array_1.getLength();var pointer_1 = 0;block_1: while (pointer_1 < length_1) {tools.createList([scope.getVariable("serviceId"),scope.getVariable("method"),scope.getVariable("priority")]).setValue(array_1.getElementByIndex(pointer_1).getValue());pointer_1++;scope.getVariable("listener").setValue(scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("container")).getValue().callMethod(tools.valueFactory.createBarewordString("get").getNative(), [scope.getVariable("serviceId").getValue()]));scope.getVariable("key").setValue(scope.getVariable("serviceId").getValue().concat(tools.valueFactory.createString(".")).concat(scope.getVariable("method").getValue()));if ((function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean(scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listeners")).getValue().getElementByKey(scope.getVariable("eventName").getValue()).getValue().getElementByKey(scope.getVariable("key").getValue()).isSet());scope.unsuppressOwnErrors(); return result;}(scope)).logicalNot().coerceToBoolean().getNative()) {scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [scope.getVariable("eventName").getValue(), tools.valueFactory.createArray([scope.getVariable("listener").getValue(), scope.getVariable("method").getValue()]), scope.getVariable("priority").getValue()]);} else {if (scope.getVariable("listener").getValue().isNotIdenticalTo(scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listeners")).getValue().getElementByKey(scope.getVariable("eventName").getValue()).getValue().getElementByKey(scope.getVariable("key").getValue()).getValue()).coerceToBoolean().getNative()) {tools.valueFactory.createBarewordString("parent").callStaticMethod(tools.valueFactory.createBarewordString("removeListener"), [scope.getVariable("eventName").getValue(), tools.valueFactory.createArray([scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listeners")).getValue().getElementByKey(scope.getVariable("eventName").getValue()).getValue().getElementByKey(scope.getVariable("key").getValue()).getValue(), scope.getVariable("method").getValue()])], namespaceScope);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [scope.getVariable("eventName").getValue(), tools.valueFactory.createArray([scope.getVariable("listener").getValue(), scope.getVariable("method").getValue()]), scope.getVariable("priority").getValue()]);}}tools.implyArray(tools.implyArray(tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("listeners"))).getElementByKey(scope.getVariable("eventName").getValue())).getElementByKey(scope.getVariable("key").getValue()).setValue(scope.getVariable("listener").getValue());}}}}}, constants: {}}, namespaceScope);}());namespaceScope.use("Symfony\\Component\\DependencyInjection\\ContainerInterface");}(namespace))) { return namespaceResult; }return tools.valueFactory.createNull();}));
},{"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api":147,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime":153,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php":173}],182:[function(require,module,exports){
require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php");
module.exports = require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api").load("vendor/symfony/event-dispatcher/Debug/TraceableEventDispatcher.php", require('/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime').compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.createNamespaceScope(namespace), namespaceResult, scope = tools.topLevelScope, currentClass = null;if (namespaceResult = (function (globalNamespace) {var namespace = globalNamespace.getDescendant("Symfony\\Component\\EventDispatcher\\Debug"), namespaceScope = tools.createNamespaceScope(namespace);(function () {var currentClass = namespace.defineClass("TraceableEventDispatcher", {superClass: null, interfaces: ["TraceableEventDispatcherInterface"], staticProperties: {}, properties: {"logger": null, "stopwatch": null, "called": null, "dispatcher": null, "wrappedListeners": null}, methods: {"__construct": {isStatic: false, method: function ($dispatcher, $stopwatch, $logger) {var scope = this;scope.getVariable("dispatcher").setValue($dispatcher.getValue());scope.getVariable("stopwatch").setValue($stopwatch.getValue());scope.getVariable("logger").setValue($logger ? $logger.getValue() : tools.valueFactory.createNull());tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).setValue(scope.getVariable("dispatcher").getValue());tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("stopwatch")).setValue(scope.getVariable("stopwatch").getValue());tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("logger")).setValue(scope.getVariable("logger").getValue());tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("called")).setValue(tools.valueFactory.createArray([]));tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("wrappedListeners")).setValue(tools.valueFactory.createArray([]));}}, "addListener": {isStatic: false, method: function ($eventName, $listener, $priority) {var scope = this;scope.getVariable("eventName").setValue($eventName.getValue());scope.getVariable("listener").setValue($listener.getValue());scope.getVariable("priority").setValue($priority ? $priority.getValue() : tools.valueFactory.createInteger(0));scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [scope.getVariable("eventName").getValue(), scope.getVariable("listener").getValue(), scope.getVariable("priority").getValue()]);}}, "addSubscriber": {isStatic: false, method: function ($subscriber) {var scope = this;scope.getVariable("subscriber").setValue($subscriber.getValue());scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addSubscriber").getNative(), [scope.getVariable("subscriber").getValue()]);}}, "removeListener": {isStatic: false, method: function ($eventName, $listener) {var scope = this;scope.getVariable("eventName").setValue($eventName.getValue());scope.getVariable("listener").setValue($listener.getValue());if ((function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean(scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("wrappedListeners")).getValue().getElementByKey(scope.getVariable("eventName").getValue()).isSet());scope.unsuppressOwnErrors(); return result;}(scope)).coerceToBoolean().getNative()) {var array_1 = scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("wrappedListeners")).getValue().getElementByKey(scope.getVariable("eventName").getValue()).getValue().reset();var length_1 = array_1.getLength();var pointer_1 = 0;block_1: while (pointer_1 < length_1) {scope.getVariable("index").setValue(array_1.getKeyByIndex(pointer_1));scope.getVariable("wrappedListener").setValue(array_1.getElementByIndex(pointer_1).getValue());pointer_1++;if (scope.getVariable("wrappedListener").getValue().callMethod(tools.valueFactory.createBarewordString("getWrappedListener").getNative(), []).isIdenticalTo(scope.getVariable("listener").getValue()).coerceToBoolean().getNative()) {scope.getVariable("listener").setValue(scope.getVariable("wrappedListener").getValue());scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("wrappedListeners")).getValue().getElementByKey(scope.getVariable("eventName").getValue()).getValue().getElementByKey(scope.getVariable("index").getValue()).unset();break block_1;}}}return scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("removeListener").getNative(), [scope.getVariable("eventName").getValue(), scope.getVariable("listener").getValue()]);}}, "removeSubscriber": {isStatic: false, method: function ($subscriber) {var scope = this;scope.getVariable("subscriber").setValue($subscriber.getValue());return scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("removeSubscriber").getNative(), [scope.getVariable("subscriber").getValue()]);}}, "getListeners": {isStatic: false, method: function ($eventName) {var scope = this;scope.getVariable("eventName").setValue($eventName ? $eventName.getValue() : tools.valueFactory.createNull());return scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("getListeners").getNative(), [scope.getVariable("eventName").getValue()]);}}, "getListenerPriority": {isStatic: false, method: function ($eventName, $listener) {var scope = this;scope.getVariable("eventName").setValue($eventName.getValue());scope.getVariable("listener").setValue($listener.getValue());return scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("getListenerPriority").getNative(), [scope.getVariable("eventName").getValue(), scope.getVariable("listener").getValue()]);}}, "hasListeners": {isStatic: false, method: function ($eventName) {var scope = this;scope.getVariable("eventName").setValue($eventName ? $eventName.getValue() : tools.valueFactory.createNull());return scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("hasListeners").getNative(), [scope.getVariable("eventName").getValue()]);}}, "dispatch": {isStatic: false, method: function ($eventName, $event) {var scope = this;scope.getVariable("eventName").setValue($eventName.getValue());scope.getVariable("event").setValue($event ? $event.getValue() : tools.valueFactory.createNull());if (tools.valueFactory.createNull().isIdenticalTo(scope.getVariable("event").getValue()).coerceToBoolean().getNative()) {scope.getVariable("event").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("Event"), []));}if (tools.valueFactory.createBoolean(tools.valueFactory.createNull().isNotIdenticalTo(scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("logger")).getValue()).coerceToBoolean().getNative() && (scope.getVariable("event").getValue().callMethod(tools.valueFactory.createBarewordString("isPropagationStopped").getNative(), []).coerceToBoolean().getNative())).coerceToBoolean().getNative()) {scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("logger")).getValue().callMethod(tools.valueFactory.createBarewordString("debug").getNative(), [(tools.valueFactory.createBarewordString("sprintf").call([tools.valueFactory.createString("The \"%s\" event is already stopped. No listeners have been called."), scope.getVariable("eventName")], namespaceScope) || tools.valueFactory.createNull())]);}scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("preProcess").getNative(), [scope.getVariable("eventName").getValue()]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("preDispatch").getNative(), [scope.getVariable("eventName").getValue(), scope.getVariable("event").getValue()]);scope.getVariable("e").setValue(scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("stopwatch")).getValue().callMethod(tools.valueFactory.createBarewordString("start").getNative(), [scope.getVariable("eventName").getValue(), tools.valueFactory.createString("section")]));scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("dispatch").getNative(), [scope.getVariable("eventName").getValue(), scope.getVariable("event").getValue()]);if (scope.getVariable("e").getValue().callMethod(tools.valueFactory.createBarewordString("isStarted").getNative(), []).coerceToBoolean().getNative()) {scope.getVariable("e").getValue().callMethod(tools.valueFactory.createBarewordString("stop").getNative(), []);}scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("postDispatch").getNative(), [scope.getVariable("eventName").getValue(), scope.getVariable("event").getValue()]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("postProcess").getNative(), [scope.getVariable("eventName").getValue()]);return scope.getVariable("event").getValue();}}, "getCalledListeners": {isStatic: false, method: function () {var scope = this;scope.getVariable("called").setValue(tools.valueFactory.createArray([]));var array_1 = scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("called")).getValue().reset();var length_1 = array_1.getLength();var pointer_1 = 0;block_1: while (pointer_1 < length_1) {scope.getVariable("eventName").setValue(array_1.getKeyByIndex(pointer_1));scope.getVariable("listeners").setValue(array_1.getElementByIndex(pointer_1).getValue());pointer_1++;var array_2 = scope.getVariable("listeners").getValue().reset();var length_2 = array_2.getLength();var pointer_2 = 0;block_2: while (pointer_2 < length_2) {scope.getVariable("listener").setValue(array_2.getElementByIndex(pointer_2).getValue());pointer_2++;scope.getVariable("info").setValue(scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("getListenerInfo").getNative(), [scope.getVariable("listener").getValue().callMethod(tools.valueFactory.createBarewordString("getWrappedListener").getNative(), []), scope.getVariable("eventName").getValue()]));tools.implyArray(scope.getVariable("called")).getElementByKey(scope.getVariable("eventName").getValue().concat(tools.valueFactory.createString(".")).concat(scope.getVariable("info").getValue().getElementByKey(tools.valueFactory.createString("pretty")).getValue())).setValue(scope.getVariable("info").getValue());}}return scope.getVariable("called").getValue();}}, "getNotCalledListeners": {isStatic: false, method: function () {var scope = this;try {scope.getVariable("allListeners").setValue(scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("getListeners").getNative(), []));} catch (e) {if (!tools.valueFactory.isValue(e)) {throw e;}if (tools.valueFactory.createBarewordString("\\Exception").isTheClassOfObject(e, namespaceScope).getNative()) {scope.getVariable("e").setValue(e);if (tools.valueFactory.createNull().isNotIdenticalTo(scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("logger")).getValue()).coerceToBoolean().getNative()) {scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("logger")).getValue().callMethod(tools.valueFactory.createBarewordString("info").getNative(), [tools.valueFactory.createString("An exception was thrown while getting the uncalled listeners."), tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("exception"), scope.getVariable("e").getValue())])]);}return tools.valueFactory.createArray([]);} else { throw e; }}scope.getVariable("notCalled").setValue(tools.valueFactory.createArray([]));var array_1 = scope.getVariable("allListeners").getValue().reset();var length_1 = array_1.getLength();var pointer_1 = 0;block_1: while (pointer_1 < length_1) {scope.getVariable("eventName").setValue(array_1.getKeyByIndex(pointer_1));scope.getVariable("listeners").setValue(array_1.getElementByIndex(pointer_1).getValue());pointer_1++;var array_2 = scope.getVariable("listeners").getValue().reset();var length_2 = array_2.getLength();var pointer_2 = 0;block_2: while (pointer_2 < length_2) {scope.getVariable("listener").setValue(array_2.getElementByIndex(pointer_2).getValue());pointer_2++;scope.getVariable("called").setValue(tools.valueFactory.createBoolean(false));if ((function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean(scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("called")).getValue().getElementByKey(scope.getVariable("eventName").getValue()).isSet());scope.unsuppressOwnErrors(); return result;}(scope)).coerceToBoolean().getNative()) {var array_3 = scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("called")).getValue().getElementByKey(scope.getVariable("eventName").getValue()).getValue().reset();var length_3 = array_3.getLength();var pointer_3 = 0;block_3: while (pointer_3 < length_3) {scope.getVariable("l").setValue(array_3.getElementByIndex(pointer_3).getValue());pointer_3++;if (scope.getVariable("l").getValue().callMethod(tools.valueFactory.createBarewordString("getWrappedListener").getNative(), []).isIdenticalTo(scope.getVariable("listener").getValue()).coerceToBoolean().getNative()) {scope.getVariable("called").setValue(tools.valueFactory.createBoolean(true));break block_3;}}}if (scope.getVariable("called").getValue().logicalNot().coerceToBoolean().getNative()) {scope.getVariable("info").setValue(scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("getListenerInfo").getNative(), [scope.getVariable("listener").getValue(), scope.getVariable("eventName").getValue()]));tools.implyArray(scope.getVariable("notCalled")).getElementByKey(scope.getVariable("eventName").getValue().concat(tools.valueFactory.createString(".")).concat(scope.getVariable("info").getValue().getElementByKey(tools.valueFactory.createString("pretty")).getValue())).setValue(scope.getVariable("info").getValue());}}}(tools.valueFactory.createBarewordString("uasort").call([scope.getVariable("notCalled"), tools.valueFactory.createArray([scope.getVariable("this"), tools.valueFactory.createString("sortListenersByPriority")])], namespaceScope) || tools.valueFactory.createNull());return scope.getVariable("notCalled").getValue();}}, "__call": {isStatic: false, method: function ($method, $arguments) {var scope = this;scope.getVariable("method").setValue($method.getValue());scope.getVariable("arguments").setValue($arguments.getValue());return (tools.valueFactory.createBarewordString("call_user_func_array").call([tools.valueFactory.createArray([scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")), scope.getVariable("method")]), scope.getVariable("arguments")], namespaceScope) || tools.valueFactory.createNull());}}, "preDispatch": {isStatic: false, method: function ($eventName, $event) {var scope = this;scope.getVariable("eventName").setValue($eventName.getValue());scope.getVariable("event").setValue($event.getValue());}}, "postDispatch": {isStatic: false, method: function ($eventName, $event) {var scope = this;scope.getVariable("eventName").setValue($eventName.getValue());scope.getVariable("event").setValue($event.getValue());}}, "preProcess": {isStatic: false, method: function ($eventName) {var scope = this;scope.getVariable("eventName").setValue($eventName.getValue());var array_1 = scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("getListeners").getNative(), [scope.getVariable("eventName").getValue()]).reset();var length_1 = array_1.getLength();var pointer_1 = 0;block_1: while (pointer_1 < length_1) {scope.getVariable("listener").setValue(array_1.getElementByIndex(pointer_1).getValue());pointer_1++;scope.getVariable("info").setValue(scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("getListenerInfo").getNative(), [scope.getVariable("listener").getValue(), scope.getVariable("eventName").getValue()]));scope.getVariable("name").setValue(((function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean(scope.getVariable("info").getValue().getElementByKey(tools.valueFactory.createString("class")).isSet());scope.unsuppressOwnErrors(); return result;}(scope)).coerceToBoolean().getNative() ? scope.getVariable("info").getValue().getElementByKey(tools.valueFactory.createString("class")).getValue() : scope.getVariable("info").getValue().getElementByKey(tools.valueFactory.createString("type")).getValue()));scope.getVariable("wrappedListener").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("WrappedListener"), [scope.getVariable("listener").getValue(), scope.getVariable("name").getValue(), scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("stopwatch")).getValue(), scope.getVariable("this").getValue()]));tools.implyArray(tools.implyArray(tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("wrappedListeners"))).getElementByKey(scope.getVariable("eventName").getValue())).getPushElement().setValue(scope.getVariable("wrappedListener").getValue());scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("removeListener").getNative(), [scope.getVariable("eventName").getValue(), scope.getVariable("listener").getValue()]);scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [scope.getVariable("eventName").getValue(), scope.getVariable("wrappedListener").getValue(), scope.getVariable("info").getValue().getElementByKey(tools.valueFactory.createString("priority")).getValue()]);}}}, "postProcess": {isStatic: false, method: function ($eventName) {var scope = this;scope.getVariable("eventName").setValue($eventName.getValue());scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("wrappedListeners")).getValue().getElementByKey(scope.getVariable("eventName").getValue()).unset();scope.getVariable("skipped").setValue(tools.valueFactory.createBoolean(false));var array_1 = scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("getListeners").getNative(), [scope.getVariable("eventName").getValue()]).reset();var length_1 = array_1.getLength();var pointer_1 = 0;block_1: while (pointer_1 < length_1) {scope.getVariable("listener").setValue(array_1.getElementByIndex(pointer_1).getValue());pointer_1++;if (scope.getVariable("listener").getValue().isAnInstanceOf(tools.valueFactory.createBarewordString("WrappedListener"), namespaceScope).logicalNot().coerceToBoolean().getNative()) {continue block_1;}scope.getVariable("priority").setValue(scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("getListenerPriority").getNative(), [scope.getVariable("eventName").getValue(), scope.getVariable("listener").getValue()]));scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("removeListener").getNative(), [scope.getVariable("eventName").getValue(), scope.getVariable("listener").getValue()]);scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [scope.getVariable("eventName").getValue(), scope.getVariable("listener").getValue().callMethod(tools.valueFactory.createBarewordString("getWrappedListener").getNative(), []), scope.getVariable("priority").getValue()]);scope.getVariable("info").setValue(scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("getListenerInfo").getNative(), [scope.getVariable("listener").getValue().callMethod(tools.valueFactory.createBarewordString("getWrappedListener").getNative(), []), scope.getVariable("eventName").getValue()]));if (scope.getVariable("listener").getValue().callMethod(tools.valueFactory.createBarewordString("wasCalled").getNative(), []).coerceToBoolean().getNative()) {if (tools.valueFactory.createNull().isNotIdenticalTo(scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("logger")).getValue()).coerceToBoolean().getNative()) {scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("logger")).getValue().callMethod(tools.valueFactory.createBarewordString("debug").getNative(), [tools.valueFactory.createString("Notified event \"{event}\" to listener \"{listener}\"."), tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("event"), scope.getVariable("eventName").getValue()), tools.createKeyValuePair(tools.valueFactory.createString("listener"), scope.getVariable("info").getValue().getElementByKey(tools.valueFactory.createString("pretty")).getValue())])]);}if ((function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean(scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("called")).getValue().getElementByKey(scope.getVariable("eventName").getValue()).isSet());scope.unsuppressOwnErrors(); return result;}(scope)).logicalNot().coerceToBoolean().getNative()) {tools.implyArray(tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("called"))).getElementByKey(scope.getVariable("eventName").getValue()).setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("\\SplObjectStorage"), []));}scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("called")).getValue().getElementByKey(scope.getVariable("eventName").getValue()).getValue().callMethod(tools.valueFactory.createBarewordString("attach").getNative(), [scope.getVariable("listener").getValue()]);}if (tools.valueFactory.createBoolean(tools.valueFactory.createNull().isNotIdenticalTo(scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("logger")).getValue()).coerceToBoolean().getNative() && (scope.getVariable("skipped").getValue().coerceToBoolean().getNative())).coerceToBoolean().getNative()) {scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("logger")).getValue().callMethod(tools.valueFactory.createBarewordString("debug").getNative(), [tools.valueFactory.createString("Listener \"{listener}\" was not called for event \"{event}\"."), tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("listener"), scope.getVariable("info").getValue().getElementByKey(tools.valueFactory.createString("pretty")).getValue()), tools.createKeyValuePair(tools.valueFactory.createString("event"), scope.getVariable("eventName").getValue())])]);}if (scope.getVariable("listener").getValue().callMethod(tools.valueFactory.createBarewordString("stoppedPropagation").getNative(), []).coerceToBoolean().getNative()) {if (tools.valueFactory.createNull().isNotIdenticalTo(scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("logger")).getValue()).coerceToBoolean().getNative()) {scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("logger")).getValue().callMethod(tools.valueFactory.createBarewordString("debug").getNative(), [tools.valueFactory.createString("Listener \"{listener}\" stopped propagation of the event \"{event}\"."), tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("listener"), scope.getVariable("info").getValue().getElementByKey(tools.valueFactory.createString("pretty")).getValue()), tools.createKeyValuePair(tools.valueFactory.createString("event"), scope.getVariable("eventName").getValue())])]);}scope.getVariable("skipped").setValue(tools.valueFactory.createBoolean(true));}}}}, "getListenerInfo": {isStatic: false, method: function ($listener, $eventName) {var scope = this;scope.getVariable("listener").setValue($listener.getValue());scope.getVariable("eventName").setValue($eventName.getValue());scope.getVariable("info").setValue(tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("event"), scope.getVariable("eventName").getValue()), tools.createKeyValuePair(tools.valueFactory.createString("priority"), scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("getListenerPriority").getNative(), [scope.getVariable("eventName").getValue(), scope.getVariable("listener").getValue()]))]));if (scope.getVariable("listener").getValue().isAnInstanceOf(tools.valueFactory.createBarewordString("\\Closure"), namespaceScope).coerceToBoolean().getNative()) {scope.getVariable("info").incrementBy(tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("type"), tools.valueFactory.createString("Closure")), tools.createKeyValuePair(tools.valueFactory.createString("pretty"), tools.valueFactory.createString("closure"))]));} else {if ((tools.valueFactory.createBarewordString("is_string").call([scope.getVariable("listener")], namespaceScope) || tools.valueFactory.createNull()).coerceToBoolean().getNative()) {try {scope.getVariable("r").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("\\ReflectionFunction"), [scope.getVariable("listener").getValue()]));scope.getVariable("file").setValue(scope.getVariable("r").getValue().callMethod(tools.valueFactory.createBarewordString("getFileName").getNative(), []));scope.getVariable("line").setValue(scope.getVariable("r").getValue().callMethod(tools.valueFactory.createBarewordString("getStartLine").getNative(), []));} catch (e) {if (!tools.valueFactory.isValue(e)) {throw e;}if (tools.valueFactory.createBarewordString("\\ReflectionException").isTheClassOfObject(e, namespaceScope).getNative()) {scope.getVariable("e").setValue(e);scope.getVariable("file").setValue(tools.valueFactory.createNull());scope.getVariable("line").setValue(tools.valueFactory.createNull());} else { throw e; }}scope.getVariable("info").incrementBy(tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("type"), tools.valueFactory.createString("Function")), tools.createKeyValuePair(tools.valueFactory.createString("function"), scope.getVariable("listener").getValue()), tools.createKeyValuePair(tools.valueFactory.createString("file"), scope.getVariable("file").getValue()), tools.createKeyValuePair(tools.valueFactory.createString("line"), scope.getVariable("line").getValue()), tools.createKeyValuePair(tools.valueFactory.createString("pretty"), scope.getVariable("listener").getValue())]));} else {if (tools.valueFactory.createBoolean((tools.valueFactory.createBarewordString("is_array").call([scope.getVariable("listener")], namespaceScope) || tools.valueFactory.createNull()).coerceToBoolean().getNative() || (tools.valueFactory.createBoolean((tools.valueFactory.createBarewordString("is_object").call([scope.getVariable("listener")], namespaceScope) || tools.valueFactory.createNull()).coerceToBoolean().getNative() && ((tools.valueFactory.createBarewordString("is_callable").call([scope.getVariable("listener")], namespaceScope) || tools.valueFactory.createNull()).coerceToBoolean().getNative())).coerceToBoolean().getNative())).coerceToBoolean().getNative()) {if ((tools.valueFactory.createBarewordString("is_array").call([scope.getVariable("listener")], namespaceScope) || tools.valueFactory.createNull()).logicalNot().coerceToBoolean().getNative()) {scope.getVariable("listener").setValue(tools.valueFactory.createArray([scope.getVariable("listener").getValue(), tools.valueFactory.createString("__invoke")]));}scope.getVariable("class").setValue(((tools.valueFactory.createBarewordString("is_object").call([scope.getVariable("listener").getValue().getElementByKey(tools.valueFactory.createInteger(0))], namespaceScope) || tools.valueFactory.createNull()).coerceToBoolean().getNative() ? (tools.valueFactory.createBarewordString("get_class").call([scope.getVariable("listener").getValue().getElementByKey(tools.valueFactory.createInteger(0))], namespaceScope) || tools.valueFactory.createNull()) : scope.getVariable("listener").getValue().getElementByKey(tools.valueFactory.createInteger(0)).getValue()));try {scope.getVariable("r").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("\\ReflectionMethod"), [scope.getVariable("class").getValue(), scope.getVariable("listener").getValue().getElementByKey(tools.valueFactory.createInteger(1)).getValue()]));scope.getVariable("file").setValue(scope.getVariable("r").getValue().callMethod(tools.valueFactory.createBarewordString("getFileName").getNative(), []));scope.getVariable("line").setValue(scope.getVariable("r").getValue().callMethod(tools.valueFactory.createBarewordString("getStartLine").getNative(), []));} catch (e) {if (!tools.valueFactory.isValue(e)) {throw e;}if (tools.valueFactory.createBarewordString("\\ReflectionException").isTheClassOfObject(e, namespaceScope).getNative()) {scope.getVariable("e").setValue(e);scope.getVariable("file").setValue(tools.valueFactory.createNull());scope.getVariable("line").setValue(tools.valueFactory.createNull());} else { throw e; }}scope.getVariable("info").incrementBy(tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("type"), tools.valueFactory.createString("Method")), tools.createKeyValuePair(tools.valueFactory.createString("class"), scope.getVariable("class").getValue()), tools.createKeyValuePair(tools.valueFactory.createString("method"), scope.getVariable("listener").getValue().getElementByKey(tools.valueFactory.createInteger(1)).getValue()), tools.createKeyValuePair(tools.valueFactory.createString("file"), scope.getVariable("file").getValue()), tools.createKeyValuePair(tools.valueFactory.createString("line"), scope.getVariable("line").getValue()), tools.createKeyValuePair(tools.valueFactory.createString("pretty"), scope.getVariable("class").getValue().concat(tools.valueFactory.createString("::")).concat(scope.getVariable("listener").getValue().getElementByKey(tools.valueFactory.createInteger(1)).getValue()))]));}}}return scope.getVariable("info").getValue();}}, "sortListenersByPriority": {isStatic: false, method: function ($a, $b) {var scope = this;scope.getVariable("a").setValue($a.getValue());scope.getVariable("b").setValue($b.getValue());if (tools.valueFactory.createBoolean((tools.valueFactory.createBarewordString("is_int").call([scope.getVariable("a").getValue().getElementByKey(tools.valueFactory.createString("priority"))], namespaceScope) || tools.valueFactory.createNull()).coerceToBoolean().getNative() && ((tools.valueFactory.createBarewordString("is_int").call([scope.getVariable("b").getValue().getElementByKey(tools.valueFactory.createString("priority"))], namespaceScope) || tools.valueFactory.createNull()).logicalNot().coerceToBoolean().getNative())).coerceToBoolean().getNative()) {return tools.valueFactory.createInteger(1);}if (tools.valueFactory.createBoolean((tools.valueFactory.createBarewordString("is_int").call([scope.getVariable("a").getValue().getElementByKey(tools.valueFactory.createString("priority"))], namespaceScope) || tools.valueFactory.createNull()).logicalNot().coerceToBoolean().getNative() && ((tools.valueFactory.createBarewordString("is_int").call([scope.getVariable("b").getValue().getElementByKey(tools.valueFactory.createString("priority"))], namespaceScope) || tools.valueFactory.createNull()).coerceToBoolean().getNative())).coerceToBoolean().getNative()) {return tools.valueFactory.createInteger(1).toNegative();}if (scope.getVariable("a").getValue().getElementByKey(tools.valueFactory.createString("priority")).getValue().isIdenticalTo(scope.getVariable("b").getValue().getElementByKey(tools.valueFactory.createString("priority")).getValue()).coerceToBoolean().getNative()) {return tools.valueFactory.createInteger(0);}if (scope.getVariable("a").getValue().getElementByKey(tools.valueFactory.createString("priority")).getValue().isGreaterThan(scope.getVariable("b").getValue().getElementByKey(tools.valueFactory.createString("priority")).getValue()).coerceToBoolean().getNative()) {return tools.valueFactory.createInteger(1).toNegative();}return tools.valueFactory.createInteger(1);}}}, constants: {}}, namespaceScope);}());namespaceScope.use("Symfony\\Component\\EventDispatcher\\EventDispatcherInterface");namespaceScope.use("Symfony\\Component\\EventDispatcher\\EventSubscriberInterface");namespaceScope.use("Symfony\\Component\\EventDispatcher\\Event");namespaceScope.use("Symfony\\Component\\Stopwatch\\Stopwatch");namespaceScope.use("Psr\\Log\\LoggerInterface");}(namespace))) { return namespaceResult; }return tools.valueFactory.createNull();}));
},{"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api":147,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime":153,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php":173}],183:[function(require,module,exports){
require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php");
module.exports = require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api").load("vendor/symfony/event-dispatcher/Debug/TraceableEventDispatcherInterface.php", require('/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime').compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.createNamespaceScope(namespace), namespaceResult, scope = tools.topLevelScope, currentClass = null;if (namespaceResult = (function (globalNamespace) {var namespace = globalNamespace.getDescendant("Symfony\\Component\\EventDispatcher\\Debug"), namespaceScope = tools.createNamespaceScope(namespace);namespaceScope.use("Symfony\\Component\\EventDispatcher\\EventDispatcherInterface");(function () {var currentClass = namespace.defineClass("TraceableEventDispatcherInterface", {superClass: namespaceScope.getClass("EventDispatcherInterface"), staticProperties: {}, properties: {}, methods: {"getCalledListeners": {isStatic: false, abstract: true}, "getNotCalledListeners": {isStatic: false, abstract: true}}, constants: {}}, namespaceScope);}());}(namespace))) { return namespaceResult; }return tools.valueFactory.createNull();}));
},{"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api":147,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime":153,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php":173}],184:[function(require,module,exports){
require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php");
module.exports = require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api").load("vendor/symfony/event-dispatcher/Debug/WrappedListener.php", require('/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime').compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.createNamespaceScope(namespace), namespaceResult, scope = tools.topLevelScope, currentClass = null;if (namespaceResult = (function (globalNamespace) {var namespace = globalNamespace.getDescendant("Symfony\\Component\\EventDispatcher\\Debug"), namespaceScope = tools.createNamespaceScope(namespace);(function () {var currentClass = namespace.defineClass("WrappedListener", {superClass: null, interfaces: [], staticProperties: {}, properties: {"listener": null, "name": null, "called": null, "stoppedPropagation": null, "stopwatch": null, "dispatcher": null}, methods: {"__construct": {isStatic: false, method: function ($listener, $name, $stopwatch, $dispatcher) {var scope = this;scope.getVariable("listener").setValue($listener.getValue());scope.getVariable("name").setValue($name.getValue());scope.getVariable("stopwatch").setValue($stopwatch.getValue());scope.getVariable("dispatcher").setValue($dispatcher ? $dispatcher.getValue() : tools.valueFactory.createNull());tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("listener")).setValue(scope.getVariable("listener").getValue());tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("name")).setValue(scope.getVariable("name").getValue());tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("stopwatch")).setValue(scope.getVariable("stopwatch").getValue());tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).setValue(scope.getVariable("dispatcher").getValue());tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("called")).setValue(tools.valueFactory.createBoolean(false));tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("stoppedPropagation")).setValue(tools.valueFactory.createBoolean(false));}}, "getWrappedListener": {isStatic: false, method: function () {var scope = this;return scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listener")).getValue();}}, "wasCalled": {isStatic: false, method: function () {var scope = this;return scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("called")).getValue();}}, "stoppedPropagation": {isStatic: false, method: function () {var scope = this;return scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("stoppedPropagation")).getValue();}}, "__invoke": {isStatic: false, method: function ($event, $eventName, $dispatcher) {var scope = this;scope.getVariable("event").setValue($event.getValue());scope.getVariable("eventName").setValue($eventName.getValue());scope.getVariable("dispatcher").setValue($dispatcher.getValue());tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("called")).setValue(tools.valueFactory.createBoolean(true));scope.getVariable("e").setValue(scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("stopwatch")).getValue().callMethod(tools.valueFactory.createBarewordString("start").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("name")).getValue(), tools.valueFactory.createString("event_listener")]));(tools.valueFactory.createBarewordString("call_user_func").call([scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listener")), scope.getVariable("event"), scope.getVariable("eventName"), ((tools.ternaryCondition = scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher"))).coerceToBoolean().getNative() ? tools.ternaryCondition : scope.getVariable("dispatcher"))], namespaceScope) || tools.valueFactory.createNull());if (scope.getVariable("e").getValue().callMethod(tools.valueFactory.createBarewordString("isStarted").getNative(), []).coerceToBoolean().getNative()) {scope.getVariable("e").getValue().callMethod(tools.valueFactory.createBarewordString("stop").getNative(), []);}if (scope.getVariable("event").getValue().callMethod(tools.valueFactory.createBarewordString("isPropagationStopped").getNative(), []).coerceToBoolean().getNative()) {tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("stoppedPropagation")).setValue(tools.valueFactory.createBoolean(true));}}}}, constants: {}}, namespaceScope);}());namespaceScope.use("Symfony\\Component\\Stopwatch\\Stopwatch");namespaceScope.use("Symfony\\Component\\EventDispatcher\\Event");namespaceScope.use("Symfony\\Component\\EventDispatcher\\EventDispatcherInterface");}(namespace))) { return namespaceResult; }return tools.valueFactory.createNull();}));
},{"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api":147,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime":153,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php":173}],185:[function(require,module,exports){
require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php");
module.exports = require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api").load("vendor/symfony/event-dispatcher/DependencyInjection/RegisterListenersPass.php", require('/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime').compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.createNamespaceScope(namespace), namespaceResult, scope = tools.topLevelScope, currentClass = null;if (namespaceResult = (function (globalNamespace) {var namespace = globalNamespace.getDescendant("Symfony\\Component\\EventDispatcher\\DependencyInjection"), namespaceScope = tools.createNamespaceScope(namespace);(function () {var currentClass = namespace.defineClass("RegisterListenersPass", {superClass: null, interfaces: ["CompilerPassInterface"], staticProperties: {}, properties: {"dispatcherService": null, "listenerTag": null, "subscriberTag": null}, methods: {"__construct": {isStatic: false, method: function ($dispatcherService, $listenerTag, $subscriberTag) {var scope = this;scope.getVariable("dispatcherService").setValue($dispatcherService ? $dispatcherService.getValue() : tools.valueFactory.createString("event_dispatcher"));scope.getVariable("listenerTag").setValue($listenerTag ? $listenerTag.getValue() : tools.valueFactory.createString("kernel.event_listener"));scope.getVariable("subscriberTag").setValue($subscriberTag ? $subscriberTag.getValue() : tools.valueFactory.createString("kernel.event_subscriber"));tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcherService")).setValue(scope.getVariable("dispatcherService").getValue());tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("listenerTag")).setValue(scope.getVariable("listenerTag").getValue());tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("subscriberTag")).setValue(scope.getVariable("subscriberTag").getValue());}}, "process": {isStatic: false, method: function ($container) {var scope = this;scope.getVariable("container").setValue($container.getValue());if (tools.valueFactory.createBoolean(scope.getVariable("container").getValue().callMethod(tools.valueFactory.createBarewordString("hasDefinition").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcherService")).getValue()]).logicalNot().coerceToBoolean().getNative() && (scope.getVariable("container").getValue().callMethod(tools.valueFactory.createBarewordString("hasAlias").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcherService")).getValue()]).logicalNot().coerceToBoolean().getNative())).coerceToBoolean().getNative()) {return tools.valueFactory.createNull();}scope.getVariable("definition").setValue(scope.getVariable("container").getValue().callMethod(tools.valueFactory.createBarewordString("findDefinition").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcherService")).getValue()]));var array_1 = scope.getVariable("container").getValue().callMethod(tools.valueFactory.createBarewordString("findTaggedServiceIds").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listenerTag")).getValue()]).reset();var length_1 = array_1.getLength();var pointer_1 = 0;block_1: while (pointer_1 < length_1) {scope.getVariable("id").setValue(array_1.getKeyByIndex(pointer_1));scope.getVariable("events").setValue(array_1.getElementByIndex(pointer_1).getValue());pointer_1++;scope.getVariable("def").setValue(scope.getVariable("container").getValue().callMethod(tools.valueFactory.createBarewordString("getDefinition").getNative(), [scope.getVariable("id").getValue()]));if (scope.getVariable("def").getValue().callMethod(tools.valueFactory.createBarewordString("isPublic").getNative(), []).logicalNot().coerceToBoolean().getNative()) {throw tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("\\InvalidArgumentException"), [(tools.valueFactory.createBarewordString("sprintf").call([tools.valueFactory.createString("The service \"%s\" must be public as event listeners are lazy-loaded."), scope.getVariable("id")], namespaceScope) || tools.valueFactory.createNull())]);}if (scope.getVariable("def").getValue().callMethod(tools.valueFactory.createBarewordString("isAbstract").getNative(), []).coerceToBoolean().getNative()) {throw tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("\\InvalidArgumentException"), [(tools.valueFactory.createBarewordString("sprintf").call([tools.valueFactory.createString("The service \"%s\" must not be abstract as event listeners are lazy-loaded."), scope.getVariable("id")], namespaceScope) || tools.valueFactory.createNull())]);}var array_2 = scope.getVariable("events").getValue().reset();var length_2 = array_2.getLength();var pointer_2 = 0;block_2: while (pointer_2 < length_2) {scope.getVariable("event").setValue(array_2.getElementByIndex(pointer_2).getValue());pointer_2++;scope.getVariable("priority").setValue(((function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean(scope.getVariable("event").getValue().getElementByKey(tools.valueFactory.createString("priority")).isSet());scope.unsuppressOwnErrors(); return result;}(scope)).coerceToBoolean().getNative() ? scope.getVariable("event").getValue().getElementByKey(tools.valueFactory.createString("priority")).getValue() : tools.valueFactory.createInteger(0)));if ((function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean(scope.getVariable("event").getValue().getElementByKey(tools.valueFactory.createString("event")).isSet());scope.unsuppressOwnErrors(); return result;}(scope)).logicalNot().coerceToBoolean().getNative()) {throw tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("\\InvalidArgumentException"), [(tools.valueFactory.createBarewordString("sprintf").call([tools.valueFactory.createString("Service \"%s\" must define the \"event\" attribute on \"%s\" tags."), scope.getVariable("id"), scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listenerTag"))], namespaceScope) || tools.valueFactory.createNull())]);}if ((function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean(scope.getVariable("event").getValue().getElementByKey(tools.valueFactory.createString("method")).isSet());scope.unsuppressOwnErrors(); return result;}(scope)).logicalNot().coerceToBoolean().getNative()) {tools.implyArray(scope.getVariable("event")).getElementByKey(tools.valueFactory.createString("method")).setValue(tools.valueFactory.createString("on").concat((tools.valueFactory.createBarewordString("preg_replace_callback").call([tools.valueFactory.createArray([tools.valueFactory.createString("/(?<=\\b)[a-z]/i"), tools.valueFactory.createString("/[^a-z0-9]/i")]), tools.createClosure(function ($matches) {var scope = this;scope.getVariable("matches").setValue($matches.getValue());return (tools.valueFactory.createBarewordString("strtoupper").call([scope.getVariable("matches").getValue().getElementByKey(tools.valueFactory.createInteger(0))], namespaceScope) || tools.valueFactory.createNull());}, scope), scope.getVariable("event").getValue().getElementByKey(tools.valueFactory.createString("event"))], namespaceScope) || tools.valueFactory.createNull())));tools.implyArray(scope.getVariable("event")).getElementByKey(tools.valueFactory.createString("method")).setValue((tools.valueFactory.createBarewordString("preg_replace").call([tools.valueFactory.createString("/[^a-z0-9]/i"), tools.valueFactory.createString(""), scope.getVariable("event").getValue().getElementByKey(tools.valueFactory.createString("method"))], namespaceScope) || tools.valueFactory.createNull()));}scope.getVariable("definition").getValue().callMethod(tools.valueFactory.createBarewordString("addMethodCall").getNative(), [tools.valueFactory.createString("addListenerService"), tools.valueFactory.createArray([scope.getVariable("event").getValue().getElementByKey(tools.valueFactory.createString("event")).getValue(), tools.valueFactory.createArray([scope.getVariable("id").getValue(), scope.getVariable("event").getValue().getElementByKey(tools.valueFactory.createString("method")).getValue()]), scope.getVariable("priority").getValue()])]);}}var array_1 = scope.getVariable("container").getValue().callMethod(tools.valueFactory.createBarewordString("findTaggedServiceIds").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("subscriberTag")).getValue()]).reset();var length_1 = array_1.getLength();var pointer_1 = 0;block_1: while (pointer_1 < length_1) {scope.getVariable("id").setValue(array_1.getKeyByIndex(pointer_1));scope.getVariable("attributes").setValue(array_1.getElementByIndex(pointer_1).getValue());pointer_1++;scope.getVariable("def").setValue(scope.getVariable("container").getValue().callMethod(tools.valueFactory.createBarewordString("getDefinition").getNative(), [scope.getVariable("id").getValue()]));if (scope.getVariable("def").getValue().callMethod(tools.valueFactory.createBarewordString("isPublic").getNative(), []).logicalNot().coerceToBoolean().getNative()) {throw tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("\\InvalidArgumentException"), [(tools.valueFactory.createBarewordString("sprintf").call([tools.valueFactory.createString("The service \"%s\" must be public as event subscribers are lazy-loaded."), scope.getVariable("id")], namespaceScope) || tools.valueFactory.createNull())]);}if (scope.getVariable("def").getValue().callMethod(tools.valueFactory.createBarewordString("isAbstract").getNative(), []).coerceToBoolean().getNative()) {throw tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("\\InvalidArgumentException"), [(tools.valueFactory.createBarewordString("sprintf").call([tools.valueFactory.createString("The service \"%s\" must not be abstract as event subscribers are lazy-loaded."), scope.getVariable("id")], namespaceScope) || tools.valueFactory.createNull())]);}scope.getVariable("class").setValue(scope.getVariable("container").getValue().callMethod(tools.valueFactory.createBarewordString("getParameterBag").getNative(), []).callMethod(tools.valueFactory.createBarewordString("resolveValue").getNative(), [scope.getVariable("def").getValue().callMethod(tools.valueFactory.createBarewordString("getClass").getNative(), [])]));scope.getVariable("interface").setValue(tools.valueFactory.createString("Symfony\\Component\\EventDispatcher\\EventSubscriberInterface"));if ((tools.valueFactory.createBarewordString("is_subclass_of").call([scope.getVariable("class"), scope.getVariable("interface")], namespaceScope) || tools.valueFactory.createNull()).logicalNot().coerceToBoolean().getNative()) {if ((tools.valueFactory.createBarewordString("class_exists").call([scope.getVariable("class"), tools.valueFactory.createBoolean(false)], namespaceScope) || tools.valueFactory.createNull()).logicalNot().coerceToBoolean().getNative()) {throw tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("\\InvalidArgumentException"), [(tools.valueFactory.createBarewordString("sprintf").call([tools.valueFactory.createString("Class \"%s\" used for service \"%s\" cannot be found."), scope.getVariable("class"), scope.getVariable("id")], namespaceScope) || tools.valueFactory.createNull())]);}throw tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("\\InvalidArgumentException"), [(tools.valueFactory.createBarewordString("sprintf").call([tools.valueFactory.createString("Service \"%s\" must implement interface \"%s\"."), scope.getVariable("id"), scope.getVariable("interface")], namespaceScope) || tools.valueFactory.createNull())]);}scope.getVariable("definition").getValue().callMethod(tools.valueFactory.createBarewordString("addMethodCall").getNative(), [tools.valueFactory.createString("addSubscriberService"), tools.valueFactory.createArray([scope.getVariable("id").getValue(), scope.getVariable("class").getValue()])]);}}}}, constants: {}}, namespaceScope);}());namespaceScope.use("Symfony\\Component\\DependencyInjection\\ContainerBuilder");namespaceScope.use("Symfony\\Component\\DependencyInjection\\Compiler\\CompilerPassInterface");}(namespace))) { return namespaceResult; }return tools.valueFactory.createNull();}));
},{"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api":147,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime":153,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php":173}],186:[function(require,module,exports){
require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php");
module.exports = require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api").load("vendor/symfony/event-dispatcher/Event.php", require('/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime').compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.createNamespaceScope(namespace), namespaceResult, scope = tools.topLevelScope, currentClass = null;if (namespaceResult = (function (globalNamespace) {var namespace = globalNamespace.getDescendant("Symfony\\Component\\EventDispatcher"), namespaceScope = tools.createNamespaceScope(namespace);(function () {var currentClass = namespace.defineClass("Event", {superClass: null, interfaces: [], staticProperties: {}, properties: {"propagationStopped": tools.valueFactory.createBoolean(false)}, methods: {"isPropagationStopped": {isStatic: false, method: function () {var scope = this;return scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("propagationStopped")).getValue();}}, "stopPropagation": {isStatic: false, method: function () {var scope = this;tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("propagationStopped")).setValue(tools.valueFactory.createBoolean(true));}}}, constants: {}}, namespaceScope);}());}(namespace))) { return namespaceResult; }return tools.valueFactory.createNull();}));
},{"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api":147,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime":153,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php":173}],187:[function(require,module,exports){
require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php");
module.exports = require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api").load("vendor/symfony/event-dispatcher/EventDispatcher.php", require('/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime').compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.createNamespaceScope(namespace), namespaceResult, scope = tools.topLevelScope, currentClass = null;if (namespaceResult = (function (globalNamespace) {var namespace = globalNamespace.getDescendant("Symfony\\Component\\EventDispatcher"), namespaceScope = tools.createNamespaceScope(namespace);(function () {var currentClass = namespace.defineClass("EventDispatcher", {superClass: null, interfaces: ["EventDispatcherInterface"], staticProperties: {}, properties: {"listeners": tools.valueFactory.createArray([]), "sorted": tools.valueFactory.createArray([])}, methods: {"dispatch": {isStatic: false, method: function ($eventName, $event) {var scope = this;scope.getVariable("eventName").setValue($eventName.getValue());scope.getVariable("event").setValue($event ? $event.getValue() : tools.valueFactory.createNull());if (tools.valueFactory.createNull().isIdenticalTo(scope.getVariable("event").getValue()).coerceToBoolean().getNative()) {scope.getVariable("event").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("Event"), []));}if (scope.getVariable("listeners").setValue(scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("getListeners").getNative(), [scope.getVariable("eventName").getValue()])).coerceToBoolean().getNative()) {scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("doDispatch").getNative(), [scope.getVariable("listeners").getValue(), scope.getVariable("eventName").getValue(), scope.getVariable("event").getValue()]);}return scope.getVariable("event").getValue();}}, "getListeners": {isStatic: false, method: function ($eventName) {var scope = this;scope.getVariable("eventName").setValue($eventName ? $eventName.getValue() : tools.valueFactory.createNull());if (tools.valueFactory.createNull().isNotIdenticalTo(scope.getVariable("eventName").getValue()).coerceToBoolean().getNative()) {if ((function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean(scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listeners")).getValue().getElementByKey(scope.getVariable("eventName").getValue()).isSet());scope.unsuppressOwnErrors(); return result;}(scope)).logicalNot().coerceToBoolean().getNative()) {return tools.valueFactory.createArray([]);}if ((function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean(scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("sorted")).getValue().getElementByKey(scope.getVariable("eventName").getValue()).isSet());scope.unsuppressOwnErrors(); return result;}(scope)).logicalNot().coerceToBoolean().getNative()) {scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("sortListeners").getNative(), [scope.getVariable("eventName").getValue()]);}return scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("sorted")).getValue().getElementByKey(scope.getVariable("eventName").getValue()).getValue();}var array_1 = scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listeners")).getValue().reset();var length_1 = array_1.getLength();var pointer_1 = 0;block_1: while (pointer_1 < length_1) {scope.getVariable("eventName").setValue(array_1.getKeyByIndex(pointer_1));scope.getVariable("eventListeners").setValue(array_1.getElementByIndex(pointer_1).getValue());pointer_1++;if ((function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean(scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("sorted")).getValue().getElementByKey(scope.getVariable("eventName").getValue()).isSet());scope.unsuppressOwnErrors(); return result;}(scope)).logicalNot().coerceToBoolean().getNative()) {scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("sortListeners").getNative(), [scope.getVariable("eventName").getValue()]);}}return (tools.valueFactory.createBarewordString("array_filter").call([scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("sorted"))], namespaceScope) || tools.valueFactory.createNull());}}, "getListenerPriority": {isStatic: false, method: function ($eventName, $listener) {var scope = this;scope.getVariable("eventName").setValue($eventName.getValue());scope.getVariable("listener").setValue($listener.getValue());if ((function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean(scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listeners")).getValue().getElementByKey(scope.getVariable("eventName").getValue()).isSet());scope.unsuppressOwnErrors(); return result;}(scope)).logicalNot().coerceToBoolean().getNative()) {return tools.valueFactory.createNull();}var array_1 = scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listeners")).getValue().getElementByKey(scope.getVariable("eventName").getValue()).getValue().reset();var length_1 = array_1.getLength();var pointer_1 = 0;block_1: while (pointer_1 < length_1) {scope.getVariable("priority").setValue(array_1.getKeyByIndex(pointer_1));scope.getVariable("listeners").setValue(array_1.getElementByIndex(pointer_1).getValue());pointer_1++;if (tools.valueFactory.createBoolean(false).isNotIdenticalTo(scope.getVariable("key").setValue((tools.valueFactory.createBarewordString("array_search").call([scope.getVariable("listener"), scope.getVariable("listeners"), tools.valueFactory.createBoolean(true)], namespaceScope) || tools.valueFactory.createNull()))).coerceToBoolean().getNative()) {return scope.getVariable("priority").getValue();}}}}, "hasListeners": {isStatic: false, method: function ($eventName) {var scope = this;scope.getVariable("eventName").setValue($eventName ? $eventName.getValue() : tools.valueFactory.createNull());return (tools.valueFactory.createBarewordString("count").call([scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("getListeners").getNative(), [scope.getVariable("eventName")])], namespaceScope) || tools.valueFactory.createNull()).coerceToBoolean();}}, "addListener": {isStatic: false, method: function ($eventName, $listener, $priority) {var scope = this;scope.getVariable("eventName").setValue($eventName.getValue());scope.getVariable("listener").setValue($listener.getValue());scope.getVariable("priority").setValue($priority ? $priority.getValue() : tools.valueFactory.createInteger(0));tools.implyArray(tools.implyArray(tools.implyArray(tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("listeners"))).getElementByKey(scope.getVariable("eventName").getValue())).getElementByKey(scope.getVariable("priority").getValue())).getPushElement().setValue(scope.getVariable("listener").getValue());scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("sorted")).getValue().getElementByKey(scope.getVariable("eventName").getValue()).unset();}}, "removeListener": {isStatic: false, method: function ($eventName, $listener) {var scope = this;scope.getVariable("eventName").setValue($eventName.getValue());scope.getVariable("listener").setValue($listener.getValue());if ((function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean(scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listeners")).getValue().getElementByKey(scope.getVariable("eventName").getValue()).isSet());scope.unsuppressOwnErrors(); return result;}(scope)).logicalNot().coerceToBoolean().getNative()) {return tools.valueFactory.createNull();}var array_1 = scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listeners")).getValue().getElementByKey(scope.getVariable("eventName").getValue()).getValue().reset();var length_1 = array_1.getLength();var pointer_1 = 0;block_1: while (pointer_1 < length_1) {scope.getVariable("priority").setValue(array_1.getKeyByIndex(pointer_1));scope.getVariable("listeners").setValue(array_1.getElementByIndex(pointer_1).getValue());pointer_1++;if (tools.valueFactory.createBoolean(false).isNotIdenticalTo(scope.getVariable("key").setValue((tools.valueFactory.createBarewordString("array_search").call([scope.getVariable("listener"), scope.getVariable("listeners"), tools.valueFactory.createBoolean(true)], namespaceScope) || tools.valueFactory.createNull()))).coerceToBoolean().getNative()) {scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listeners")).getValue().getElementByKey(scope.getVariable("eventName").getValue()).getValue().getElementByKey(scope.getVariable("priority").getValue()).getValue().getElementByKey(scope.getVariable("key").getValue()).unset(); scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("sorted")).getValue().getElementByKey(scope.getVariable("eventName").getValue()).unset();}}}}, "addSubscriber": {isStatic: false, method: function ($subscriber) {var scope = this;scope.getVariable("subscriber").setValue($subscriber.getValue());var array_1 = scope.getVariable("subscriber").getValue().callMethod(tools.valueFactory.createBarewordString("getSubscribedEvents").getNative(), []).reset();var length_1 = array_1.getLength();var pointer_1 = 0;block_1: while (pointer_1 < length_1) {scope.getVariable("eventName").setValue(array_1.getKeyByIndex(pointer_1));scope.getVariable("params").setValue(array_1.getElementByIndex(pointer_1).getValue());pointer_1++;if ((tools.valueFactory.createBarewordString("is_string").call([scope.getVariable("params")], namespaceScope) || tools.valueFactory.createNull()).coerceToBoolean().getNative()) {scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [scope.getVariable("eventName").getValue(), tools.valueFactory.createArray([scope.getVariable("subscriber").getValue(), scope.getVariable("params").getValue()])]);} else {if ((tools.valueFactory.createBarewordString("is_string").call([scope.getVariable("params").getValue().getElementByKey(tools.valueFactory.createInteger(0))], namespaceScope) || tools.valueFactory.createNull()).coerceToBoolean().getNative()) {scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [scope.getVariable("eventName").getValue(), tools.valueFactory.createArray([scope.getVariable("subscriber").getValue(), scope.getVariable("params").getValue().getElementByKey(tools.valueFactory.createInteger(0)).getValue()]), ((function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean(scope.getVariable("params").getValue().getElementByKey(tools.valueFactory.createInteger(1)).isSet());scope.unsuppressOwnErrors(); return result;}(scope)).coerceToBoolean().getNative() ? scope.getVariable("params").getValue().getElementByKey(tools.valueFactory.createInteger(1)).getValue() : tools.valueFactory.createInteger(0))]);} else {var array_2 = scope.getVariable("params").getValue().reset();var length_2 = array_2.getLength();var pointer_2 = 0;block_2: while (pointer_2 < length_2) {scope.getVariable("listener").setValue(array_2.getElementByIndex(pointer_2).getValue());pointer_2++;scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [scope.getVariable("eventName").getValue(), tools.valueFactory.createArray([scope.getVariable("subscriber").getValue(), scope.getVariable("listener").getValue().getElementByKey(tools.valueFactory.createInteger(0)).getValue()]), ((function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean(scope.getVariable("listener").getValue().getElementByKey(tools.valueFactory.createInteger(1)).isSet());scope.unsuppressOwnErrors(); return result;}(scope)).coerceToBoolean().getNative() ? scope.getVariable("listener").getValue().getElementByKey(tools.valueFactory.createInteger(1)).getValue() : tools.valueFactory.createInteger(0))]);}}}}}}, "removeSubscriber": {isStatic: false, method: function ($subscriber) {var scope = this;scope.getVariable("subscriber").setValue($subscriber.getValue());var array_1 = scope.getVariable("subscriber").getValue().callMethod(tools.valueFactory.createBarewordString("getSubscribedEvents").getNative(), []).reset();var length_1 = array_1.getLength();var pointer_1 = 0;block_1: while (pointer_1 < length_1) {scope.getVariable("eventName").setValue(array_1.getKeyByIndex(pointer_1));scope.getVariable("params").setValue(array_1.getElementByIndex(pointer_1).getValue());pointer_1++;if (tools.valueFactory.createBoolean((tools.valueFactory.createBarewordString("is_array").call([scope.getVariable("params")], namespaceScope) || tools.valueFactory.createNull()).coerceToBoolean().getNative() && ((tools.valueFactory.createBarewordString("is_array").call([scope.getVariable("params").getValue().getElementByKey(tools.valueFactory.createInteger(0))], namespaceScope) || tools.valueFactory.createNull()).coerceToBoolean().getNative())).coerceToBoolean().getNative()) {var array_2 = scope.getVariable("params").getValue().reset();var length_2 = array_2.getLength();var pointer_2 = 0;block_2: while (pointer_2 < length_2) {scope.getVariable("listener").setValue(array_2.getElementByIndex(pointer_2).getValue());pointer_2++;scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("removeListener").getNative(), [scope.getVariable("eventName").getValue(), tools.valueFactory.createArray([scope.getVariable("subscriber").getValue(), scope.getVariable("listener").getValue().getElementByKey(tools.valueFactory.createInteger(0)).getValue()])]);}} else {scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("removeListener").getNative(), [scope.getVariable("eventName").getValue(), tools.valueFactory.createArray([scope.getVariable("subscriber").getValue(), ((tools.valueFactory.createBarewordString("is_string").call([scope.getVariable("params")], namespaceScope) || tools.valueFactory.createNull()).coerceToBoolean().getNative() ? scope.getVariable("params").getValue() : scope.getVariable("params").getValue().getElementByKey(tools.valueFactory.createInteger(0)).getValue())])]);}}}}, "doDispatch": {isStatic: false, method: function ($listeners, $eventName, $event) {var scope = this;scope.getVariable("listeners").setValue($listeners.getValue());scope.getVariable("eventName").setValue($eventName.getValue());scope.getVariable("event").setValue($event.getValue());var array_1 = scope.getVariable("listeners").getValue().reset();var length_1 = array_1.getLength();var pointer_1 = 0;block_1: while (pointer_1 < length_1) {scope.getVariable("listener").setValue(array_1.getElementByIndex(pointer_1).getValue());pointer_1++;if (scope.getVariable("event").getValue().callMethod(tools.valueFactory.createBarewordString("isPropagationStopped").getNative(), []).coerceToBoolean().getNative()) {break block_1;}(tools.valueFactory.createBarewordString("call_user_func").call([scope.getVariable("listener"), scope.getVariable("event"), scope.getVariable("eventName"), scope.getVariable("this")], namespaceScope) || tools.valueFactory.createNull());}}}, "sortListeners": {isStatic: false, method: function ($eventName) {var scope = this;scope.getVariable("eventName").setValue($eventName.getValue());(tools.valueFactory.createBarewordString("krsort").call([scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listeners")).getValue().getElementByKey(scope.getVariable("eventName").getValue())], namespaceScope) || tools.valueFactory.createNull());tools.implyArray(tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("sorted"))).getElementByKey(scope.getVariable("eventName").getValue()).setValue((tools.valueFactory.createBarewordString("call_user_func_array").call([tools.valueFactory.createString("array_merge"), scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listeners")).getValue().getElementByKey(scope.getVariable("eventName").getValue())], namespaceScope) || tools.valueFactory.createNull()));}}}, constants: {}}, namespaceScope);}());}(namespace))) { return namespaceResult; }return tools.valueFactory.createNull();}));
},{"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api":147,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime":153,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php":173}],188:[function(require,module,exports){
require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php");
module.exports = require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api").load("vendor/symfony/event-dispatcher/EventDispatcherInterface.php", require('/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime').compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.createNamespaceScope(namespace), namespaceResult, scope = tools.topLevelScope, currentClass = null;if (namespaceResult = (function (globalNamespace) {var namespace = globalNamespace.getDescendant("Symfony\\Component\\EventDispatcher"), namespaceScope = tools.createNamespaceScope(namespace);(function () {var currentClass = namespace.defineClass("EventDispatcherInterface", {superClass: null, staticProperties: {}, properties: {}, methods: {"dispatch": {isStatic: false, abstract: true}, "addListener": {isStatic: false, abstract: true}, "addSubscriber": {isStatic: false, abstract: true}, "removeListener": {isStatic: false, abstract: true}, "removeSubscriber": {isStatic: false, abstract: true}, "getListeners": {isStatic: false, abstract: true}, "getListenerPriority": {isStatic: false, abstract: true}, "hasListeners": {isStatic: false, abstract: true}}, constants: {}}, namespaceScope);}());}(namespace))) { return namespaceResult; }return tools.valueFactory.createNull();}));
},{"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api":147,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime":153,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php":173}],189:[function(require,module,exports){
require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php");
module.exports = require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api").load("vendor/symfony/event-dispatcher/EventSubscriberInterface.php", require('/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime').compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.createNamespaceScope(namespace), namespaceResult, scope = tools.topLevelScope, currentClass = null;if (namespaceResult = (function (globalNamespace) {var namespace = globalNamespace.getDescendant("Symfony\\Component\\EventDispatcher"), namespaceScope = tools.createNamespaceScope(namespace);(function () {var currentClass = namespace.defineClass("EventSubscriberInterface", {superClass: null, staticProperties: {}, properties: {}, methods: {"getSubscribedEvents": {isStatic: true, abstract: true}}, constants: {}}, namespaceScope);}());}(namespace))) { return namespaceResult; }return tools.valueFactory.createNull();}));
},{"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api":147,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime":153,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php":173}],190:[function(require,module,exports){
require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php");
module.exports = require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api").load("vendor/symfony/event-dispatcher/GenericEvent.php", require('/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime').compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.createNamespaceScope(namespace), namespaceResult, scope = tools.topLevelScope, currentClass = null;if (namespaceResult = (function (globalNamespace) {var namespace = globalNamespace.getDescendant("Symfony\\Component\\EventDispatcher"), namespaceScope = tools.createNamespaceScope(namespace);(function () {var currentClass = namespace.defineClass("GenericEvent", {superClass: namespaceScope.getClass("Event"), interfaces: ["\\ArrayAccess","\\IteratorAggregate"], staticProperties: {}, properties: {"subject": null, "arguments": null}, methods: {"__construct": {isStatic: false, method: function ($subject, $arguments) {var scope = this;scope.getVariable("subject").setValue($subject ? $subject.getValue() : tools.valueFactory.createNull());scope.getVariable("arguments").setValue($arguments ? $arguments.getValue() : tools.valueFactory.createArray([]));tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("subject")).setValue(scope.getVariable("subject").getValue());tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("arguments")).setValue(scope.getVariable("arguments").getValue());}}, "getSubject": {isStatic: false, method: function () {var scope = this;return scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("subject")).getValue();}}, "getArgument": {isStatic: false, method: function ($key) {var scope = this;scope.getVariable("key").setValue($key.getValue());if (scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("hasArgument").getNative(), [scope.getVariable("key").getValue()]).coerceToBoolean().getNative()) {return scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("arguments")).getValue().getElementByKey(scope.getVariable("key").getValue()).getValue();}throw tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("\\InvalidArgumentException"), [(tools.valueFactory.createBarewordString("sprintf").call([tools.valueFactory.createString("Argument \"%s\" not found."), scope.getVariable("key")], namespaceScope) || tools.valueFactory.createNull())]);}}, "setArgument": {isStatic: false, method: function ($key, $value) {var scope = this;scope.getVariable("key").setValue($key.getValue());scope.getVariable("value").setValue($value.getValue());tools.implyArray(tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("arguments"))).getElementByKey(scope.getVariable("key").getValue()).setValue(scope.getVariable("value").getValue());return scope.getVariable("this").getValue();}}, "getArguments": {isStatic: false, method: function () {var scope = this;return scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("arguments")).getValue();}}, "setArguments": {isStatic: false, method: function ($args) {var scope = this;scope.getVariable("args").setValue($args ? $args.getValue() : tools.valueFactory.createArray([]));tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("arguments")).setValue(scope.getVariable("args").getValue());return scope.getVariable("this").getValue();}}, "hasArgument": {isStatic: false, method: function ($key) {var scope = this;scope.getVariable("key").setValue($key.getValue());return (tools.valueFactory.createBarewordString("array_key_exists").call([scope.getVariable("key"), scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("arguments"))], namespaceScope) || tools.valueFactory.createNull());}}, "offsetGet": {isStatic: false, method: function ($key) {var scope = this;scope.getVariable("key").setValue($key.getValue());return scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("getArgument").getNative(), [scope.getVariable("key").getValue()]);}}, "offsetSet": {isStatic: false, method: function ($key, $value) {var scope = this;scope.getVariable("key").setValue($key.getValue());scope.getVariable("value").setValue($value.getValue());scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("setArgument").getNative(), [scope.getVariable("key").getValue(), scope.getVariable("value").getValue()]);}}, "offsetUnset": {isStatic: false, method: function ($key) {var scope = this;scope.getVariable("key").setValue($key.getValue());if (scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("hasArgument").getNative(), [scope.getVariable("key").getValue()]).coerceToBoolean().getNative()) {scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("arguments")).getValue().getElementByKey(scope.getVariable("key").getValue()).unset();}}}, "offsetExists": {isStatic: false, method: function ($key) {var scope = this;scope.getVariable("key").setValue($key.getValue());return scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("hasArgument").getNative(), [scope.getVariable("key").getValue()]);}}, "getIterator": {isStatic: false, method: function () {var scope = this;return tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("\\ArrayIterator"), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("arguments")).getValue()]);}}}, constants: {}}, namespaceScope);}());}(namespace))) { return namespaceResult; }return tools.valueFactory.createNull();}));
},{"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api":147,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime":153,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php":173}],191:[function(require,module,exports){
require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php");
module.exports = require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api").load("vendor/symfony/event-dispatcher/ImmutableEventDispatcher.php", require('/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime').compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.createNamespaceScope(namespace), namespaceResult, scope = tools.topLevelScope, currentClass = null;if (namespaceResult = (function (globalNamespace) {var namespace = globalNamespace.getDescendant("Symfony\\Component\\EventDispatcher"), namespaceScope = tools.createNamespaceScope(namespace);(function () {var currentClass = namespace.defineClass("ImmutableEventDispatcher", {superClass: null, interfaces: ["EventDispatcherInterface"], staticProperties: {}, properties: {"dispatcher": null}, methods: {"__construct": {isStatic: false, method: function ($dispatcher) {var scope = this;scope.getVariable("dispatcher").setValue($dispatcher.getValue());tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).setValue(scope.getVariable("dispatcher").getValue());}}, "dispatch": {isStatic: false, method: function ($eventName, $event) {var scope = this;scope.getVariable("eventName").setValue($eventName.getValue());scope.getVariable("event").setValue($event ? $event.getValue() : tools.valueFactory.createNull());return scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("dispatch").getNative(), [scope.getVariable("eventName").getValue(), scope.getVariable("event").getValue()]);}}, "addListener": {isStatic: false, method: function ($eventName, $listener, $priority) {var scope = this;scope.getVariable("eventName").setValue($eventName.getValue());scope.getVariable("listener").setValue($listener.getValue());scope.getVariable("priority").setValue($priority ? $priority.getValue() : tools.valueFactory.createInteger(0));throw tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("\\BadMethodCallException"), [tools.valueFactory.createString("Unmodifiable event dispatchers must not be modified.")]);}}, "addSubscriber": {isStatic: false, method: function ($subscriber) {var scope = this;scope.getVariable("subscriber").setValue($subscriber.getValue());throw tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("\\BadMethodCallException"), [tools.valueFactory.createString("Unmodifiable event dispatchers must not be modified.")]);}}, "removeListener": {isStatic: false, method: function ($eventName, $listener) {var scope = this;scope.getVariable("eventName").setValue($eventName.getValue());scope.getVariable("listener").setValue($listener.getValue());throw tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("\\BadMethodCallException"), [tools.valueFactory.createString("Unmodifiable event dispatchers must not be modified.")]);}}, "removeSubscriber": {isStatic: false, method: function ($subscriber) {var scope = this;scope.getVariable("subscriber").setValue($subscriber.getValue());throw tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("\\BadMethodCallException"), [tools.valueFactory.createString("Unmodifiable event dispatchers must not be modified.")]);}}, "getListeners": {isStatic: false, method: function ($eventName) {var scope = this;scope.getVariable("eventName").setValue($eventName ? $eventName.getValue() : tools.valueFactory.createNull());return scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("getListeners").getNative(), [scope.getVariable("eventName").getValue()]);}}, "getListenerPriority": {isStatic: false, method: function ($eventName, $listener) {var scope = this;scope.getVariable("eventName").setValue($eventName.getValue());scope.getVariable("listener").setValue($listener.getValue());return scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("getListenerPriority").getNative(), [scope.getVariable("eventName").getValue(), scope.getVariable("listener").getValue()]);}}, "hasListeners": {isStatic: false, method: function ($eventName) {var scope = this;scope.getVariable("eventName").setValue($eventName ? $eventName.getValue() : tools.valueFactory.createNull());return scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("hasListeners").getNative(), [scope.getVariable("eventName").getValue()]);}}}, constants: {}}, namespaceScope);}());}(namespace))) { return namespaceResult; }return tools.valueFactory.createNull();}));
},{"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api":147,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime":153,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php":173}],192:[function(require,module,exports){
require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php");
module.exports = require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api").load("vendor/symfony/event-dispatcher/Tests/AbstractEventDispatcherTest.php", require('/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime').compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.createNamespaceScope(namespace), namespaceResult, scope = tools.topLevelScope, currentClass = null;if (namespaceResult = (function (globalNamespace) {var namespace = globalNamespace.getDescendant("Symfony\\Component\\EventDispatcher\\Tests"), namespaceScope = tools.createNamespaceScope(namespace);(function () {var currentClass = namespace.defineClass("AbstractEventDispatcherTest", {superClass: namespaceScope.getClass("\\PHPUnit_Framework_TestCase"), interfaces: [], staticProperties: {}, properties: {"dispatcher": null, "listener": null}, methods: {"setUp": {isStatic: false, method: function () {var scope = this;tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).setValue(scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("createEventDispatcher").getNative(), []));tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("listener")).setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("TestEventListener"), []));}}, "tearDown": {isStatic: false, method: function () {var scope = this;tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).setValue(tools.valueFactory.createNull());tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("listener")).setValue(tools.valueFactory.createNull());}}, "testInitialState": {isStatic: false, method: function () {var scope = this;scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertEquals").getNative(), [tools.valueFactory.createArray([]), scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("getListeners").getNative(), [])]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertFalse").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("hasListeners").getNative(), [scope.getClassNameOrThrow().getConstantByName("preFoo", namespaceScope)])]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertFalse").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("hasListeners").getNative(), [scope.getClassNameOrThrow().getConstantByName("postFoo", namespaceScope)])]);}}, "testAddListener": {isStatic: false, method: function () {var scope = this;scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("pre.foo"), tools.valueFactory.createArray([scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listener")).getValue(), tools.valueFactory.createString("preFoo")])]);scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("post.foo"), tools.valueFactory.createArray([scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listener")).getValue(), tools.valueFactory.createString("postFoo")])]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertTrue").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("hasListeners").getNative(), [scope.getClassNameOrThrow().getConstantByName("preFoo", namespaceScope)])]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertTrue").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("hasListeners").getNative(), [scope.getClassNameOrThrow().getConstantByName("postFoo", namespaceScope)])]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertCount").getNative(), [tools.valueFactory.createInteger(1), scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("getListeners").getNative(), [scope.getClassNameOrThrow().getConstantByName("preFoo", namespaceScope)])]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertCount").getNative(), [tools.valueFactory.createInteger(1), scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("getListeners").getNative(), [scope.getClassNameOrThrow().getConstantByName("postFoo", namespaceScope)])]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertCount").getNative(), [tools.valueFactory.createInteger(2), scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("getListeners").getNative(), [])]);}}, "testGetListenersSortsByPriority": {isStatic: false, method: function () {var scope = this;scope.getVariable("listener1").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("TestEventListener"), []));scope.getVariable("listener2").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("TestEventListener"), []));scope.getVariable("listener3").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("TestEventListener"), []));tools.implyObject(scope.getVariable("listener1")).getInstancePropertyByName(tools.valueFactory.createBarewordString("name")).setValue(tools.valueFactory.createString("1"));tools.implyObject(scope.getVariable("listener2")).getInstancePropertyByName(tools.valueFactory.createBarewordString("name")).setValue(tools.valueFactory.createString("2"));tools.implyObject(scope.getVariable("listener3")).getInstancePropertyByName(tools.valueFactory.createBarewordString("name")).setValue(tools.valueFactory.createString("3"));scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("pre.foo"), tools.valueFactory.createArray([scope.getVariable("listener1").getValue(), tools.valueFactory.createString("preFoo")]), tools.valueFactory.createInteger(10).toNegative()]);scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("pre.foo"), tools.valueFactory.createArray([scope.getVariable("listener2").getValue(), tools.valueFactory.createString("preFoo")]), tools.valueFactory.createInteger(10)]);scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("pre.foo"), tools.valueFactory.createArray([scope.getVariable("listener3").getValue(), tools.valueFactory.createString("preFoo")])]);scope.getVariable("expected").setValue(tools.valueFactory.createArray([tools.valueFactory.createArray([scope.getVariable("listener2").getValue(), tools.valueFactory.createString("preFoo")]), tools.valueFactory.createArray([scope.getVariable("listener3").getValue(), tools.valueFactory.createString("preFoo")]), tools.valueFactory.createArray([scope.getVariable("listener1").getValue(), tools.valueFactory.createString("preFoo")])]));scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertSame").getNative(), [scope.getVariable("expected").getValue(), scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("getListeners").getNative(), [tools.valueFactory.createString("pre.foo")])]);}}, "testGetAllListenersSortsByPriority": {isStatic: false, method: function () {var scope = this;scope.getVariable("listener1").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("TestEventListener"), []));scope.getVariable("listener2").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("TestEventListener"), []));scope.getVariable("listener3").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("TestEventListener"), []));scope.getVariable("listener4").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("TestEventListener"), []));scope.getVariable("listener5").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("TestEventListener"), []));scope.getVariable("listener6").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("TestEventListener"), []));scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("pre.foo"), scope.getVariable("listener1").getValue(), tools.valueFactory.createInteger(10).toNegative()]);scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("pre.foo"), scope.getVariable("listener2").getValue()]);scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("pre.foo"), scope.getVariable("listener3").getValue(), tools.valueFactory.createInteger(10)]);scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("post.foo"), scope.getVariable("listener4").getValue(), tools.valueFactory.createInteger(10).toNegative()]);scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("post.foo"), scope.getVariable("listener5").getValue()]);scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("post.foo"), scope.getVariable("listener6").getValue(), tools.valueFactory.createInteger(10)]);scope.getVariable("expected").setValue(tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("pre.foo"), tools.valueFactory.createArray([scope.getVariable("listener3").getValue(), scope.getVariable("listener2").getValue(), scope.getVariable("listener1").getValue()])), tools.createKeyValuePair(tools.valueFactory.createString("post.foo"), tools.valueFactory.createArray([scope.getVariable("listener6").getValue(), scope.getVariable("listener5").getValue(), scope.getVariable("listener4").getValue()]))]));scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertSame").getNative(), [scope.getVariable("expected").getValue(), scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("getListeners").getNative(), [])]);}}, "testGetListenerPriority": {isStatic: false, method: function () {var scope = this;scope.getVariable("listener1").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("TestEventListener"), []));scope.getVariable("listener2").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("TestEventListener"), []));scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("pre.foo"), scope.getVariable("listener1").getValue(), tools.valueFactory.createInteger(10).toNegative()]);scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("pre.foo"), scope.getVariable("listener2").getValue()]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertSame").getNative(), [tools.valueFactory.createInteger(10).toNegative(), scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("getListenerPriority").getNative(), [tools.valueFactory.createString("pre.foo"), scope.getVariable("listener1").getValue()])]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertSame").getNative(), [tools.valueFactory.createInteger(0), scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("getListenerPriority").getNative(), [tools.valueFactory.createString("pre.foo"), scope.getVariable("listener2").getValue()])]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertNull").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("getListenerPriority").getNative(), [tools.valueFactory.createString("pre.bar"), scope.getVariable("listener2").getValue()])]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertNull").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("getListenerPriority").getNative(), [tools.valueFactory.createString("pre.foo"), tools.createClosure(function () {var scope = this;}, scope)])]);}}, "testDispatch": {isStatic: false, method: function () {var scope = this;scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("pre.foo"), tools.valueFactory.createArray([scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listener")).getValue(), tools.valueFactory.createString("preFoo")])]);scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("post.foo"), tools.valueFactory.createArray([scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listener")).getValue(), tools.valueFactory.createString("postFoo")])]);scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("dispatch").getNative(), [scope.getClassNameOrThrow().getConstantByName("preFoo", namespaceScope)]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertTrue").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listener")).getValue().getInstancePropertyByName(tools.valueFactory.createBarewordString("preFooInvoked")).getValue()]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertFalse").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listener")).getValue().getInstancePropertyByName(tools.valueFactory.createBarewordString("postFooInvoked")).getValue()]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertInstanceOf").getNative(), [tools.valueFactory.createString("Symfony\\Component\\EventDispatcher\\Event"), scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("dispatch").getNative(), [tools.valueFactory.createString("noevent")])]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertInstanceOf").getNative(), [tools.valueFactory.createString("Symfony\\Component\\EventDispatcher\\Event"), scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("dispatch").getNative(), [scope.getClassNameOrThrow().getConstantByName("preFoo", namespaceScope)])]);scope.getVariable("event").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("Event"), []));scope.getVariable("return").setValue(scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("dispatch").getNative(), [scope.getClassNameOrThrow().getConstantByName("preFoo", namespaceScope), scope.getVariable("event").getValue()]));scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertSame").getNative(), [scope.getVariable("event").getValue(), scope.getVariable("return").getValue()]);}}, "testDispatchForClosure": {isStatic: false, method: function () {var scope = this;scope.getVariable("invoked").setValue(tools.valueFactory.createInteger(0));scope.getVariable("listener").setValue(tools.createClosure((function (parentScope) { return function () {var scope = this;scope.getVariable("invoked").setReference(parentScope.getVariable("invoked").getReference());scope.getVariable("invoked").preIncrement();}; }(scope)), scope));scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("pre.foo"), scope.getVariable("listener").getValue()]);scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("post.foo"), scope.getVariable("listener").getValue()]);scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("dispatch").getNative(), [scope.getClassNameOrThrow().getConstantByName("preFoo", namespaceScope)]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertEquals").getNative(), [tools.valueFactory.createInteger(1), scope.getVariable("invoked").getValue()]);}}, "testStopEventPropagation": {isStatic: false, method: function () {var scope = this;scope.getVariable("otherListener").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("TestEventListener"), []));scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("post.foo"), tools.valueFactory.createArray([scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listener")).getValue(), tools.valueFactory.createString("postFoo")]), tools.valueFactory.createInteger(10)]);scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("post.foo"), tools.valueFactory.createArray([scope.getVariable("otherListener").getValue(), tools.valueFactory.createString("preFoo")])]);scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("dispatch").getNative(), [scope.getClassNameOrThrow().getConstantByName("postFoo", namespaceScope)]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertTrue").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listener")).getValue().getInstancePropertyByName(tools.valueFactory.createBarewordString("postFooInvoked")).getValue()]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertFalse").getNative(), [scope.getVariable("otherListener").getInstancePropertyByName(tools.valueFactory.createBarewordString("postFooInvoked")).getValue()]);}}, "testDispatchByPriority": {isStatic: false, method: function () {var scope = this;scope.getVariable("invoked").setValue(tools.valueFactory.createArray([]));scope.getVariable("listener1").setValue(tools.createClosure((function (parentScope) { return function () {var scope = this;scope.getVariable("invoked").setReference(parentScope.getVariable("invoked").getReference());tools.implyArray(scope.getVariable("invoked")).getPushElement().setValue(tools.valueFactory.createString("1"));}; }(scope)), scope));scope.getVariable("listener2").setValue(tools.createClosure((function (parentScope) { return function () {var scope = this;scope.getVariable("invoked").setReference(parentScope.getVariable("invoked").getReference());tools.implyArray(scope.getVariable("invoked")).getPushElement().setValue(tools.valueFactory.createString("2"));}; }(scope)), scope));scope.getVariable("listener3").setValue(tools.createClosure((function (parentScope) { return function () {var scope = this;scope.getVariable("invoked").setReference(parentScope.getVariable("invoked").getReference());tools.implyArray(scope.getVariable("invoked")).getPushElement().setValue(tools.valueFactory.createString("3"));}; }(scope)), scope));scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("pre.foo"), scope.getVariable("listener1").getValue(), tools.valueFactory.createInteger(10).toNegative()]);scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("pre.foo"), scope.getVariable("listener2").getValue()]);scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("pre.foo"), scope.getVariable("listener3").getValue(), tools.valueFactory.createInteger(10)]);scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("dispatch").getNative(), [scope.getClassNameOrThrow().getConstantByName("preFoo", namespaceScope)]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertEquals").getNative(), [tools.valueFactory.createArray([tools.valueFactory.createString("3"), tools.valueFactory.createString("2"), tools.valueFactory.createString("1")]), scope.getVariable("invoked").getValue()]);}}, "testRemoveListener": {isStatic: false, method: function () {var scope = this;scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("pre.bar"), scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listener")).getValue()]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertTrue").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("hasListeners").getNative(), [scope.getClassNameOrThrow().getConstantByName("preBar", namespaceScope)])]);scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("removeListener").getNative(), [tools.valueFactory.createString("pre.bar"), scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listener")).getValue()]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertFalse").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("hasListeners").getNative(), [scope.getClassNameOrThrow().getConstantByName("preBar", namespaceScope)])]);scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("removeListener").getNative(), [tools.valueFactory.createString("notExists"), scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("listener")).getValue()]);}}, "testAddSubscriber": {isStatic: false, method: function () {var scope = this;scope.getVariable("eventSubscriber").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("TestEventSubscriber"), []));scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addSubscriber").getNative(), [scope.getVariable("eventSubscriber").getValue()]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertTrue").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("hasListeners").getNative(), [scope.getClassNameOrThrow().getConstantByName("preFoo", namespaceScope)])]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertTrue").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("hasListeners").getNative(), [scope.getClassNameOrThrow().getConstantByName("postFoo", namespaceScope)])]);}}, "testAddSubscriberWithPriorities": {isStatic: false, method: function () {var scope = this;scope.getVariable("eventSubscriber").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("TestEventSubscriber"), []));scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addSubscriber").getNative(), [scope.getVariable("eventSubscriber").getValue()]);scope.getVariable("eventSubscriber").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("TestEventSubscriberWithPriorities"), []));scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addSubscriber").getNative(), [scope.getVariable("eventSubscriber").getValue()]);scope.getVariable("listeners").setValue(scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("getListeners").getNative(), [tools.valueFactory.createString("pre.foo")]));scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertTrue").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("hasListeners").getNative(), [scope.getClassNameOrThrow().getConstantByName("preFoo", namespaceScope)])]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertCount").getNative(), [tools.valueFactory.createInteger(2), scope.getVariable("listeners").getValue()]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertInstanceOf").getNative(), [tools.valueFactory.createString("Symfony\\Component\\EventDispatcher\\Tests\\TestEventSubscriberWithPriorities"), scope.getVariable("listeners").getValue().getElementByKey(tools.valueFactory.createInteger(0)).getValue().getElementByKey(tools.valueFactory.createInteger(0)).getValue()]);}}, "testAddSubscriberWithMultipleListeners": {isStatic: false, method: function () {var scope = this;scope.getVariable("eventSubscriber").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("TestEventSubscriberWithMultipleListeners"), []));scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addSubscriber").getNative(), [scope.getVariable("eventSubscriber").getValue()]);scope.getVariable("listeners").setValue(scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("getListeners").getNative(), [tools.valueFactory.createString("pre.foo")]));scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertTrue").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("hasListeners").getNative(), [scope.getClassNameOrThrow().getConstantByName("preFoo", namespaceScope)])]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertCount").getNative(), [tools.valueFactory.createInteger(2), scope.getVariable("listeners").getValue()]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertEquals").getNative(), [tools.valueFactory.createString("preFoo2"), scope.getVariable("listeners").getValue().getElementByKey(tools.valueFactory.createInteger(0)).getValue().getElementByKey(tools.valueFactory.createInteger(1)).getValue()]);}}, "testRemoveSubscriber": {isStatic: false, method: function () {var scope = this;scope.getVariable("eventSubscriber").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("TestEventSubscriber"), []));scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addSubscriber").getNative(), [scope.getVariable("eventSubscriber").getValue()]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertTrue").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("hasListeners").getNative(), [scope.getClassNameOrThrow().getConstantByName("preFoo", namespaceScope)])]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertTrue").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("hasListeners").getNative(), [scope.getClassNameOrThrow().getConstantByName("postFoo", namespaceScope)])]);scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("removeSubscriber").getNative(), [scope.getVariable("eventSubscriber").getValue()]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertFalse").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("hasListeners").getNative(), [scope.getClassNameOrThrow().getConstantByName("preFoo", namespaceScope)])]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertFalse").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("hasListeners").getNative(), [scope.getClassNameOrThrow().getConstantByName("postFoo", namespaceScope)])]);}}, "testRemoveSubscriberWithPriorities": {isStatic: false, method: function () {var scope = this;scope.getVariable("eventSubscriber").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("TestEventSubscriberWithPriorities"), []));scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addSubscriber").getNative(), [scope.getVariable("eventSubscriber").getValue()]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertTrue").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("hasListeners").getNative(), [scope.getClassNameOrThrow().getConstantByName("preFoo", namespaceScope)])]);scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("removeSubscriber").getNative(), [scope.getVariable("eventSubscriber").getValue()]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertFalse").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("hasListeners").getNative(), [scope.getClassNameOrThrow().getConstantByName("preFoo", namespaceScope)])]);}}, "testRemoveSubscriberWithMultipleListeners": {isStatic: false, method: function () {var scope = this;scope.getVariable("eventSubscriber").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("TestEventSubscriberWithMultipleListeners"), []));scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addSubscriber").getNative(), [scope.getVariable("eventSubscriber").getValue()]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertTrue").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("hasListeners").getNative(), [scope.getClassNameOrThrow().getConstantByName("preFoo", namespaceScope)])]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertCount").getNative(), [tools.valueFactory.createInteger(2), scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("getListeners").getNative(), [scope.getClassNameOrThrow().getConstantByName("preFoo", namespaceScope)])]);scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("removeSubscriber").getNative(), [scope.getVariable("eventSubscriber").getValue()]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertFalse").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("hasListeners").getNative(), [scope.getClassNameOrThrow().getConstantByName("preFoo", namespaceScope)])]);}}, "testEventReceivesTheDispatcherInstanceAsArgument": {isStatic: false, method: function () {var scope = this;scope.getVariable("listener").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("TestWithDispatcher"), []));scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("test"), tools.valueFactory.createArray([scope.getVariable("listener").getValue(), tools.valueFactory.createString("foo")])]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertNull").getNative(), [scope.getVariable("listener").getInstancePropertyByName(tools.valueFactory.createBarewordString("name")).getValue()]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertNull").getNative(), [scope.getVariable("listener").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue()]);scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("dispatch").getNative(), [tools.valueFactory.createString("test")]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertEquals").getNative(), [tools.valueFactory.createString("test"), scope.getVariable("listener").getInstancePropertyByName(tools.valueFactory.createBarewordString("name")).getValue()]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertSame").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue(), scope.getVariable("listener").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue()]);}}, "testWorkaroundForPhpBug62976": {isStatic: false, method: function () {var scope = this;scope.getVariable("dispatcher").setValue(scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("createEventDispatcher").getNative(), []));scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("bug.62976"), tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("CallableClass"), [])]);scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("removeListener").getNative(), [tools.valueFactory.createString("bug.62976"), tools.createClosure(function () {var scope = this;}, scope)]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertTrue").getNative(), [scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("hasListeners").getNative(), [tools.valueFactory.createString("bug.62976")])]);}}, "testHasListenersWhenAddedCallbackListenerIsRemoved": {isStatic: false, method: function () {var scope = this;scope.getVariable("listener").setValue(tools.createClosure(function () {var scope = this;}, scope));scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("foo"), scope.getVariable("listener").getValue()]);scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("removeListener").getNative(), [tools.valueFactory.createString("foo"), scope.getVariable("listener").getValue()]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertFalse").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("hasListeners").getNative(), [])]);}}, "testGetListenersWhenAddedCallbackListenerIsRemoved": {isStatic: false, method: function () {var scope = this;scope.getVariable("listener").setValue(tools.createClosure(function () {var scope = this;}, scope));scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("foo"), scope.getVariable("listener").getValue()]);scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("removeListener").getNative(), [tools.valueFactory.createString("foo"), scope.getVariable("listener").getValue()]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertSame").getNative(), [tools.valueFactory.createArray([]), scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("getListeners").getNative(), [])]);}}, "testHasListenersWithoutEventsReturnsFalseAfterHasListenersWithEventHasBeenCalled": {isStatic: false, method: function () {var scope = this;scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertFalse").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("hasListeners").getNative(), [tools.valueFactory.createString("foo")])]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertFalse").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("hasListeners").getNative(), [])]);}}}, constants: {"preFoo": function () { return tools.valueFactory.createString("pre.foo"); }, "postFoo": function () { return tools.valueFactory.createString("post.foo"); }, "preBar": function () { return tools.valueFactory.createString("pre.bar"); }, "postBar": function () { return tools.valueFactory.createString("post.bar"); }}}, namespaceScope);}());(function () {var currentClass = namespace.defineClass("CallableClass", {superClass: null, interfaces: [], staticProperties: {}, properties: {}, methods: {"__invoke": {isStatic: false, method: function () {var scope = this;}}}, constants: {}}, namespaceScope);}());(function () {var currentClass = namespace.defineClass("TestEventListener", {superClass: null, interfaces: [], staticProperties: {}, properties: {"preFooInvoked": tools.valueFactory.createBoolean(false), "postFooInvoked": tools.valueFactory.createBoolean(false)}, methods: {"preFoo": {isStatic: false, method: function ($e) {var scope = this;scope.getVariable("e").setValue($e.getValue());tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("preFooInvoked")).setValue(tools.valueFactory.createBoolean(true));}}, "postFoo": {isStatic: false, method: function ($e) {var scope = this;scope.getVariable("e").setValue($e.getValue());tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("postFooInvoked")).setValue(tools.valueFactory.createBoolean(true));scope.getVariable("e").getValue().callMethod(tools.valueFactory.createBarewordString("stopPropagation").getNative(), []);}}}, constants: {}}, namespaceScope);}());(function () {var currentClass = namespace.defineClass("TestWithDispatcher", {superClass: null, interfaces: [], staticProperties: {}, properties: {"name": null, "dispatcher": null}, methods: {"foo": {isStatic: false, method: function ($e, $name, $dispatcher) {var scope = this;scope.getVariable("e").setValue($e.getValue());scope.getVariable("name").setValue($name.getValue());scope.getVariable("dispatcher").setValue($dispatcher.getValue());tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("name")).setValue(scope.getVariable("name").getValue());tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).setValue(scope.getVariable("dispatcher").getValue());}}}, constants: {}}, namespaceScope);}());(function () {var currentClass = namespace.defineClass("TestEventSubscriber", {superClass: null, interfaces: ["EventSubscriberInterface"], staticProperties: {}, properties: {}, methods: {"getSubscribedEvents": {isStatic: true, method: function () {var scope = this;return tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("pre.foo"), tools.valueFactory.createString("preFoo")), tools.createKeyValuePair(tools.valueFactory.createString("post.foo"), tools.valueFactory.createString("postFoo"))]);}}}, constants: {}}, namespaceScope);}());(function () {var currentClass = namespace.defineClass("TestEventSubscriberWithPriorities", {superClass: null, interfaces: ["EventSubscriberInterface"], staticProperties: {}, properties: {}, methods: {"getSubscribedEvents": {isStatic: true, method: function () {var scope = this;return tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("pre.foo"), tools.valueFactory.createArray([tools.valueFactory.createString("preFoo"), tools.valueFactory.createInteger(10)])), tools.createKeyValuePair(tools.valueFactory.createString("post.foo"), tools.valueFactory.createArray([tools.valueFactory.createString("postFoo")]))]);}}}, constants: {}}, namespaceScope);}());(function () {var currentClass = namespace.defineClass("TestEventSubscriberWithMultipleListeners", {superClass: null, interfaces: ["EventSubscriberInterface"], staticProperties: {}, properties: {}, methods: {"getSubscribedEvents": {isStatic: true, method: function () {var scope = this;return tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("pre.foo"), tools.valueFactory.createArray([tools.valueFactory.createArray([tools.valueFactory.createString("preFoo1")]), tools.valueFactory.createArray([tools.valueFactory.createString("preFoo2"), tools.valueFactory.createInteger(10)])]))]);}}}, constants: {}}, namespaceScope);}());namespaceScope.use("Symfony\\Component\\EventDispatcher\\Event");namespaceScope.use("Symfony\\Component\\EventDispatcher\\EventDispatcher");namespaceScope.use("Symfony\\Component\\EventDispatcher\\EventSubscriberInterface");}(namespace))) { return namespaceResult; }return tools.valueFactory.createNull();}));
},{"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api":147,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime":153,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php":173}],193:[function(require,module,exports){
require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php");
module.exports = require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api").load("vendor/symfony/event-dispatcher/Tests/ContainerAwareEventDispatcherTest.php", require('/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime').compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.createNamespaceScope(namespace), namespaceResult, scope = tools.topLevelScope, currentClass = null;if (namespaceResult = (function (globalNamespace) {var namespace = globalNamespace.getDescendant("Symfony\\Component\\EventDispatcher\\Tests"), namespaceScope = tools.createNamespaceScope(namespace);(function () {var currentClass = namespace.defineClass("ContainerAwareEventDispatcherTest", {superClass: namespaceScope.getClass("AbstractEventDispatcherTest"), interfaces: [], staticProperties: {}, properties: {}, methods: {"createEventDispatcher": {isStatic: false, method: function () {var scope = this;scope.getVariable("container").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("Container"), []));return tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("ContainerAwareEventDispatcher"), [scope.getVariable("container").getValue()]);}}, "testAddAListenerService": {isStatic: false, method: function () {var scope = this;scope.getVariable("event").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("Event"), []));scope.getVariable("service").setValue(scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("getMock").getNative(), [tools.valueFactory.createString("Symfony\\Component\\EventDispatcher\\Tests\\Service")]));scope.getVariable("service").getValue().callMethod(tools.valueFactory.createBarewordString("expects").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("once").getNative(), [])]).callMethod(tools.valueFactory.createBarewordString("method").getNative(), [tools.valueFactory.createString("onEvent")]).callMethod(tools.valueFactory.createBarewordString("with").getNative(), [scope.getVariable("event").getValue()]);scope.getVariable("container").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("Container"), []));scope.getVariable("container").getValue().callMethod(tools.valueFactory.createBarewordString("set").getNative(), [tools.valueFactory.createString("service.listener"), scope.getVariable("service").getValue()]);scope.getVariable("dispatcher").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("ContainerAwareEventDispatcher"), [scope.getVariable("container").getValue()]));scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("addListenerService").getNative(), [tools.valueFactory.createString("onEvent"), tools.valueFactory.createArray([tools.valueFactory.createString("service.listener"), tools.valueFactory.createString("onEvent")])]);scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("dispatch").getNative(), [tools.valueFactory.createString("onEvent"), scope.getVariable("event").getValue()]);}}, "testAddASubscriberService": {isStatic: false, method: function () {var scope = this;scope.getVariable("event").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("Event"), []));scope.getVariable("service").setValue(scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("getMock").getNative(), [tools.valueFactory.createString("Symfony\\Component\\EventDispatcher\\Tests\\SubscriberService")]));scope.getVariable("service").getValue().callMethod(tools.valueFactory.createBarewordString("expects").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("once").getNative(), [])]).callMethod(tools.valueFactory.createBarewordString("method").getNative(), [tools.valueFactory.createString("onEvent")]).callMethod(tools.valueFactory.createBarewordString("with").getNative(), [scope.getVariable("event").getValue()]);scope.getVariable("service").getValue().callMethod(tools.valueFactory.createBarewordString("expects").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("once").getNative(), [])]).callMethod(tools.valueFactory.createBarewordString("method").getNative(), [tools.valueFactory.createString("onEventWithPriority")]).callMethod(tools.valueFactory.createBarewordString("with").getNative(), [scope.getVariable("event").getValue()]);scope.getVariable("service").getValue().callMethod(tools.valueFactory.createBarewordString("expects").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("once").getNative(), [])]).callMethod(tools.valueFactory.createBarewordString("method").getNative(), [tools.valueFactory.createString("onEventNested")]).callMethod(tools.valueFactory.createBarewordString("with").getNative(), [scope.getVariable("event").getValue()]);scope.getVariable("container").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("Container"), []));scope.getVariable("container").getValue().callMethod(tools.valueFactory.createBarewordString("set").getNative(), [tools.valueFactory.createString("service.subscriber"), scope.getVariable("service").getValue()]);scope.getVariable("dispatcher").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("ContainerAwareEventDispatcher"), [scope.getVariable("container").getValue()]));scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("addSubscriberService").getNative(), [tools.valueFactory.createString("service.subscriber"), tools.valueFactory.createString("Symfony\\Component\\EventDispatcher\\Tests\\SubscriberService")]);scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("dispatch").getNative(), [tools.valueFactory.createString("onEvent"), scope.getVariable("event").getValue()]);scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("dispatch").getNative(), [tools.valueFactory.createString("onEventWithPriority"), scope.getVariable("event").getValue()]);scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("dispatch").getNative(), [tools.valueFactory.createString("onEventNested"), scope.getVariable("event").getValue()]);}}, "testPreventDuplicateListenerService": {isStatic: false, method: function () {var scope = this;scope.getVariable("event").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("Event"), []));scope.getVariable("service").setValue(scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("getMock").getNative(), [tools.valueFactory.createString("Symfony\\Component\\EventDispatcher\\Tests\\Service")]));scope.getVariable("service").getValue().callMethod(tools.valueFactory.createBarewordString("expects").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("once").getNative(), [])]).callMethod(tools.valueFactory.createBarewordString("method").getNative(), [tools.valueFactory.createString("onEvent")]).callMethod(tools.valueFactory.createBarewordString("with").getNative(), [scope.getVariable("event").getValue()]);scope.getVariable("container").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("Container"), []));scope.getVariable("container").getValue().callMethod(tools.valueFactory.createBarewordString("set").getNative(), [tools.valueFactory.createString("service.listener"), scope.getVariable("service").getValue()]);scope.getVariable("dispatcher").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("ContainerAwareEventDispatcher"), [scope.getVariable("container").getValue()]));scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("addListenerService").getNative(), [tools.valueFactory.createString("onEvent"), tools.valueFactory.createArray([tools.valueFactory.createString("service.listener"), tools.valueFactory.createString("onEvent")]), tools.valueFactory.createInteger(5)]);scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("addListenerService").getNative(), [tools.valueFactory.createString("onEvent"), tools.valueFactory.createArray([tools.valueFactory.createString("service.listener"), tools.valueFactory.createString("onEvent")]), tools.valueFactory.createInteger(10)]);scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("dispatch").getNative(), [tools.valueFactory.createString("onEvent"), scope.getVariable("event").getValue()]);}}, "testHasListenersOnLazyLoad": {isStatic: false, method: function () {var scope = this;scope.getVariable("event").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("Event"), []));scope.getVariable("service").setValue(scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("getMock").getNative(), [tools.valueFactory.createString("Symfony\\Component\\EventDispatcher\\Tests\\Service")]));scope.getVariable("container").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("Container"), []));scope.getVariable("container").getValue().callMethod(tools.valueFactory.createBarewordString("set").getNative(), [tools.valueFactory.createString("service.listener"), scope.getVariable("service").getValue()]);scope.getVariable("dispatcher").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("ContainerAwareEventDispatcher"), [scope.getVariable("container").getValue()]));scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("addListenerService").getNative(), [tools.valueFactory.createString("onEvent"), tools.valueFactory.createArray([tools.valueFactory.createString("service.listener"), tools.valueFactory.createString("onEvent")])]);scope.getVariable("service").getValue().callMethod(tools.valueFactory.createBarewordString("expects").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("once").getNative(), [])]).callMethod(tools.valueFactory.createBarewordString("method").getNative(), [tools.valueFactory.createString("onEvent")]).callMethod(tools.valueFactory.createBarewordString("with").getNative(), [scope.getVariable("event").getValue()]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertTrue").getNative(), [scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("hasListeners").getNative(), [])]);if (scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("hasListeners").getNative(), [tools.valueFactory.createString("onEvent")]).coerceToBoolean().getNative()) {scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("dispatch").getNative(), [tools.valueFactory.createString("onEvent")]);}}}, "testGetListenersOnLazyLoad": {isStatic: false, method: function () {var scope = this;scope.getVariable("service").setValue(scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("getMock").getNative(), [tools.valueFactory.createString("Symfony\\Component\\EventDispatcher\\Tests\\Service")]));scope.getVariable("container").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("Container"), []));scope.getVariable("container").getValue().callMethod(tools.valueFactory.createBarewordString("set").getNative(), [tools.valueFactory.createString("service.listener"), scope.getVariable("service").getValue()]);scope.getVariable("dispatcher").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("ContainerAwareEventDispatcher"), [scope.getVariable("container").getValue()]));scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("addListenerService").getNative(), [tools.valueFactory.createString("onEvent"), tools.valueFactory.createArray([tools.valueFactory.createString("service.listener"), tools.valueFactory.createString("onEvent")])]);scope.getVariable("listeners").setValue(scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("getListeners").getNative(), []));scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertTrue").getNative(), [(function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean(scope.getVariable("listeners").getValue().getElementByKey(tools.valueFactory.createString("onEvent")).isSet());scope.unsuppressOwnErrors(); return result;}(scope))]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertCount").getNative(), [tools.valueFactory.createInteger(1), scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("getListeners").getNative(), [tools.valueFactory.createString("onEvent")])]);}}, "testRemoveAfterDispatch": {isStatic: false, method: function () {var scope = this;scope.getVariable("service").setValue(scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("getMock").getNative(), [tools.valueFactory.createString("Symfony\\Component\\EventDispatcher\\Tests\\Service")]));scope.getVariable("container").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("Container"), []));scope.getVariable("container").getValue().callMethod(tools.valueFactory.createBarewordString("set").getNative(), [tools.valueFactory.createString("service.listener"), scope.getVariable("service").getValue()]);scope.getVariable("dispatcher").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("ContainerAwareEventDispatcher"), [scope.getVariable("container").getValue()]));scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("addListenerService").getNative(), [tools.valueFactory.createString("onEvent"), tools.valueFactory.createArray([tools.valueFactory.createString("service.listener"), tools.valueFactory.createString("onEvent")])]);scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("dispatch").getNative(), [tools.valueFactory.createString("onEvent"), tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("Event"), [])]);scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("removeListener").getNative(), [tools.valueFactory.createString("onEvent"), tools.valueFactory.createArray([scope.getVariable("container").getValue().callMethod(tools.valueFactory.createBarewordString("get").getNative(), [tools.valueFactory.createString("service.listener")]), tools.valueFactory.createString("onEvent")])]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertFalse").getNative(), [scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("hasListeners").getNative(), [tools.valueFactory.createString("onEvent")])]);}}, "testRemoveBeforeDispatch": {isStatic: false, method: function () {var scope = this;scope.getVariable("service").setValue(scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("getMock").getNative(), [tools.valueFactory.createString("Symfony\\Component\\EventDispatcher\\Tests\\Service")]));scope.getVariable("container").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("Container"), []));scope.getVariable("container").getValue().callMethod(tools.valueFactory.createBarewordString("set").getNative(), [tools.valueFactory.createString("service.listener"), scope.getVariable("service").getValue()]);scope.getVariable("dispatcher").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("ContainerAwareEventDispatcher"), [scope.getVariable("container").getValue()]));scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("addListenerService").getNative(), [tools.valueFactory.createString("onEvent"), tools.valueFactory.createArray([tools.valueFactory.createString("service.listener"), tools.valueFactory.createString("onEvent")])]);scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("removeListener").getNative(), [tools.valueFactory.createString("onEvent"), tools.valueFactory.createArray([scope.getVariable("container").getValue().callMethod(tools.valueFactory.createBarewordString("get").getNative(), [tools.valueFactory.createString("service.listener")]), tools.valueFactory.createString("onEvent")])]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertFalse").getNative(), [scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("hasListeners").getNative(), [tools.valueFactory.createString("onEvent")])]);}}}, constants: {}}, namespaceScope);}());(function () {var currentClass = namespace.defineClass("Service", {superClass: null, interfaces: [], staticProperties: {}, properties: {}, methods: {"onEvent": {isStatic: false, method: function ($e) {var scope = this;scope.getVariable("e").setValue($e.getValue());}}}, constants: {}}, namespaceScope);}());(function () {var currentClass = namespace.defineClass("SubscriberService", {superClass: null, interfaces: ["EventSubscriberInterface"], staticProperties: {}, properties: {}, methods: {"getSubscribedEvents": {isStatic: true, method: function () {var scope = this;return tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("onEvent"), tools.valueFactory.createString("onEvent")), tools.createKeyValuePair(tools.valueFactory.createString("onEventWithPriority"), tools.valueFactory.createArray([tools.valueFactory.createString("onEventWithPriority"), tools.valueFactory.createInteger(10)])), tools.createKeyValuePair(tools.valueFactory.createString("onEventNested"), tools.valueFactory.createArray([tools.valueFactory.createArray([tools.valueFactory.createString("onEventNested")])]))]);}}, "onEvent": {isStatic: false, method: function ($e) {var scope = this;scope.getVariable("e").setValue($e.getValue());}}, "onEventWithPriority": {isStatic: false, method: function ($e) {var scope = this;scope.getVariable("e").setValue($e.getValue());}}, "onEventNested": {isStatic: false, method: function ($e) {var scope = this;scope.getVariable("e").setValue($e.getValue());}}}, constants: {}}, namespaceScope);}());namespaceScope.use("Symfony\\Component\\DependencyInjection\\Container");namespaceScope.use("Symfony\\Component\\EventDispatcher\\ContainerAwareEventDispatcher");namespaceScope.use("Symfony\\Component\\EventDispatcher\\Event");namespaceScope.use("Symfony\\Component\\EventDispatcher\\EventSubscriberInterface");}(namespace))) { return namespaceResult; }return tools.valueFactory.createNull();}));
},{"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api":147,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime":153,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php":173}],194:[function(require,module,exports){
require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php");
module.exports = require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api").load("vendor/symfony/event-dispatcher/Tests/Debug/TraceableEventDispatcherTest.php", require('/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime').compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.createNamespaceScope(namespace), namespaceResult, scope = tools.topLevelScope, currentClass = null;if (namespaceResult = (function (globalNamespace) {var namespace = globalNamespace.getDescendant("Symfony\\Component\\EventDispatcher\\Tests\\Debug"), namespaceScope = tools.createNamespaceScope(namespace);(function () {var currentClass = namespace.defineClass("TraceableEventDispatcherTest", {superClass: namespaceScope.getClass("\\PHPUnit_Framework_TestCase"), interfaces: [], staticProperties: {}, properties: {}, methods: {"testAddRemoveListener": {isStatic: false, method: function () {var scope = this;scope.getVariable("dispatcher").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("EventDispatcher"), []));scope.getVariable("tdispatcher").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("TraceableEventDispatcher"), [scope.getVariable("dispatcher").getValue(), tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("Stopwatch"), [])]));scope.getVariable("tdispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("foo"), scope.getVariable("listener").setValue(tools.createClosure(function () {var scope = this;}, scope))]);scope.getVariable("listeners").setValue(scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("getListeners").getNative(), [tools.valueFactory.createString("foo")]));scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertCount").getNative(), [tools.valueFactory.createInteger(1), scope.getVariable("listeners").getValue()]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertSame").getNative(), [scope.getVariable("listener").getValue(), scope.getVariable("listeners").getValue().getElementByKey(tools.valueFactory.createInteger(0)).getValue()]);scope.getVariable("tdispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("removeListener").getNative(), [tools.valueFactory.createString("foo"), scope.getVariable("listener").getValue()]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertCount").getNative(), [tools.valueFactory.createInteger(0), scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("getListeners").getNative(), [tools.valueFactory.createString("foo")])]);}}, "testGetListeners": {isStatic: false, method: function () {var scope = this;scope.getVariable("dispatcher").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("EventDispatcher"), []));scope.getVariable("tdispatcher").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("TraceableEventDispatcher"), [scope.getVariable("dispatcher").getValue(), tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("Stopwatch"), [])]));scope.getVariable("tdispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("foo"), scope.getVariable("listener").setValue(tools.createClosure(function () {var scope = this;}, scope))]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertSame").getNative(), [scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("getListeners").getNative(), [tools.valueFactory.createString("foo")]), scope.getVariable("tdispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("getListeners").getNative(), [tools.valueFactory.createString("foo")])]);}}, "testHasListeners": {isStatic: false, method: function () {var scope = this;scope.getVariable("dispatcher").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("EventDispatcher"), []));scope.getVariable("tdispatcher").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("TraceableEventDispatcher"), [scope.getVariable("dispatcher").getValue(), tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("Stopwatch"), [])]));scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertFalse").getNative(), [scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("hasListeners").getNative(), [tools.valueFactory.createString("foo")])]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertFalse").getNative(), [scope.getVariable("tdispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("hasListeners").getNative(), [tools.valueFactory.createString("foo")])]);scope.getVariable("tdispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("foo"), scope.getVariable("listener").setValue(tools.createClosure(function () {var scope = this;}, scope))]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertTrue").getNative(), [scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("hasListeners").getNative(), [tools.valueFactory.createString("foo")])]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertTrue").getNative(), [scope.getVariable("tdispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("hasListeners").getNative(), [tools.valueFactory.createString("foo")])]);}}, "testGetListenerPriority": {isStatic: false, method: function () {var scope = this;scope.getVariable("dispatcher").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("EventDispatcher"), []));scope.getVariable("tdispatcher").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("TraceableEventDispatcher"), [scope.getVariable("dispatcher").getValue(), tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("Stopwatch"), [])]));scope.getVariable("tdispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("foo"), tools.createClosure(function () {var scope = this;}, scope), tools.valueFactory.createInteger(123)]);scope.getVariable("listeners").setValue(scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("getListeners").getNative(), [tools.valueFactory.createString("foo")]));scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertSame").getNative(), [tools.valueFactory.createInteger(123), scope.getVariable("tdispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("getListenerPriority").getNative(), [tools.valueFactory.createString("foo"), scope.getVariable("listeners").getValue().getElementByKey(tools.valueFactory.createInteger(0)).getValue()])]);scope.getVariable("tdispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("dispatch").getNative(), [tools.valueFactory.createString("foo"), tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("Event"), [])]);scope.getVariable("listeners").setValue(scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("getListeners").getNative(), [tools.valueFactory.createString("foo")]));scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertSame").getNative(), [tools.valueFactory.createInteger(123), scope.getVariable("tdispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("getListenerPriority").getNative(), [tools.valueFactory.createString("foo"), scope.getVariable("listeners").getValue().getElementByKey(tools.valueFactory.createInteger(0)).getValue()])]);}}, "testAddRemoveSubscriber": {isStatic: false, method: function () {var scope = this;scope.getVariable("dispatcher").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("EventDispatcher"), []));scope.getVariable("tdispatcher").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("TraceableEventDispatcher"), [scope.getVariable("dispatcher").getValue(), tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("Stopwatch"), [])]));scope.getVariable("subscriber").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("EventSubscriber"), []));scope.getVariable("tdispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("addSubscriber").getNative(), [scope.getVariable("subscriber").getValue()]);scope.getVariable("listeners").setValue(scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("getListeners").getNative(), [tools.valueFactory.createString("foo")]));scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertCount").getNative(), [tools.valueFactory.createInteger(1), scope.getVariable("listeners").getValue()]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertSame").getNative(), [tools.valueFactory.createArray([scope.getVariable("subscriber").getValue(), tools.valueFactory.createString("call")]), scope.getVariable("listeners").getValue().getElementByKey(tools.valueFactory.createInteger(0)).getValue()]);scope.getVariable("tdispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("removeSubscriber").getNative(), [scope.getVariable("subscriber").getValue()]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertCount").getNative(), [tools.valueFactory.createInteger(0), scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("getListeners").getNative(), [tools.valueFactory.createString("foo")])]);}}, "testGetCalledListeners": {isStatic: false, method: function () {var scope = this;scope.getVariable("dispatcher").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("EventDispatcher"), []));scope.getVariable("tdispatcher").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("TraceableEventDispatcher"), [scope.getVariable("dispatcher").getValue(), tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("Stopwatch"), [])]));scope.getVariable("tdispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("foo"), scope.getVariable("listener").setValue(tools.createClosure(function () {var scope = this;}, scope))]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertEquals").getNative(), [tools.valueFactory.createArray([]), scope.getVariable("tdispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("getCalledListeners").getNative(), [])]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertEquals").getNative(), [tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("foo.closure"), tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("event"), tools.valueFactory.createString("foo")), tools.createKeyValuePair(tools.valueFactory.createString("type"), tools.valueFactory.createString("Closure")), tools.createKeyValuePair(tools.valueFactory.createString("pretty"), tools.valueFactory.createString("closure")), tools.createKeyValuePair(tools.valueFactory.createString("priority"), tools.valueFactory.createInteger(0))]))]), scope.getVariable("tdispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("getNotCalledListeners").getNative(), [])]);scope.getVariable("tdispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("dispatch").getNative(), [tools.valueFactory.createString("foo")]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertEquals").getNative(), [tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("foo.closure"), tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("event"), tools.valueFactory.createString("foo")), tools.createKeyValuePair(tools.valueFactory.createString("type"), tools.valueFactory.createString("Closure")), tools.createKeyValuePair(tools.valueFactory.createString("pretty"), tools.valueFactory.createString("closure")), tools.createKeyValuePair(tools.valueFactory.createString("priority"), tools.valueFactory.createNull())]))]), scope.getVariable("tdispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("getCalledListeners").getNative(), [])]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertEquals").getNative(), [tools.valueFactory.createArray([]), scope.getVariable("tdispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("getNotCalledListeners").getNative(), [])]);}}, "testGetCalledListenersNested": {isStatic: false, method: function () {var scope = this;scope.getVariable("tdispatcher").setValue(tools.valueFactory.createNull());scope.getVariable("dispatcher").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("TraceableEventDispatcher"), [tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("EventDispatcher"), []), tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("Stopwatch"), [])]));scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("foo"), tools.createClosure((function (parentScope) { return function ($event, $eventName, $dispatcher) {var scope = this;scope.getVariable("event").setValue($event.getValue());scope.getVariable("eventName").setValue($eventName.getValue());scope.getVariable("dispatcher").setValue($dispatcher.getValue());scope.getVariable("tdispatcher").setReference(parentScope.getVariable("tdispatcher").getReference());scope.getVariable("tdispatcher").setValue(scope.getVariable("dispatcher").getValue());scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("dispatch").getNative(), [tools.valueFactory.createString("bar")]);}; }(scope)), scope)]);scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("bar"), tools.createClosure(function ($event) {var scope = this;scope.getVariable("event").setValue($event.getValue());}, scope)]);scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("dispatch").getNative(), [tools.valueFactory.createString("foo")]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertSame").getNative(), [scope.getVariable("dispatcher").getValue(), scope.getVariable("tdispatcher").getValue()]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertCount").getNative(), [tools.valueFactory.createInteger(2), scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("getCalledListeners").getNative(), [])]);}}, "testLogger": {isStatic: false, method: function () {var scope = this;scope.getVariable("logger").setValue(scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("getMock").getNative(), [tools.valueFactory.createString("Psr\\Log\\LoggerInterface")]));scope.getVariable("dispatcher").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("EventDispatcher"), []));scope.getVariable("tdispatcher").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("TraceableEventDispatcher"), [scope.getVariable("dispatcher").getValue(), tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("Stopwatch"), []), scope.getVariable("logger").getValue()]));scope.getVariable("tdispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("foo"), scope.getVariable("listener1").setValue(tools.createClosure(function () {var scope = this;}, scope))]);scope.getVariable("tdispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("foo"), scope.getVariable("listener2").setValue(tools.createClosure(function () {var scope = this;}, scope))]);scope.getVariable("logger").getValue().callMethod(tools.valueFactory.createBarewordString("expects").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("at").getNative(), [tools.valueFactory.createInteger(0)])]).callMethod(tools.valueFactory.createBarewordString("method").getNative(), [tools.valueFactory.createString("debug")]).callMethod(tools.valueFactory.createBarewordString("with").getNative(), [tools.valueFactory.createString("Notified event \"{event}\" to listener \"{listener}\"."), tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("event"), tools.valueFactory.createString("foo")), tools.createKeyValuePair(tools.valueFactory.createString("listener"), tools.valueFactory.createString("closure"))])]);scope.getVariable("logger").getValue().callMethod(tools.valueFactory.createBarewordString("expects").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("at").getNative(), [tools.valueFactory.createInteger(1)])]).callMethod(tools.valueFactory.createBarewordString("method").getNative(), [tools.valueFactory.createString("debug")]).callMethod(tools.valueFactory.createBarewordString("with").getNative(), [tools.valueFactory.createString("Notified event \"{event}\" to listener \"{listener}\"."), tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("event"), tools.valueFactory.createString("foo")), tools.createKeyValuePair(tools.valueFactory.createString("listener"), tools.valueFactory.createString("closure"))])]);scope.getVariable("tdispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("dispatch").getNative(), [tools.valueFactory.createString("foo")]);}}, "testLoggerWithStoppedEvent": {isStatic: false, method: function () {var scope = this;scope.getVariable("logger").setValue(scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("getMock").getNative(), [tools.valueFactory.createString("Psr\\Log\\LoggerInterface")]));scope.getVariable("dispatcher").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("EventDispatcher"), []));scope.getVariable("tdispatcher").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("TraceableEventDispatcher"), [scope.getVariable("dispatcher").getValue(), tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("Stopwatch"), []), scope.getVariable("logger").getValue()]));scope.getVariable("tdispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("foo"), scope.getVariable("listener1").setValue(tools.createClosure(function ($event) {var scope = this;scope.getVariable("event").setValue($event.getValue());scope.getVariable("event").getValue().callMethod(tools.valueFactory.createBarewordString("stopPropagation").getNative(), []);}, scope))]);scope.getVariable("tdispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("foo"), scope.getVariable("listener2").setValue(tools.createClosure(function () {var scope = this;}, scope))]);scope.getVariable("logger").getValue().callMethod(tools.valueFactory.createBarewordString("expects").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("at").getNative(), [tools.valueFactory.createInteger(0)])]).callMethod(tools.valueFactory.createBarewordString("method").getNative(), [tools.valueFactory.createString("debug")]).callMethod(tools.valueFactory.createBarewordString("with").getNative(), [tools.valueFactory.createString("Notified event \"{event}\" to listener \"{listener}\"."), tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("event"), tools.valueFactory.createString("foo")), tools.createKeyValuePair(tools.valueFactory.createString("listener"), tools.valueFactory.createString("closure"))])]);scope.getVariable("logger").getValue().callMethod(tools.valueFactory.createBarewordString("expects").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("at").getNative(), [tools.valueFactory.createInteger(1)])]).callMethod(tools.valueFactory.createBarewordString("method").getNative(), [tools.valueFactory.createString("debug")]).callMethod(tools.valueFactory.createBarewordString("with").getNative(), [tools.valueFactory.createString("Listener \"{listener}\" stopped propagation of the event \"{event}\"."), tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("event"), tools.valueFactory.createString("foo")), tools.createKeyValuePair(tools.valueFactory.createString("listener"), tools.valueFactory.createString("closure"))])]);scope.getVariable("logger").getValue().callMethod(tools.valueFactory.createBarewordString("expects").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("at").getNative(), [tools.valueFactory.createInteger(2)])]).callMethod(tools.valueFactory.createBarewordString("method").getNative(), [tools.valueFactory.createString("debug")]).callMethod(tools.valueFactory.createBarewordString("with").getNative(), [tools.valueFactory.createString("Listener \"{listener}\" was not called for event \"{event}\"."), tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("event"), tools.valueFactory.createString("foo")), tools.createKeyValuePair(tools.valueFactory.createString("listener"), tools.valueFactory.createString("closure"))])]);scope.getVariable("tdispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("dispatch").getNative(), [tools.valueFactory.createString("foo")]);}}, "testDispatchCallListeners": {isStatic: false, method: function () {var scope = this;scope.getVariable("called").setValue(tools.valueFactory.createArray([]));scope.getVariable("dispatcher").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("EventDispatcher"), []));scope.getVariable("tdispatcher").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("TraceableEventDispatcher"), [scope.getVariable("dispatcher").getValue(), tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("Stopwatch"), [])]));scope.getVariable("tdispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("foo"), tools.createClosure((function (parentScope) { return function () {var scope = this;scope.getVariable("called").setReference(parentScope.getVariable("called").getReference());tools.implyArray(scope.getVariable("called")).getPushElement().setValue(tools.valueFactory.createString("foo1"));}; }(scope)), scope), tools.valueFactory.createInteger(10)]);scope.getVariable("tdispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("foo"), tools.createClosure((function (parentScope) { return function () {var scope = this;scope.getVariable("called").setReference(parentScope.getVariable("called").getReference());tools.implyArray(scope.getVariable("called")).getPushElement().setValue(tools.valueFactory.createString("foo2"));}; }(scope)), scope), tools.valueFactory.createInteger(20)]);scope.getVariable("tdispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("dispatch").getNative(), [tools.valueFactory.createString("foo")]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertSame").getNative(), [tools.valueFactory.createArray([tools.valueFactory.createString("foo2"), tools.valueFactory.createString("foo1")]), scope.getVariable("called").getValue()]);}}, "testDispatchNested": {isStatic: false, method: function () {var scope = this;scope.getVariable("dispatcher").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("TraceableEventDispatcher"), [tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("EventDispatcher"), []), tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("Stopwatch"), [])]));scope.getVariable("loop").setValue(tools.valueFactory.createInteger(1));scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("foo"), scope.getVariable("listener1").setValue(tools.createClosure((function (parentScope) { return function () {var scope = this;scope.getVariable("dispatcher").setValue(parentScope.getVariable("dispatcher").getValue());scope.getVariable("loop").setReference(parentScope.getVariable("loop").getReference());scope.getVariable("loop").preIncrement();if (tools.valueFactory.createInteger(2).isEqualTo(scope.getVariable("loop").getValue()).coerceToBoolean().getNative()) {scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("dispatch").getNative(), [tools.valueFactory.createString("foo")]);}}; }(scope)), scope))]);scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("dispatch").getNative(), [tools.valueFactory.createString("foo")]);}}, "testDispatchReusedEventNested": {isStatic: false, method: function () {var scope = this;scope.getVariable("nestedCall").setValue(tools.valueFactory.createBoolean(false));scope.getVariable("dispatcher").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("TraceableEventDispatcher"), [tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("EventDispatcher"), []), tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("Stopwatch"), [])]));scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("foo"), tools.createClosure((function (parentScope) { return function ($e) {var scope = this;scope.getVariable("e").setValue($e.getValue());scope.getVariable("dispatcher").setValue(parentScope.getVariable("dispatcher").getValue());scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("dispatch").getNative(), [tools.valueFactory.createString("bar"), scope.getVariable("e").getValue()]);}; }(scope)), scope)]);scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("bar"), tools.createClosure((function (parentScope) { return function ($e) {var scope = this;scope.getVariable("e").setValue($e.getValue());scope.getVariable("nestedCall").setReference(parentScope.getVariable("nestedCall").getReference());scope.getVariable("nestedCall").setValue(tools.valueFactory.createBoolean(true));}; }(scope)), scope)]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertFalse").getNative(), [scope.getVariable("nestedCall").getValue()]);scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("dispatch").getNative(), [tools.valueFactory.createString("foo")]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertTrue").getNative(), [scope.getVariable("nestedCall").getValue()]);}}, "testListenerCanRemoveItselfWhenExecuted": {isStatic: false, method: function () {var scope = this;scope.getVariable("eventDispatcher").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("TraceableEventDispatcher"), [tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("EventDispatcher"), []), tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("Stopwatch"), [])]));scope.getVariable("listener1").setValue(tools.createClosure((function (parentScope) { return function ($event, $eventName, $dispatcher) {var scope = this;scope.getVariable("event").setValue($event.getValue());scope.getVariable("eventName").setValue($eventName.getValue());scope.getVariable("dispatcher").setValue($dispatcher.getValue());scope.getVariable("listener1").setReference(parentScope.getVariable("listener1").getReference());scope.getVariable("dispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("removeListener").getNative(), [tools.valueFactory.createString("foo"), scope.getVariable("listener1").getValue()]);}; }(scope)), scope));scope.getVariable("eventDispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("foo"), scope.getVariable("listener1").getValue()]);scope.getVariable("eventDispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("foo"), tools.createClosure(function () {var scope = this;}, scope)]);scope.getVariable("eventDispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("dispatch").getNative(), [tools.valueFactory.createString("foo")]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertCount").getNative(), [tools.valueFactory.createInteger(1), scope.getVariable("eventDispatcher").getValue().callMethod(tools.valueFactory.createBarewordString("getListeners").getNative(), [tools.valueFactory.createString("foo")]), tools.valueFactory.createString("expected listener1 to be removed")]);}}}, constants: {}}, namespaceScope);}());(function () {var currentClass = namespace.defineClass("EventSubscriber", {superClass: null, interfaces: ["EventSubscriberInterface"], staticProperties: {}, properties: {}, methods: {"getSubscribedEvents": {isStatic: true, method: function () {var scope = this;return tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("foo"), tools.valueFactory.createString("call"))]);}}}, constants: {}}, namespaceScope);}());namespaceScope.use("Symfony\\Component\\EventDispatcher\\Debug\\TraceableEventDispatcher");namespaceScope.use("Symfony\\Component\\EventDispatcher\\EventDispatcherInterface");namespaceScope.use("Symfony\\Component\\EventDispatcher\\EventSubscriberInterface");namespaceScope.use("Symfony\\Component\\EventDispatcher\\EventDispatcher");namespaceScope.use("Symfony\\Component\\EventDispatcher\\Event");namespaceScope.use("Symfony\\Component\\Stopwatch\\Stopwatch");}(namespace))) { return namespaceResult; }return tools.valueFactory.createNull();}));
},{"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api":147,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime":153,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php":173}],195:[function(require,module,exports){
require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php");
module.exports = require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api").load("vendor/symfony/event-dispatcher/Tests/DependencyInjection/RegisterListenersPassTest.php", require('/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime').compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.createNamespaceScope(namespace), namespaceResult, scope = tools.topLevelScope, currentClass = null;if (namespaceResult = (function (globalNamespace) {var namespace = globalNamespace.getDescendant("Symfony\\Component\\EventDispatcher\\Tests\\DependencyInjection"), namespaceScope = tools.createNamespaceScope(namespace);(function () {var currentClass = namespace.defineClass("RegisterListenersPassTest", {superClass: namespaceScope.getClass("\\PHPUnit_Framework_TestCase"), interfaces: [], staticProperties: {}, properties: {}, methods: {"testEventSubscriberWithoutInterface": {isStatic: false, method: function () {var scope = this;scope.getVariable("services").setValue(tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("my_event_subscriber"), tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createInteger(0), tools.valueFactory.createArray([]))]))]));scope.getVariable("definition").setValue(scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("getMock").getNative(), [tools.valueFactory.createString("Symfony\\Component\\DependencyInjection\\Definition")]));scope.getVariable("definition").getValue().callMethod(tools.valueFactory.createBarewordString("expects").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("atLeastOnce").getNative(), [])]).callMethod(tools.valueFactory.createBarewordString("method").getNative(), [tools.valueFactory.createString("isPublic")]).callMethod(tools.valueFactory.createBarewordString("will").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("returnValue").getNative(), [tools.valueFactory.createBoolean(true)])]);scope.getVariable("definition").getValue().callMethod(tools.valueFactory.createBarewordString("expects").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("atLeastOnce").getNative(), [])]).callMethod(tools.valueFactory.createBarewordString("method").getNative(), [tools.valueFactory.createString("getClass")]).callMethod(tools.valueFactory.createBarewordString("will").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("returnValue").getNative(), [tools.valueFactory.createString("stdClass")])]);scope.getVariable("builder").setValue(scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("getMock").getNative(), [tools.valueFactory.createString("Symfony\\Component\\DependencyInjection\\ContainerBuilder"), tools.valueFactory.createArray([tools.valueFactory.createString("hasDefinition"), tools.valueFactory.createString("findTaggedServiceIds"), tools.valueFactory.createString("getDefinition")])]));scope.getVariable("builder").getValue().callMethod(tools.valueFactory.createBarewordString("expects").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("any").getNative(), [])]).callMethod(tools.valueFactory.createBarewordString("method").getNative(), [tools.valueFactory.createString("hasDefinition")]).callMethod(tools.valueFactory.createBarewordString("will").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("returnValue").getNative(), [tools.valueFactory.createBoolean(true)])]);scope.getVariable("builder").getValue().callMethod(tools.valueFactory.createBarewordString("expects").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("atLeastOnce").getNative(), [])]).callMethod(tools.valueFactory.createBarewordString("method").getNative(), [tools.valueFactory.createString("findTaggedServiceIds")]).callMethod(tools.valueFactory.createBarewordString("will").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("onConsecutiveCalls").getNative(), [tools.valueFactory.createArray([]), scope.getVariable("services").getValue()])]);scope.getVariable("builder").getValue().callMethod(tools.valueFactory.createBarewordString("expects").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("atLeastOnce").getNative(), [])]).callMethod(tools.valueFactory.createBarewordString("method").getNative(), [tools.valueFactory.createString("getDefinition")]).callMethod(tools.valueFactory.createBarewordString("will").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("returnValue").getNative(), [scope.getVariable("definition").getValue()])]);scope.getVariable("registerListenersPass").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("RegisterListenersPass"), []));scope.getVariable("registerListenersPass").getValue().callMethod(tools.valueFactory.createBarewordString("process").getNative(), [scope.getVariable("builder").getValue()]);}}, "testValidEventSubscriber": {isStatic: false, method: function () {var scope = this;scope.getVariable("services").setValue(tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("my_event_subscriber"), tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createInteger(0), tools.valueFactory.createArray([]))]))]));scope.getVariable("definition").setValue(scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("getMock").getNative(), [tools.valueFactory.createString("Symfony\\Component\\DependencyInjection\\Definition")]));scope.getVariable("definition").getValue().callMethod(tools.valueFactory.createBarewordString("expects").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("atLeastOnce").getNative(), [])]).callMethod(tools.valueFactory.createBarewordString("method").getNative(), [tools.valueFactory.createString("isPublic")]).callMethod(tools.valueFactory.createBarewordString("will").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("returnValue").getNative(), [tools.valueFactory.createBoolean(true)])]);scope.getVariable("definition").getValue().callMethod(tools.valueFactory.createBarewordString("expects").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("atLeastOnce").getNative(), [])]).callMethod(tools.valueFactory.createBarewordString("method").getNative(), [tools.valueFactory.createString("getClass")]).callMethod(tools.valueFactory.createBarewordString("will").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("returnValue").getNative(), [tools.valueFactory.createString("Symfony\\Component\\EventDispatcher\\Tests\\DependencyInjection\\SubscriberService")])]);scope.getVariable("builder").setValue(scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("getMock").getNative(), [tools.valueFactory.createString("Symfony\\Component\\DependencyInjection\\ContainerBuilder"), tools.valueFactory.createArray([tools.valueFactory.createString("hasDefinition"), tools.valueFactory.createString("findTaggedServiceIds"), tools.valueFactory.createString("getDefinition"), tools.valueFactory.createString("findDefinition")])]));scope.getVariable("builder").getValue().callMethod(tools.valueFactory.createBarewordString("expects").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("any").getNative(), [])]).callMethod(tools.valueFactory.createBarewordString("method").getNative(), [tools.valueFactory.createString("hasDefinition")]).callMethod(tools.valueFactory.createBarewordString("will").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("returnValue").getNative(), [tools.valueFactory.createBoolean(true)])]);scope.getVariable("builder").getValue().callMethod(tools.valueFactory.createBarewordString("expects").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("atLeastOnce").getNative(), [])]).callMethod(tools.valueFactory.createBarewordString("method").getNative(), [tools.valueFactory.createString("findTaggedServiceIds")]).callMethod(tools.valueFactory.createBarewordString("will").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("onConsecutiveCalls").getNative(), [tools.valueFactory.createArray([]), scope.getVariable("services").getValue()])]);scope.getVariable("builder").getValue().callMethod(tools.valueFactory.createBarewordString("expects").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("atLeastOnce").getNative(), [])]).callMethod(tools.valueFactory.createBarewordString("method").getNative(), [tools.valueFactory.createString("getDefinition")]).callMethod(tools.valueFactory.createBarewordString("will").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("returnValue").getNative(), [scope.getVariable("definition").getValue()])]);scope.getVariable("builder").getValue().callMethod(tools.valueFactory.createBarewordString("expects").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("atLeastOnce").getNative(), [])]).callMethod(tools.valueFactory.createBarewordString("method").getNative(), [tools.valueFactory.createString("findDefinition")]).callMethod(tools.valueFactory.createBarewordString("will").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("returnValue").getNative(), [scope.getVariable("definition").getValue()])]);scope.getVariable("registerListenersPass").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("RegisterListenersPass"), []));scope.getVariable("registerListenersPass").getValue().callMethod(tools.valueFactory.createBarewordString("process").getNative(), [scope.getVariable("builder").getValue()]);}}, "testPrivateEventListener": {isStatic: false, method: function () {var scope = this;scope.getVariable("container").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("ContainerBuilder"), []));scope.getVariable("container").getValue().callMethod(tools.valueFactory.createBarewordString("register").getNative(), [tools.valueFactory.createString("foo"), tools.valueFactory.createString("stdClass")]).callMethod(tools.valueFactory.createBarewordString("setPublic").getNative(), [tools.valueFactory.createBoolean(false)]).callMethod(tools.valueFactory.createBarewordString("addTag").getNative(), [tools.valueFactory.createString("kernel.event_listener"), tools.valueFactory.createArray([])]);scope.getVariable("container").getValue().callMethod(tools.valueFactory.createBarewordString("register").getNative(), [tools.valueFactory.createString("event_dispatcher"), tools.valueFactory.createString("stdClass")]);scope.getVariable("registerListenersPass").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("RegisterListenersPass"), []));scope.getVariable("registerListenersPass").getValue().callMethod(tools.valueFactory.createBarewordString("process").getNative(), [scope.getVariable("container").getValue()]);}}, "testPrivateEventSubscriber": {isStatic: false, method: function () {var scope = this;scope.getVariable("container").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("ContainerBuilder"), []));scope.getVariable("container").getValue().callMethod(tools.valueFactory.createBarewordString("register").getNative(), [tools.valueFactory.createString("foo"), tools.valueFactory.createString("stdClass")]).callMethod(tools.valueFactory.createBarewordString("setPublic").getNative(), [tools.valueFactory.createBoolean(false)]).callMethod(tools.valueFactory.createBarewordString("addTag").getNative(), [tools.valueFactory.createString("kernel.event_subscriber"), tools.valueFactory.createArray([])]);scope.getVariable("container").getValue().callMethod(tools.valueFactory.createBarewordString("register").getNative(), [tools.valueFactory.createString("event_dispatcher"), tools.valueFactory.createString("stdClass")]);scope.getVariable("registerListenersPass").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("RegisterListenersPass"), []));scope.getVariable("registerListenersPass").getValue().callMethod(tools.valueFactory.createBarewordString("process").getNative(), [scope.getVariable("container").getValue()]);}}, "testAbstractEventListener": {isStatic: false, method: function () {var scope = this;scope.getVariable("container").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("ContainerBuilder"), []));scope.getVariable("container").getValue().callMethod(tools.valueFactory.createBarewordString("register").getNative(), [tools.valueFactory.createString("foo"), tools.valueFactory.createString("stdClass")]).callMethod(tools.valueFactory.createBarewordString("setAbstract").getNative(), [tools.valueFactory.createBoolean(true)]).callMethod(tools.valueFactory.createBarewordString("addTag").getNative(), [tools.valueFactory.createString("kernel.event_listener"), tools.valueFactory.createArray([])]);scope.getVariable("container").getValue().callMethod(tools.valueFactory.createBarewordString("register").getNative(), [tools.valueFactory.createString("event_dispatcher"), tools.valueFactory.createString("stdClass")]);scope.getVariable("registerListenersPass").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("RegisterListenersPass"), []));scope.getVariable("registerListenersPass").getValue().callMethod(tools.valueFactory.createBarewordString("process").getNative(), [scope.getVariable("container").getValue()]);}}, "testAbstractEventSubscriber": {isStatic: false, method: function () {var scope = this;scope.getVariable("container").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("ContainerBuilder"), []));scope.getVariable("container").getValue().callMethod(tools.valueFactory.createBarewordString("register").getNative(), [tools.valueFactory.createString("foo"), tools.valueFactory.createString("stdClass")]).callMethod(tools.valueFactory.createBarewordString("setAbstract").getNative(), [tools.valueFactory.createBoolean(true)]).callMethod(tools.valueFactory.createBarewordString("addTag").getNative(), [tools.valueFactory.createString("kernel.event_subscriber"), tools.valueFactory.createArray([])]);scope.getVariable("container").getValue().callMethod(tools.valueFactory.createBarewordString("register").getNative(), [tools.valueFactory.createString("event_dispatcher"), tools.valueFactory.createString("stdClass")]);scope.getVariable("registerListenersPass").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("RegisterListenersPass"), []));scope.getVariable("registerListenersPass").getValue().callMethod(tools.valueFactory.createBarewordString("process").getNative(), [scope.getVariable("container").getValue()]);}}, "testEventSubscriberResolvableClassName": {isStatic: false, method: function () {var scope = this;scope.getVariable("container").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("ContainerBuilder"), []));scope.getVariable("container").getValue().callMethod(tools.valueFactory.createBarewordString("setParameter").getNative(), [tools.valueFactory.createString("subscriber.class"), tools.valueFactory.createString("Symfony\\Component\\EventDispatcher\\Tests\\DependencyInjection\\SubscriberService")]);scope.getVariable("container").getValue().callMethod(tools.valueFactory.createBarewordString("register").getNative(), [tools.valueFactory.createString("foo"), tools.valueFactory.createString("%subscriber.class%")]).callMethod(tools.valueFactory.createBarewordString("addTag").getNative(), [tools.valueFactory.createString("kernel.event_subscriber"), tools.valueFactory.createArray([])]);scope.getVariable("container").getValue().callMethod(tools.valueFactory.createBarewordString("register").getNative(), [tools.valueFactory.createString("event_dispatcher"), tools.valueFactory.createString("stdClass")]);scope.getVariable("registerListenersPass").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("RegisterListenersPass"), []));scope.getVariable("registerListenersPass").getValue().callMethod(tools.valueFactory.createBarewordString("process").getNative(), [scope.getVariable("container").getValue()]);scope.getVariable("definition").setValue(scope.getVariable("container").getValue().callMethod(tools.valueFactory.createBarewordString("getDefinition").getNative(), [tools.valueFactory.createString("event_dispatcher")]));scope.getVariable("expected_calls").setValue(tools.valueFactory.createArray([tools.valueFactory.createArray([tools.valueFactory.createString("addSubscriberService"), tools.valueFactory.createArray([tools.valueFactory.createString("foo"), tools.valueFactory.createString("Symfony\\Component\\EventDispatcher\\Tests\\DependencyInjection\\SubscriberService")])])]));scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertSame").getNative(), [scope.getVariable("expected_calls").getValue(), scope.getVariable("definition").getValue().callMethod(tools.valueFactory.createBarewordString("getMethodCalls").getNative(), [])]);}}, "testEventSubscriberUnresolvableClassName": {isStatic: false, method: function () {var scope = this;scope.getVariable("container").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("ContainerBuilder"), []));scope.getVariable("container").getValue().callMethod(tools.valueFactory.createBarewordString("register").getNative(), [tools.valueFactory.createString("foo"), tools.valueFactory.createString("%subscriber.class%")]).callMethod(tools.valueFactory.createBarewordString("addTag").getNative(), [tools.valueFactory.createString("kernel.event_subscriber"), tools.valueFactory.createArray([])]);scope.getVariable("container").getValue().callMethod(tools.valueFactory.createBarewordString("register").getNative(), [tools.valueFactory.createString("event_dispatcher"), tools.valueFactory.createString("stdClass")]);scope.getVariable("registerListenersPass").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("RegisterListenersPass"), []));scope.getVariable("registerListenersPass").getValue().callMethod(tools.valueFactory.createBarewordString("process").getNative(), [scope.getVariable("container").getValue()]);}}}, constants: {}}, namespaceScope);}());(function () {var currentClass = namespace.defineClass("SubscriberService", {superClass: null, interfaces: ["\\Symfony\\Component\\EventDispatcher\\EventSubscriberInterface"], staticProperties: {}, properties: {}, methods: {"getSubscribedEvents": {isStatic: true, method: function () {var scope = this;}}}, constants: {}}, namespaceScope);}());namespaceScope.use("Symfony\\Component\\DependencyInjection\\ContainerBuilder");namespaceScope.use("Symfony\\Component\\EventDispatcher\\DependencyInjection\\RegisterListenersPass");}(namespace))) { return namespaceResult; }return tools.valueFactory.createNull();}));
},{"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api":147,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime":153,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php":173}],196:[function(require,module,exports){
require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php");
module.exports = require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api").load("vendor/symfony/event-dispatcher/Tests/EventDispatcherTest.php", require('/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime').compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.createNamespaceScope(namespace), namespaceResult, scope = tools.topLevelScope, currentClass = null;if (namespaceResult = (function (globalNamespace) {var namespace = globalNamespace.getDescendant("Symfony\\Component\\EventDispatcher\\Tests"), namespaceScope = tools.createNamespaceScope(namespace);(function () {var currentClass = namespace.defineClass("EventDispatcherTest", {superClass: namespaceScope.getClass("AbstractEventDispatcherTest"), interfaces: [], staticProperties: {}, properties: {}, methods: {"createEventDispatcher": {isStatic: false, method: function () {var scope = this;return tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("EventDispatcher"), []);}}}, constants: {}}, namespaceScope);}());namespaceScope.use("Symfony\\Component\\EventDispatcher\\EventDispatcher");}(namespace))) { return namespaceResult; }return tools.valueFactory.createNull();}));
},{"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api":147,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime":153,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php":173}],197:[function(require,module,exports){
require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php");
module.exports = require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api").load("vendor/symfony/event-dispatcher/Tests/EventTest.php", require('/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime').compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.createNamespaceScope(namespace), namespaceResult, scope = tools.topLevelScope, currentClass = null;if (namespaceResult = (function (globalNamespace) {var namespace = globalNamespace.getDescendant("Symfony\\Component\\EventDispatcher\\Tests"), namespaceScope = tools.createNamespaceScope(namespace);(function () {var currentClass = namespace.defineClass("EventTest", {superClass: namespaceScope.getClass("\\PHPUnit_Framework_TestCase"), interfaces: [], staticProperties: {}, properties: {"event": null}, methods: {"setUp": {isStatic: false, method: function () {var scope = this;tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("event")).setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("Event"), []));}}, "tearDown": {isStatic: false, method: function () {var scope = this;tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("event")).setValue(tools.valueFactory.createNull());}}, "testIsPropagationStopped": {isStatic: false, method: function () {var scope = this;scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertFalse").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("event")).getValue().callMethod(tools.valueFactory.createBarewordString("isPropagationStopped").getNative(), [])]);}}, "testStopPropagationAndIsPropagationStopped": {isStatic: false, method: function () {var scope = this;scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("event")).getValue().callMethod(tools.valueFactory.createBarewordString("stopPropagation").getNative(), []);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertTrue").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("event")).getValue().callMethod(tools.valueFactory.createBarewordString("isPropagationStopped").getNative(), [])]);}}}, constants: {}}, namespaceScope);}());namespaceScope.use("Symfony\\Component\\EventDispatcher\\Event");}(namespace))) { return namespaceResult; }return tools.valueFactory.createNull();}));
},{"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api":147,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime":153,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php":173}],198:[function(require,module,exports){
require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php");
module.exports = require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api").load("vendor/symfony/event-dispatcher/Tests/GenericEventTest.php", require('/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime').compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.createNamespaceScope(namespace), namespaceResult, scope = tools.topLevelScope, currentClass = null;if (namespaceResult = (function (globalNamespace) {var namespace = globalNamespace.getDescendant("Symfony\\Component\\EventDispatcher\\Tests"), namespaceScope = tools.createNamespaceScope(namespace);(function () {var currentClass = namespace.defineClass("GenericEventTest", {superClass: namespaceScope.getClass("\\PHPUnit_Framework_TestCase"), interfaces: [], staticProperties: {}, properties: {"event": null, "subject": null}, methods: {"setUp": {isStatic: false, method: function () {var scope = this;tools.valueFactory.createBarewordString("parent").callStaticMethod(tools.valueFactory.createBarewordString("setUp"), [], namespaceScope);tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("subject")).setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("\\stdClass"), []));tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("event")).setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("GenericEvent"), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("subject")).getValue(), tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("name"), tools.valueFactory.createString("Event"))])]));}}, "tearDown": {isStatic: false, method: function () {var scope = this;tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("subject")).setValue(tools.valueFactory.createNull());tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("event")).setValue(tools.valueFactory.createNull());tools.valueFactory.createBarewordString("parent").callStaticMethod(tools.valueFactory.createBarewordString("tearDown"), [], namespaceScope);}}, "testConstruct": {isStatic: false, method: function () {var scope = this;scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertEquals").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("event")).getValue(), tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("GenericEvent"), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("subject")).getValue(), tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("name"), tools.valueFactory.createString("Event"))])])]);}}, "testGetArguments": {isStatic: false, method: function () {var scope = this;scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertSame").getNative(), [tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("name"), tools.valueFactory.createString("Event"))]), scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("event")).getValue().callMethod(tools.valueFactory.createBarewordString("getArguments").getNative(), [])]);}}, "testSetArguments": {isStatic: false, method: function () {var scope = this;scope.getVariable("result").setValue(scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("event")).getValue().callMethod(tools.valueFactory.createBarewordString("setArguments").getNative(), [tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("foo"), tools.valueFactory.createString("bar"))])]));scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertAttributeSame").getNative(), [tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("foo"), tools.valueFactory.createString("bar"))]), tools.valueFactory.createString("arguments"), scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("event")).getValue()]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertSame").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("event")).getValue(), scope.getVariable("result").getValue()]);}}, "testSetArgument": {isStatic: false, method: function () {var scope = this;scope.getVariable("result").setValue(scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("event")).getValue().callMethod(tools.valueFactory.createBarewordString("setArgument").getNative(), [tools.valueFactory.createString("foo2"), tools.valueFactory.createString("bar2")]));scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertAttributeSame").getNative(), [tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("name"), tools.valueFactory.createString("Event")), tools.createKeyValuePair(tools.valueFactory.createString("foo2"), tools.valueFactory.createString("bar2"))]), tools.valueFactory.createString("arguments"), scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("event")).getValue()]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertEquals").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("event")).getValue(), scope.getVariable("result").getValue()]);}}, "testGetArgument": {isStatic: false, method: function () {var scope = this;scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertEquals").getNative(), [tools.valueFactory.createString("Event"), scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("event")).getValue().callMethod(tools.valueFactory.createBarewordString("getArgument").getNative(), [tools.valueFactory.createString("name")])]);}}, "testGetArgException": {isStatic: false, method: function () {var scope = this;scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("event")).getValue().callMethod(tools.valueFactory.createBarewordString("getArgument").getNative(), [tools.valueFactory.createString("nameNotExist")]);}}, "testOffsetGet": {isStatic: false, method: function () {var scope = this;scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertEquals").getNative(), [tools.valueFactory.createString("Event"), scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("event")).getValue().getElementByKey(tools.valueFactory.createString("name")).getValue()]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("setExpectedException").getNative(), [tools.valueFactory.createString("InvalidArgumentException")]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertFalse").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("event")).getValue().getElementByKey(tools.valueFactory.createString("nameNotExist")).getValue()]);}}, "testOffsetSet": {isStatic: false, method: function () {var scope = this;tools.implyArray(tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("event"))).getElementByKey(tools.valueFactory.createString("foo2")).setValue(tools.valueFactory.createString("bar2"));scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertAttributeSame").getNative(), [tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("name"), tools.valueFactory.createString("Event")), tools.createKeyValuePair(tools.valueFactory.createString("foo2"), tools.valueFactory.createString("bar2"))]), tools.valueFactory.createString("arguments"), scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("event")).getValue()]);}}, "testOffsetUnset": {isStatic: false, method: function () {var scope = this;scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("event")).getValue().getElementByKey(tools.valueFactory.createString("name")).unset();scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertAttributeSame").getNative(), [tools.valueFactory.createArray([]), tools.valueFactory.createString("arguments"), scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("event")).getValue()]);}}, "testOffsetIsset": {isStatic: false, method: function () {var scope = this;scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertTrue").getNative(), [(function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean(scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("event")).getValue().getElementByKey(tools.valueFactory.createString("name")).isSet());scope.unsuppressOwnErrors(); return result;}(scope))]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertFalse").getNative(), [(function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean(scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("event")).getValue().getElementByKey(tools.valueFactory.createString("nameNotExist")).isSet());scope.unsuppressOwnErrors(); return result;}(scope))]);}}, "testHasArgument": {isStatic: false, method: function () {var scope = this;scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertTrue").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("event")).getValue().callMethod(tools.valueFactory.createBarewordString("hasArgument").getNative(), [tools.valueFactory.createString("name")])]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertFalse").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("event")).getValue().callMethod(tools.valueFactory.createBarewordString("hasArgument").getNative(), [tools.valueFactory.createString("nameNotExist")])]);}}, "testGetSubject": {isStatic: false, method: function () {var scope = this;scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertSame").getNative(), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("subject")).getValue(), scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("event")).getValue().callMethod(tools.valueFactory.createBarewordString("getSubject").getNative(), [])]);}}, "testHasIterator": {isStatic: false, method: function () {var scope = this;scope.getVariable("data").setValue(tools.valueFactory.createArray([]));var array_1 = scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("event")).getValue().reset();var length_1 = array_1.getLength();var pointer_1 = 0;block_1: while (pointer_1 < length_1) {scope.getVariable("key").setValue(array_1.getKeyByIndex(pointer_1));scope.getVariable("value").setValue(array_1.getElementByIndex(pointer_1).getValue());pointer_1++;tools.implyArray(scope.getVariable("data")).getElementByKey(scope.getVariable("key").getValue()).setValue(scope.getVariable("value").getValue());}scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertEquals").getNative(), [tools.valueFactory.createArray([tools.createKeyValuePair(tools.valueFactory.createString("name"), tools.valueFactory.createString("Event"))]), scope.getVariable("data").getValue()]);}}}, constants: {}}, namespaceScope);}());namespaceScope.use("Symfony\\Component\\EventDispatcher\\GenericEvent");}(namespace))) { return namespaceResult; }return tools.valueFactory.createNull();}));
},{"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api":147,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime":153,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php":173}],199:[function(require,module,exports){
require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php");
module.exports = require("/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api").load("vendor/symfony/event-dispatcher/Tests/ImmutableEventDispatcherTest.php", require('/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime').compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.createNamespaceScope(namespace), namespaceResult, scope = tools.topLevelScope, currentClass = null;if (namespaceResult = (function (globalNamespace) {var namespace = globalNamespace.getDescendant("Symfony\\Component\\EventDispatcher\\Tests"), namespaceScope = tools.createNamespaceScope(namespace);(function () {var currentClass = namespace.defineClass("ImmutableEventDispatcherTest", {superClass: namespaceScope.getClass("\\PHPUnit_Framework_TestCase"), interfaces: [], staticProperties: {}, properties: {"innerDispatcher": null, "dispatcher": null}, methods: {"setUp": {isStatic: false, method: function () {var scope = this;tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("innerDispatcher")).setValue(scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("getMock").getNative(), [tools.valueFactory.createString("Symfony\\Component\\EventDispatcher\\EventDispatcherInterface")]));tools.implyObject(scope.getVariable("this")).getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("ImmutableEventDispatcher"), [scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("innerDispatcher")).getValue()]));}}, "testDispatchDelegates": {isStatic: false, method: function () {var scope = this;scope.getVariable("event").setValue(tools.createInstance(namespaceScope, tools.valueFactory.createBarewordString("Event"), []));scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("innerDispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("expects").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("once").getNative(), [])]).callMethod(tools.valueFactory.createBarewordString("method").getNative(), [tools.valueFactory.createString("dispatch")]).callMethod(tools.valueFactory.createBarewordString("with").getNative(), [tools.valueFactory.createString("event"), scope.getVariable("event").getValue()]).callMethod(tools.valueFactory.createBarewordString("will").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("returnValue").getNative(), [tools.valueFactory.createString("result")])]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertSame").getNative(), [tools.valueFactory.createString("result"), scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("dispatch").getNative(), [tools.valueFactory.createString("event"), scope.getVariable("event").getValue()])]);}}, "testGetListenersDelegates": {isStatic: false, method: function () {var scope = this;scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("innerDispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("expects").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("once").getNative(), [])]).callMethod(tools.valueFactory.createBarewordString("method").getNative(), [tools.valueFactory.createString("getListeners")]).callMethod(tools.valueFactory.createBarewordString("with").getNative(), [tools.valueFactory.createString("event")]).callMethod(tools.valueFactory.createBarewordString("will").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("returnValue").getNative(), [tools.valueFactory.createString("result")])]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertSame").getNative(), [tools.valueFactory.createString("result"), scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("getListeners").getNative(), [tools.valueFactory.createString("event")])]);}}, "testHasListenersDelegates": {isStatic: false, method: function () {var scope = this;scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("innerDispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("expects").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("once").getNative(), [])]).callMethod(tools.valueFactory.createBarewordString("method").getNative(), [tools.valueFactory.createString("hasListeners")]).callMethod(tools.valueFactory.createBarewordString("with").getNative(), [tools.valueFactory.createString("event")]).callMethod(tools.valueFactory.createBarewordString("will").getNative(), [scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("returnValue").getNative(), [tools.valueFactory.createString("result")])]);scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("assertSame").getNative(), [tools.valueFactory.createString("result"), scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("hasListeners").getNative(), [tools.valueFactory.createString("event")])]);}}, "testAddListenerDisallowed": {isStatic: false, method: function () {var scope = this;scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addListener").getNative(), [tools.valueFactory.createString("event"), tools.createClosure(function () {var scope = this;return tools.valueFactory.createString("foo");}, scope)]);}}, "testAddSubscriberDisallowed": {isStatic: false, method: function () {var scope = this;scope.getVariable("subscriber").setValue(scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("getMock").getNative(), [tools.valueFactory.createString("Symfony\\Component\\EventDispatcher\\EventSubscriberInterface")]));scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("addSubscriber").getNative(), [scope.getVariable("subscriber").getValue()]);}}, "testRemoveListenerDisallowed": {isStatic: false, method: function () {var scope = this;scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("removeListener").getNative(), [tools.valueFactory.createString("event"), tools.createClosure(function () {var scope = this;return tools.valueFactory.createString("foo");}, scope)]);}}, "testRemoveSubscriberDisallowed": {isStatic: false, method: function () {var scope = this;scope.getVariable("subscriber").setValue(scope.getVariable("this").getValue().callMethod(tools.valueFactory.createBarewordString("getMock").getNative(), [tools.valueFactory.createString("Symfony\\Component\\EventDispatcher\\EventSubscriberInterface")]));scope.getVariable("this").getInstancePropertyByName(tools.valueFactory.createBarewordString("dispatcher")).getValue().callMethod(tools.valueFactory.createBarewordString("removeSubscriber").getNative(), [scope.getVariable("subscriber").getValue()]);}}}, constants: {}}, namespaceScope);}());namespaceScope.use("Symfony\\Component\\EventDispatcher\\Event");namespaceScope.use("Symfony\\Component\\EventDispatcher\\ImmutableEventDispatcher");}(namespace))) { return namespaceResult; }return tools.valueFactory.createNull();}));
},{"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpify/api":147,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/node_modules/phpruntime":153,"/Library/WebServer/Documents/localhost/uniter-projects/event-dispatcher-demo/php/src/MyApp/dispatchIt.php":173}]},{},[1]);
